{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README","path":"README","modified":0,"renderable":0},{"_id":"themes/Yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"themes/Yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/Coding.png","path":"img/Coding.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/Quora.png","path":"img/Quora.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/head.jpg","path":"img/head.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/niconico.png","path":"img/niconico.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/知乎.png","path":"img/知乎.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/博客园.png","path":"img/博客园.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/简书.png","path":"img/简书.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/Yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/Yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Yelee/README.md","hash":"034155f3c0a9ac4a30bbdcfd549f151960f5ef8d","modified":1556590837645},{"_id":"themes/Yelee/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1556590837656},{"_id":"themes/Yelee/_config.yml","hash":"b2196b5e01e06cdf521ef53ad2247f91b6f4b1f7","modified":1597719097413},{"_id":"themes/Yelee/.gitignore","hash":"237760b38ce80bcc3a8b556566bef0295c145393","modified":1556590837644},{"_id":"source/CNAME","hash":"ddeaea73b34aa7d35ca32bbd334689162c1607ab","modified":1596856124574},{"_id":"source/README","hash":"aa514d27a389ec5d7ba23e0d0444924c5b7d9519","modified":1596976574642},{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1596976492374},{"_id":"source/baidu_verify_Yi3nkSW723.html","hash":"4cfe2c48ee7183fcb11f5795f0e9c82810f0c9b9","modified":1596865407398},{"_id":"source/google5415f93fcae2e344.html","hash":"6a7c401bd0a16ca72987c039ec6e0850a8f1eb07","modified":1596867700178},{"_id":"themes/Yelee/.github/ISSUE_TEMPLATE.md","hash":"09e2580d457ce93b4d7d554b75618036b45f8717","modified":1556590837644},{"_id":"themes/Yelee/languages/default.yml","hash":"80cc17267333753accc0b1c85a73678fedcbce76","modified":1556590837645},{"_id":"themes/Yelee/languages/zh-Hant-TW.yml","hash":"f372cc0d758a7d8bbb885aa9756d607bec26469a","modified":1556590837646},{"_id":"themes/Yelee/languages/zh-Hans.yml","hash":"b5b2d20cde04db3773962284a002d025b09134b0","modified":1556590837646},{"_id":"themes/Yelee/languages/zh-Hant-HK.yml","hash":"c38a95f5076ad951839aaf7748295d7eea277c61","modified":1556590837646},{"_id":"themes/Yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1556590837655},{"_id":"themes/Yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1556590837655},{"_id":"themes/Yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1556590837655},{"_id":"themes/Yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1556590837656},{"_id":"themes/Yelee/languages/en.yml","hash":"2c096d06c0af4ddf9c128fc8f77fb276b59a47fb","modified":1556590837646},{"_id":"themes/Yelee/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1556590837655},{"_id":"themes/Yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1556590837656},{"_id":"themes/Yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1556590837656},{"_id":"source/404/index.md","hash":"fd1d6927c79e66599bb9c42b7fd7586968fe0e0d","modified":1556590837610},{"_id":"source/_discarded/exo git.md","hash":"83d3c4fdc7617a50c759bff91c5e5192a5c496d8","modified":1556590837610},{"_id":"source/_discarded/MarkDown语法.md","hash":"cfffb7a47aadc4afad3fbd489aa3216548231326","modified":1557024083255},{"_id":"source/_discarded/ink-java.md","hash":"494827d47c75ed883b13f5798f5a0d5b4d3d7c34","modified":1557024083256},{"_id":"source/_discarded/Red-Hat-升级-rpm软件、YUM软件（root用户）.md","hash":"0279603f1cdd5a30968b4aeb6ac1b4b48c9ea26d","modified":1557024083255},{"_id":"source/_discarded/lr教程（一）.md","hash":"98c7c65ab16995770421367f310e2fa1eabb1992","modified":1557024083256},{"_id":"source/smallwenzi.github.io-master/.gitignore","hash":"3809d45d6f3670729017961126fee68de00eebb3","modified":1556590837618},{"_id":"source/about/index.md","hash":"c16630b80e5d4581e6a1d5e4f4b019d7d49fe358","modified":1556590837618},{"_id":"source/smallwenzi.github.io-master/.gitattributes","hash":"4a3348fc9a3d1ec1bc517399089440028e2242fd","modified":1556590837618},{"_id":"source/tags/index.md","hash":"8f179b85e4ce6db40a64547c4d2fa9b6a13b597b","modified":1556590837619},{"_id":"source/about/index-1.md","hash":"03c96050db1892bf5a968bc4017f70220e10b970","modified":1556590837618},{"_id":"themes/Yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1556590837657},{"_id":"source/_posts/Red-Hat-升级-rpm软件、YUM软件（root用户）.md","hash":"b7e5593d22405c513cdccf2c40eed320d7537f86","modified":1557024083257},{"_id":"source/_posts/-jenkins-配置git证书.md","hash":"9479c483ec82ccdc2c00a12f201d7e7339e3e440","modified":1557024083256},{"_id":"source/_posts/Singleton.md","hash":"e20378b908a51f02ce3cfb94bf2b7de60ec2d5b0","modified":1556590837612},{"_id":"source/_posts/Spring-Bean-生命周期.md","hash":"3e3237a040fad22df8928d6cfa6d95ba76e855da","modified":1597757801156},{"_id":"source/_posts/SpringSession源码.md","hash":"4aa31b32e5a70366d44d9071b45f2cbaf074fff3","modified":1581952127568},{"_id":"source/_posts/A问题.md","hash":"2b0646f2c0bdf150f70e01c3b7eb03fd2c173fba","modified":1560093193726},{"_id":"source/_posts/-jenkins-配置maven打包git代码.md","hash":"b2be31058e0d26b27c702b3e4f7265df010a12fd","modified":1557024083257},{"_id":"source/_posts/bbitMq.md","hash":"05696533a9c905a261066bc327dd8fc02fe63722","modified":1581952127570},{"_id":"source/_posts/acheHttpd日志说明.md","hash":"bd4d931f50a371b6a86804877ab01c67517ab147","modified":1581952127569},{"_id":"source/_posts/ava-查看占用-CPU-最高的线程.md","hash":"5ecfb431f45e049725843e12fbeaac23b44ce5e1","modified":1581952127570},{"_id":"source/_posts/docker的使用.md","hash":"edfcc9f421eb8631d0906be4d429a1b0eb87e2fa","modified":1557024083257},{"_id":"source/_posts/hymeleaf学习的坑.md","hash":"91bbe6745a5d48708b19744d0d819f405c799d69","modified":1557024083259},{"_id":"source/_posts/Spring体系结构.md","hash":"aba2acc9ebb6bb2a893be2d468e86527d56104ed","modified":1596962720575},{"_id":"source/_posts/lr教程.md","hash":"ab68346dff9e3d7e82b2144e5f9a1786c6fe7c09","modified":1557024083259},{"_id":"source/_posts/olr的主从模式Master-Slave.md","hash":"c6c63e77f3a98ef320ca550b7923ef8d4300f626","modified":1557024083260},{"_id":"source/_posts/enkinx-配置任务.md","hash":"da7320163f536716ba1c4042d675e2228f580961","modified":1557024083258},{"_id":"source/_posts/gtmetix.md","hash":"f618ab8d0c9eeee8d6394c4d03cb7a3c507ef9a1","modified":1557024083258},{"_id":"source/_posts/pring-admin配置.md","hash":"cd7ba7542948448d0a223e802e543429c6c163a9","modified":1560093193726},{"_id":"source/_posts/rabbitmq-队列信息.md","hash":"9b2b21bbe1fcdb2899f5de84d04cac82b32a0439","modified":1560093193726},{"_id":"source/_posts/pringSession源码（二）.md","hash":"39a43d5897dcc89a6f180da382e21f504797f886","modified":1581952127570},{"_id":"source/_posts/ocker-mysql.md","hash":"aa5b248781ad818086530369c9ad3aec3b76ec80","modified":1557024083260},{"_id":"source/_posts/ring-cloud-docker-git-maven-jenkins-Kubernetes-目录.md","hash":"735dfb8752a68f57adbd63ff8551db7db3993f3c","modified":1557024083261},{"_id":"source/_posts/ring-config-bus.md","hash":"95cda8dd6555bd14e00feb08c4b46f435bae4006","modified":1560093193727},{"_id":"source/_posts/ring-session（1）.md","hash":"061e16e4385595c337ace8ee99bc82ba3ba1d90b","modified":1581952127571},{"_id":"source/_posts/spring源码编译.md","hash":"bdf132f51416ff7a4b3c5f8ac5c0c1edea41e283","modified":1597719301997},{"_id":"source/_posts/spring源码（一）.md","hash":"702ec871cb3c79fba54593b99c46054a9fcc9a3e","modified":1597458352610},{"_id":"source/_posts/hexo git.md","hash":"466a2a663b83d9b0cff6a6da9097e9194ab7f122","modified":1596863173446},{"_id":"source/_posts/tch-坑.md","hash":"8c9e85ec982fb4d8b0ac2febe3b222f718ae6c0d","modified":1581952127571},{"_id":"source/_posts/tepad-compare.md","hash":"28786821d13959a11fd5a840aa254eeedb2797e4","modified":1557024083262},{"_id":"source/_posts/七）maven-build-docker-and-push-Image.md","hash":"3d729331a263871b9e48e99b2ef5842f79ed012e","modified":1557024083263},{"_id":"source/_posts/九-linux配置java和maven.md","hash":"f7cca6cf05810de06ecf7b70b3e7c1ee1b76336a","modified":1557024083264},{"_id":"source/_posts/windows下atom上搭建PlantUML书写环境.md","hash":"7cc7cfc5db3fac1cdc92e0af15c78bf825a989b7","modified":1557024083263},{"_id":"source/_posts/三）linux-安装-GIT（root用户）.md","hash":"f8bbb12e6d0cba5c619a259975b1f53a3c05a51d","modified":1557024083263},{"_id":"source/_posts/升工作效率.md","hash":"c92749fd53fc248edf663bbf4b33561bfde672ef","modified":1557024083264},{"_id":"source/_posts/具集.md","hash":"6ed59eed741eb6a730e283133a0dc2b93ad9f9c9","modified":1581952127571},{"_id":"source/_posts/sttemplate-问题.md","hash":"19dfb63ba8b4bded391a96ca05b724caeafbe055","modified":1560093193727},{"_id":"source/_posts/omcat-三种部署方式.md","hash":"b41f2d9ac5d7181eec3aae3a15f11cf82178f9a4","modified":1596851968961},{"_id":"source/_posts/安装jenkins.md","hash":"88dac7779bec603aa2c09089822e13eace7810db","modified":1557024083265},{"_id":"source/_posts/（六）docker安装本地仓库（root用户）.md","hash":"0f180632ec92ede59a718af660b36e4395482259","modified":1557143145884},{"_id":"source/_posts/）oracle-VM安装red-hat-liunx.md","hash":"d52d68510814e50cdd05f996aa0129b48a4becbf","modified":1557024083267},{"_id":"source/_posts/（四）安装docker（root用户）.md","hash":"6dfa793e0a1bb984274b1cf6be07d60e15284b69","modified":1557143145884},{"_id":"source/_posts/）更新docker-版本（root用户）.md","hash":"432337dbc7185e33066a3f57252f14aa46e777c5","modified":1557143145885},{"_id":"source/_posts/那些提升开发人员工作效率的在线工具.md","hash":"4c35782e6fedc8c2e69670ee6203cf6e625b75b0","modified":1557024083265},{"_id":"source/images/pasted-0.png","hash":"eeeb7a46d25458f707233f486838388f30675dd0","modified":1557143145886},{"_id":"source/images/pasted-1.png","hash":"3c34c5f526ed014aadcdd18bb1616e5f4967973c","modified":1557143145887},{"_id":"source/_discarded/exo git/1.jpeg","hash":"005bb04becc11f386e4c174a32110677bd6d7f6a","modified":1556590837610},{"_id":"source/_discarded/exo git/3.png","hash":"a1165a66861d344170b662de946d669bba3396c1","modified":1556590837611},{"_id":"source/_discarded/exo git/head.jpg","hash":"9513f74ab765b6160f575ac687004e2309097dfb","modified":1556590837612},{"_id":"source/_discarded/exo git/2.png","hash":"f68754f1c8f0939dd6a162b207aa85f5f711c68a","modified":1556590837611},{"_id":"themes/Yelee/layout/_partial/after-footer.ejs","hash":"4024557da5cd7925084eb0bdf045ef438a0b5754","modified":1556590837647},{"_id":"themes/Yelee/layout/_partial/article.ejs","hash":"d781737389f408a5dd57a0f9430d2704b7fe192c","modified":1556590837648},{"_id":"themes/Yelee/layout/_partial/archive-post.ejs","hash":"8af583c5f60c69ffdc97bee4e8fdac1ba34ebecd","modified":1556590837647},{"_id":"themes/Yelee/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1556590837647},{"_id":"themes/Yelee/layout/_partial/background.ejs","hash":"a439ebf7c4798ad3830e66ccf226a60b05ffea0a","modified":1556590837648},{"_id":"themes/Yelee/layout/_partial/footer.ejs","hash":"2ea24319611a8fceeed4491c710920ab72b3e165","modified":1556590837649},{"_id":"themes/Yelee/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1556590837649},{"_id":"themes/Yelee/layout/_partial/head.ejs","hash":"0399601e6eb3dec32eb9107d0dded4e577cd25ef","modified":1596866754341},{"_id":"themes/Yelee/layout/_partial/ie-updater.ejs","hash":"3e5f2e41bbb1a5b93a8a7a6cb9ccd191ced54408","modified":1556590837650},{"_id":"themes/Yelee/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1556590837650},{"_id":"themes/Yelee/layout/_partial/mathjax.ejs","hash":"252f3757edea31d55a7e5624e2214f268bf07283","modified":1556590837650},{"_id":"themes/Yelee/layout/_partial/mobile-nav.ejs","hash":"48696ded8e57def05d7ea58e74730f49d66ea6b5","modified":1556590837651},{"_id":"themes/Yelee/layout/_partial/open-in-new-tab.ejs","hash":"a6046bc322ce9194faa9559c70e1618a7e1e4cbc","modified":1556590837651},{"_id":"themes/Yelee/layout/_partial/left-col.ejs","hash":"6ea8bacacc8370ccf5af4e6f66da3bc743b88342","modified":1556590837650},{"_id":"themes/Yelee/layout/_partial/post-nav-button.ejs","hash":"190efc2e8ee037387685ff7dd24ae6db8bc77c60","modified":1556590837651},{"_id":"themes/Yelee/layout/_partial/scrolling-button.ejs","hash":"6da102cd4a05bc6b4807b937862a7332f6845e5f","modified":1556590837654},{"_id":"themes/Yelee/layout/_partial/tab-title-change.ejs","hash":"1bebab6eb7a849319cd48fe051f3c71b9349a723","modified":1556590837654},{"_id":"themes/Yelee/layout/_partial/page.ejs","hash":"9e504a0ec060ac3c6622855734ebea6eca2b78e9","modified":1556590837651},{"_id":"themes/Yelee/layout/_partial/toc.ejs","hash":"a0c6362e0f0161bbb7e70d50a4d9e39f2ff8ca48","modified":1556590837655},{"_id":"themes/Yelee/layout/_partial/tag-cloud-page.ejs","hash":"432ded02bcc1f0d52cd833e8eeac688ee886169a","modified":1556590837654},{"_id":"themes/Yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1556590837659},{"_id":"themes/Yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1556590837659},{"_id":"themes/Yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1556590837659},{"_id":"themes/Yelee/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1556590837662},{"_id":"themes/Yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1556590837660},{"_id":"themes/Yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1556590837670},{"_id":"themes/Yelee/source/css/style.styl","hash":"33519d7a6be12193795382840810e9ab1a5eae8e","modified":1556590837668},{"_id":"themes/Yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1556590837669},{"_id":"themes/Yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1556590837669},{"_id":"themes/Yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1556590837670},{"_id":"themes/Yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1556590837671},{"_id":"themes/Yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1556590837671},{"_id":"themes/Yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1556590837670},{"_id":"themes/Yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1556590837670},{"_id":"themes/Yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1556590837671},{"_id":"themes/Yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1556590837673},{"_id":"themes/Yelee/source/img/head.jpg","hash":"9513f74ab765b6160f575ac687004e2309097dfb","modified":1556590837672},{"_id":"themes/Yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1556590837671},{"_id":"themes/Yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1556590837673},{"_id":"themes/Yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1556590837675},{"_id":"themes/Yelee/source/img/wechat.jpg","hash":"79f03ce57452d84c10a726c758a5210b193b27eb","modified":1556590837674},{"_id":"themes/Yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1556590837674},{"_id":"themes/Yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1556590837675},{"_id":"themes/Yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1556590837676},{"_id":"themes/Yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1556590837676},{"_id":"themes/Yelee/source/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1556590837677},{"_id":"themes/Yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1556590837675},{"_id":"themes/Yelee/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1556590837677},{"_id":"themes/Yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1556590837675},{"_id":"themes/Yelee/source/js/main.js","hash":"d58bbc593d94d48e85d4ebfb002910444080cb06","modified":1556590837677},{"_id":"themes/Yelee/source/js/pc.js","hash":"19a1660b10358046e7a1f398284491519b2ffd47","modified":1556590837677},{"_id":"themes/Yelee/source/js/mobile.js","hash":"0f4c1fcd6df47a196ed9495c225173402aa7d769","modified":1556590837677},{"_id":"themes/Yelee/source/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1556590837678},{"_id":"themes/Yelee/source/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1556590837678},{"_id":"themes/Yelee/source/css/_variables.styl","hash":"bca217a64e422ea7a4a1748b8fc980b408e8c836","modified":1556590837668},{"_id":"themes/Yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1556590837670},{"_id":"source/_posts/exo git/2.png","hash":"f68754f1c8f0939dd6a162b207aa85f5f711c68a","modified":1556590837613},{"_id":"source/_posts/exo git/1.jpeg","hash":"005bb04becc11f386e4c174a32110677bd6d7f6a","modified":1556590837613},{"_id":"source/_posts/exo git/head.jpg","hash":"9513f74ab765b6160f575ac687004e2309097dfb","modified":1556590837614},{"_id":"source/_posts/exo git/3.png","hash":"a1165a66861d344170b662de946d669bba3396c1","modified":1556590837613},{"_id":"source/_posts/gtmetix/1.jpg","hash":"33942df97031a319ffba6e735b26a3592426ce38","modified":1557024083259},{"_id":"source/_posts/hexo git/2.png","hash":"f68754f1c8f0939dd6a162b207aa85f5f711c68a","modified":1556590837615},{"_id":"source/_posts/hexo git/3.png","hash":"a1165a66861d344170b662de946d669bba3396c1","modified":1556590837615},{"_id":"themes/Yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1556590837661},{"_id":"themes/Yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1556590837661},{"_id":"source/_posts/hexo git/1.jpeg","hash":"005bb04becc11f386e4c174a32110677bd6d7f6a","modified":1556590837615},{"_id":"themes/Yelee/layout/_partial/comments/duoshuo.ejs","hash":"15c269b81046b22ee44d38d9a08fc66618318435","modified":1556590837649},{"_id":"themes/Yelee/layout/_partial/comments/click2show.ejs","hash":"678f3aec2980d378ea44be60eec3eb504c8ba668","modified":1556590837648},{"_id":"themes/Yelee/layout/_partial/comments/disqus.ejs","hash":"b0b73b4629983b4de447418f30bf744cdf7ed044","modified":1556590837649},{"_id":"themes/Yelee/layout/_partial/comments/youyan.ejs","hash":"bcf2070587645afd20a4eb046b9c8bb9c44d1cf5","modified":1556590837649},{"_id":"themes/Yelee/layout/_partial/comments/count-comment.ejs","hash":"d3c1b0b31db9d80e857f3054d010ea49c0f88134","modified":1556590837648},{"_id":"themes/Yelee/layout/_partial/post/category.ejs","hash":"265bb12f7cfa5e0bcbb74fdd409ba13a6d9d2e22","modified":1556590837652},{"_id":"themes/Yelee/layout/_partial/post/nav.ejs","hash":"593cdf0a9eca655c8a763f2d5fb22254d19b1252","modified":1556590837653},{"_id":"themes/Yelee/layout/_partial/post/share.ejs","hash":"60cb646f3bc22c46d6ff4b95bb36dad577ed76c0","modified":1556590837653},{"_id":"themes/Yelee/layout/_partial/post/tag.ejs","hash":"9dad471e27de9e066666f3082137eccaede2e67b","modified":1556590837653},{"_id":"themes/Yelee/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1556590837654},{"_id":"themes/Yelee/layout/_partial/post/date.ejs","hash":"357a8de8a7ed8194efc16f55f97f7e2551b31bf9","modified":1556590837652},{"_id":"themes/Yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1556590837657},{"_id":"themes/Yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1556590837658},{"_id":"themes/Yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1556590837658},{"_id":"themes/Yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1556590837658},{"_id":"themes/Yelee/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1556590837668},{"_id":"themes/Yelee/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1556590837668},{"_id":"themes/Yelee/source/css/_partial/archive.styl","hash":"416786f566582fe697a12bb03a9eb2d1c604e2c7","modified":1556590837662},{"_id":"themes/Yelee/source/css/_partial/instagram.styl","hash":"db9cc156c7df27f7f54b0e7ff34b5949f55f99eb","modified":1556590837665},{"_id":"themes/Yelee/source/css/_partial/mobile-slider.styl","hash":"034eb9605e006a0d0098bd963e9cdc11a1eaf6c3","modified":1556590837666},{"_id":"themes/Yelee/source/css/_partial/mobile.styl","hash":"4681032f51fd0df6451051ba35efa1f9f745c302","modified":1556590837666},{"_id":"themes/Yelee/source/css/_partial/page.styl","hash":"d05287b44c64576b8560461bc6c3b7e8ceda5539","modified":1556590837666},{"_id":"themes/Yelee/source/css/_partial/search.styl","hash":"fcaa5deaa654aaec69e267e23b49df07f84f633a","modified":1556590837667},{"_id":"themes/Yelee/source/css/_partial/scroll.styl","hash":"1932774d30b8706919342f9cf36ea2d99987ce14","modified":1556590837666},{"_id":"themes/Yelee/source/css/_partial/tagcloud.styl","hash":"9d7847cc899970a19d288c9eec9f24691c053ef3","modified":1556590837667},{"_id":"themes/Yelee/source/css/_partial/share.styl","hash":"24ff28457b5e1519a8b4561284f6159bdd827ad4","modified":1556590837667},{"_id":"themes/Yelee/source/css/_partial/toc.styl","hash":"eb19bbd37fc2c1abd238e2ed96b22cb1aae41ab7","modified":1556590837667},{"_id":"themes/Yelee/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1556590837667},{"_id":"themes/Yelee/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1556590837665},{"_id":"themes/Yelee/source/css/_partial/article.styl","hash":"45d36a307c22a754ed87f3ae6441ba8616f7329c","modified":1556590837662},{"_id":"themes/Yelee/source/css/_partial/footer.styl","hash":"384f9a9c017400b12f52ac33759380075e527998","modified":1556590837664},{"_id":"themes/Yelee/source/css/_partial/highlight.styl","hash":"4dcf5d3e3435897de91b39473a93fb7c3ad73dde","modified":1556590837665},{"_id":"themes/Yelee/source/css/_partial/main.styl","hash":"d82129844528ae1a5c9547bc6d3f5bd37b0fb801","modified":1556590837666},{"_id":"themes/Yelee/source/css/_partial/customise/blockquote.styl","hash":"9b96dd1c51b43a1130b3bb6eedb293b77eef8b1d","modified":1556590837663},{"_id":"themes/Yelee/source/css/_partial/customise/heading.styl","hash":"f309241c1daa9b6c04aa04063307537c219fdd59","modified":1556590837663},{"_id":"themes/Yelee/source/css/_partial/customise/color-scheme.styl","hash":"816044b7680514626981e945ee6be943a5de60a7","modified":1556590837663},{"_id":"themes/Yelee/source/css/_partial/customise/list.styl","hash":"b1e564ed76d6e892556b61b4278270fc9eeea961","modified":1556590837664},{"_id":"themes/Yelee/source/css/_partial/customise/social-icon.styl","hash":"365026a5a30bcc88bec1b46c391c7d3bce41f033","modified":1556590837664},{"_id":"themes/Yelee/source/css/_partial/customise/code-block.styl","hash":"ebf7ca8598d93235479460ea7d1be97d44224b05","modified":1556590837663},{"_id":"themes/Yelee/source/css/_partial/customise/inline-code.styl","hash":"2014a25ec300910b8a093ec8010f6703a2142021","modified":1556590837663},{"_id":"source/_posts/hexo git/4.png","hash":"9cd1c8552ae4b20a22451ddc5d948f5d116c51b1","modified":1556590837617},{"_id":"public/baidu_urls.txt","hash":"9865ad4a36116b59d2bc6cad2658ade8a82c0732","modified":1597719396083},{"_id":"public/baidusitemap.xml","hash":"91499c8d1d48a1b511df7a7cff6285bb923cd22f","modified":1597719396083},{"_id":"public/atom.xml","hash":"20a1d9afbc4d3eff6aa91e4f4eeb614921d427a0","modified":1597758089764},{"_id":"public/content.json","hash":"428be3008b4e9d46f3206d36c7802d3be4033f4a","modified":1597758089765},{"_id":"public/sitemap.xml","hash":"eef30c61a75389adf5bd149b3f55290106e050a3","modified":1597758133448},{"_id":"public/search.xml","hash":"efe9cc5dbdd7e0d84421238a66ff45c90e1ea5d5","modified":1597758091130},{"_id":"public/post-sitemap.xml","hash":"36922eea0dbbfd20f5aef00ccc2f6bc0a29cf04a","modified":1597758134901},{"_id":"public/page-sitemap.xml","hash":"c036b1b8e63508c23f6c8149cec9e71d8d3219ec","modified":1597758134901},{"_id":"public/category-sitemap.xml","hash":"4e87e3d3d6b199fdcd7e6f865a3eac9fa08b8c27","modified":1597758134901},{"_id":"public/tag-sitemap.xml","hash":"6bd4f5fc7207647d3a8109d292d88648d3d530dc","modified":1597758134901},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1597758134901},{"_id":"public/google5415f93fcae2e344.html","hash":"7aabc29c713736b0a64abc3c480bc108a1db5d58","modified":1597719398625},{"_id":"public/baidu_verify_Yi3nkSW723.html","hash":"376c07f6a987eab3b8d52c390719296884e34de5","modified":1597719398625},{"_id":"public/about/index.html","hash":"a0bebfb2a2d3151b8b9e8640e716ef64c93c5611","modified":1597719398625},{"_id":"public/404.html","hash":"07b827134fd2a297d0125a29339efd0bb7ff13f6","modified":1597719398625},{"_id":"public/tags/index.html","hash":"4865d2824e64fb1c7777c6f6b72029aa4584552c","modified":1597719398625},{"_id":"public/about/index-1.html","hash":"bff0cb8f9cfc8eb5f713b90b981b54345daa29e0","modified":1597719398625},{"_id":"public/2020/08/09/Spring-Bean-生命周期/index.html","hash":"09da3259985d3a7d9cd73a1c69fa61f62d14b627","modified":1597758091177},{"_id":"public/2020/08/09/Spring体系结构/index.html","hash":"88c6ca5ae8c4f630719dded1dc354bc1bed58543","modified":1597719398625},{"_id":"public/2020/08/08/spring源码（一）/index.html","hash":"5106c743f9ae4a68f6c9e00b3292c549a431c3ba","modified":1597719398625},{"_id":"public/2020/08/07/spring源码编译/index.html","hash":"9cff4ef4be21e88a2ac3256d83aada8c3adc8c7f","modified":1597719398625},{"_id":"public/2020/01/03/omcat-三种部署方式/index.html","hash":"742b827bc01e5dec351f0a5b36e22b2ab997e1cc","modified":1597719398625},{"_id":"public/2019/11/22/bbitMq/index.html","hash":"9aae0ab166785263ed9b204bf486539c5d50c40c","modified":1597719398626},{"_id":"public/2019/11/21/SpringSession源码/index.html","hash":"3ca2506189f415a69d78fdd75c9672efb550d192","modified":1597719398626},{"_id":"public/2019/11/22/pringSession源码（二）/index.html","hash":"ff75c070cd33b2e99c25d388b9b85d164dccf17e","modified":1597719398626},{"_id":"public/2019/11/21/tch-坑/index.html","hash":"1c05028411c069163212238046192d5451b82790","modified":1597719398626},{"_id":"public/2019/11/21/acheHttpd日志说明/index.html","hash":"0c81142a3edcc691d8f35809f7b832d70d37c940","modified":1597719398626},{"_id":"public/2019/11/13/ring-session（1）/index.html","hash":"d3668949986a81ec633655b1c01e8d1e85d8f74e","modified":1597719398626},{"_id":"public/2019/11/13/具集/index.html","hash":"cef83836e662d1ad5cf315f23be1bd02f82399a2","modified":1597719398626},{"_id":"public/2019/11/13/ava-查看占用-CPU-最高的线程/index.html","hash":"183bee313b780fcee8762c93e1a0178e30b08e6b","modified":1597719398626},{"_id":"public/2019/05/29/ring-config-bus/index.html","hash":"1751f669d410ae2ab58880acfa78d94b7f48549f","modified":1597719398626},{"_id":"public/2019/05/29/pring-admin配置/index.html","hash":"3d6af46f62030418ab7d564a99b61311ce52cf0f","modified":1597719398626},{"_id":"public/2019/05/29/rabbitmq-队列信息/index.html","hash":"89efc15d6e9d3324adeb9f311673569ba5ca6b31","modified":1597719398627},{"_id":"public/2019/05/29/sttemplate-问题/index.html","hash":"1acd2fcd7d2d619d6d25ce4866728e4366a5cf2e","modified":1597719398627},{"_id":"public/2019/05/06/A问题/index.html","hash":"3054073955334037b2f7b617302193f6f94b5452","modified":1597719398628},{"_id":"public/2018/10/14/windows下atom上搭建PlantUML书写环境/index.html","hash":"58c8caacafbcfd74cbca4b5b2a60ed10e6c72bc3","modified":1597719398628},{"_id":"public/2018/10/14/olr的主从模式Master-Slave/index.html","hash":"147cfd83b77bf2814f4f02dacb8f6e7e60196123","modified":1597719398628},{"_id":"public/2018/10/13/lr教程/index.html","hash":"92d824c468e78b10a41f244c7e7e5ba49e0b2b50","modified":1597719398628},{"_id":"public/2018/06/11/docker的使用/index.html","hash":"0e595f27a57d813bb925426f2ae6021a8eba3982","modified":1597719398628},{"_id":"public/2018/05/11/-jenkins-配置maven打包git代码/index.html","hash":"cbb74fa2af88308bc581352b262bbfffed78b6cf","modified":1597719398628},{"_id":"public/2018/05/11/-jenkins-配置git证书/index.html","hash":"0fe1caed342d4b8272b06c849119b7c447181844","modified":1597719398628},{"_id":"public/2018/05/11/enkinx-配置任务/index.html","hash":"100f49380a3d858fb19fd17fde140839bf3b2ca8","modified":1597719398628},{"_id":"public/2018/05/11/九-linux配置java和maven/index.html","hash":"1b7b3003cdce9da36b01f317ce7eebbe2b5d3040","modified":1597719398628},{"_id":"public/2018/05/08/安装jenkins/index.html","hash":"c7fa5e1273940994a70cd72d6bb0e8c9b495c7ff","modified":1597719398628},{"_id":"public/2018/05/08/ring-cloud-docker-git-maven-jenkins-Kubernetes-目录/index.html","hash":"2963fdfa835b6c4f59ce99f253ea474eabf147d6","modified":1597719398629},{"_id":"public/2018/05/08/七）maven-build-docker-and-push-Image/index.html","hash":"5c14d112b9c61537ae47b2780f63b3ee61846ede","modified":1597719398629},{"_id":"public/2018/05/08/ocker-mysql/index.html","hash":"8a60be32a5237833a662caefbc4103126a19d153","modified":1597719398629},{"_id":"public/2018/05/08/（六）docker安装本地仓库（root用户）/index.html","hash":"810ef842a73d093d8bbd5ba6d6e5c8e420ae194a","modified":1597719398629},{"_id":"public/2018/05/08/）更新docker-版本（root用户）/index.html","hash":"7da52a601f0870e5a1f612935aa5ee2add190605","modified":1597719398629},{"_id":"public/2018/05/08/（四）安装docker（root用户）/index.html","hash":"be11684ec8d7bc5df12b47df96475a931504b349","modified":1597719398629},{"_id":"public/2018/05/08/三）linux-安装-GIT（root用户）/index.html","hash":"b664449ba3daee832a9993557ab4006ecb0fbd25","modified":1597719398629},{"_id":"public/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/index.html","hash":"6592321aaf17fad20ce1c398b3a24a9e11f5b02e","modified":1597719398629},{"_id":"public/2018/05/08/）oracle-VM安装red-hat-liunx/index.html","hash":"a6f12fce5f39d68af966842945fbf5b466665de5","modified":1597719398629},{"_id":"public/2018/05/08/hymeleaf学习的坑/index.html","hash":"dcb04fa662a596eed03b4bf05a52ae99b39d94da","modified":1597719398629},{"_id":"public/2018/05/08/那些提升开发人员工作效率的在线工具/index.html","hash":"1acce9ac2824fc87206683a414a07ad2db65b38d","modified":1597719398630},{"_id":"public/2018/05/08/升工作效率/index.html","hash":"9db06656e1fe5f2cf10f1445090e40d9ca4c71ac","modified":1597719398630},{"_id":"public/2017/03/06/tepad-compare/index.html","hash":"5fbfe27f2de47a03de48ba8c1154b1ada0ce79ff","modified":1597719398630},{"_id":"public/2017/02/28/gtmetix/index.html","hash":"01a07a2a548ecbbd3dacd62107bf6e45f0ad8b2d","modified":1597719398630},{"_id":"public/2017/02/20/Singleton/index.html","hash":"7b393064af1378bc44267a778e110f9a5aac4f13","modified":1597719398630},{"_id":"public/2017/02/20/hexo git/index.html","hash":"1b931923c9c7f8d39a5c79b781c4816cda9e14c4","modified":1597719398630},{"_id":"public/archives/index.html","hash":"a97e5a7f1931ec731c4bad8c2c038f97902c8bcd","modified":1597719398630},{"_id":"public/archives/page/2/index.html","hash":"a5045e98b2c0d90a29265b0621adf051671a2565","modified":1597719398630},{"_id":"public/archives/page/3/index.html","hash":"32da8441d890cf885b21f7dfb87c2e65753ae5c5","modified":1597719398630},{"_id":"public/archives/page/4/index.html","hash":"7932800e569088c95b20d6a964f2b827ad3f164f","modified":1597719398630},{"_id":"public/archives/page/5/index.html","hash":"dc5608cf960a0f93bf33ceab483538ecfc6c4d11","modified":1597719398631},{"_id":"public/archives/2017/index.html","hash":"c16f663a575a19d6005bda74a6c79f40670cc083","modified":1597719398631},{"_id":"public/archives/2017/03/index.html","hash":"dc7eb09afac2f9bbe8dc4f4ea3e761784b56ff6b","modified":1597719398631},{"_id":"public/archives/2017/02/index.html","hash":"b281e7107ae9802cecffe1ebee6d20557b56405b","modified":1597719398631},{"_id":"public/archives/2018/page/2/index.html","hash":"9de5dc181b3f5b5fa8174038e3dbe94b6dcf7e03","modified":1597719398631},{"_id":"public/archives/2018/index.html","hash":"621e7caedb2d21f2053895ecb62d268f7ea98d4e","modified":1597719398631},{"_id":"public/archives/2018/05/index.html","hash":"52ac100e0e0800e3dbae6fc22670a0afe74b73cd","modified":1597719398631},{"_id":"public/archives/2018/page/3/index.html","hash":"c173a74b0832aa8ecced6fa055de801d3da8895b","modified":1597719398631},{"_id":"public/archives/2018/06/index.html","hash":"92501ea4347a0f1074566b136da83703979d8018","modified":1597719398631},{"_id":"public/archives/2018/05/page/2/index.html","hash":"2184ee440e3a90223c6934e3fa51853270278db4","modified":1597719398631},{"_id":"public/archives/2019/index.html","hash":"be2cb49ba341f165906b49a85e1d190519d6fede","modified":1597719398631},{"_id":"public/archives/2018/10/index.html","hash":"f7fa6d50f24c359347a8bd396a05708b00f16957","modified":1597719398631},{"_id":"public/archives/2019/page/2/index.html","hash":"240fd9392e10b4e63534d9dc432bf1eea83f9e78","modified":1597719398631},{"_id":"public/archives/2019/05/index.html","hash":"be59e7eb56ab6ce4a27527ce2d3f8132d904b480","modified":1597719398631},{"_id":"public/archives/2019/11/index.html","hash":"1a1f239c7d3cf4df974f263d60c2265a5d15e358","modified":1597719398631},{"_id":"public/archives/2020/index.html","hash":"cfbf894721500dfd4110e643cacd81e3a3925be9","modified":1597719398631},{"_id":"public/archives/2020/01/index.html","hash":"48ff88e2e0ba568adc12b61ce1f41b200d62d5ed","modified":1597719398632},{"_id":"public/archives/2020/08/index.html","hash":"b4e71cb088cb85048669656c5389a63ffcda4a32","modified":1597719398632},{"_id":"public/categories/jenkins/index.html","hash":"4da570d0fcb16c3a6d29dd4072e31d59dfc4bb96","modified":1597719398632},{"_id":"public/categories/linux/index.html","hash":"f2085750e22e07187125617646449e4387a22f0a","modified":1597719398632},{"_id":"public/categories/java/index.html","hash":"6312dcc5b028330c4b9f13748592a7499210dac7","modified":1597719398632},{"_id":"public/categories/Spring/index.html","hash":"ec403f0f6102b0b1a35a131892d520df418cb6f0","modified":1597719398632},{"_id":"public/categories/spring/index.html","hash":"d8db19bacbc8aa0194f335c91438901cd0a2f009","modified":1597719398632},{"_id":"public/categories/spring-cloud/index.html","hash":"d8a6631c691da6295d213b04664e0897ce7b1081","modified":1597719398632},{"_id":"public/categories/RabbitMq/index.html","hash":"683448826e2b5fe0454d7fa7c861ca1d801f72eb","modified":1597719398632},{"_id":"public/categories/java/设计模式/index.html","hash":"fa1da5ca5332b2ba709186699e1ad1e3207a77b3","modified":1597719398632},{"_id":"public/categories/apache/index.html","hash":"c2d461897956b26f0582ef1b8eb33b70d259dbea","modified":1597719398632},{"_id":"public/categories/docker/index.html","hash":"d738750353cc1ca4a838df9f22dcf52ca1b4c7d1","modified":1597719398632},{"_id":"public/categories/Spring/SpringFramework/index.html","hash":"6ec5ab5de5d17bdb02aece5142d4bfb2cf92bbe7","modified":1597719398632},{"_id":"public/categories/spring/spring-boot/index.html","hash":"bb8339b4be02d79aa3d425e6af92c6f21171e036","modified":1597719398633},{"_id":"public/categories/solr/index.html","hash":"41f3204fdcb2493ce6e212d224b446d733abebaf","modified":1597719398633},{"_id":"public/categories/性能优化/index.html","hash":"ca4dbdab426675ed383b8a76a1a36aace89c47bc","modified":1597719398633},{"_id":"public/categories/RabbitMq/消息队列/index.html","hash":"88fef08b5ab6c27933e0770802336f645c96febb","modified":1597719398633},{"_id":"public/categories/springsession/index.html","hash":"10efa8bda1546b8ddc3d799e00e7dd9c31ba9952","modified":1597719398634},{"_id":"public/categories/Spring/Spring-boot/index.html","hash":"de133f67de48defef8fc42e4a87613456ff1222d","modified":1597719398634},{"_id":"public/categories/spring/springFramework/index.html","hash":"ed3e1fbf169bafceac6014d53c98bc0c7439c376","modified":1597719398634},{"_id":"public/categories/hexo/index.html","hash":"8156124437af54409db4d538fcb61dbae0927c5f","modified":1597719398635},{"_id":"public/categories/spring/SpringFramework/index.html","hash":"e279ef2c6073507ad5ba0015ab01f63e8e1a7261","modified":1597719398636},{"_id":"public/categories/atom/index.html","hash":"38f5a4dc15b8048faea2d5b6fe95dbfe4232f496","modified":1597719398636},{"_id":"public/categories/work/index.html","hash":"5ad1d89305ffb3bd725f5debf55d697461a7b510","modified":1597719398637},{"_id":"public/categories/git/index.html","hash":"5561aa416b29cd488ae4ddae2ec8b53fd56ddcf5","modified":1597719398637},{"_id":"public/categories/tools/index.html","hash":"4502c318035891a11a86491289e3eb5e8b40d0a9","modified":1597719398638},{"_id":"public/index.html","hash":"6e08346f657b6c5ad2905a7dc240e9ff1885d938","modified":1597758091177},{"_id":"public/page/2/index.html","hash":"74d2bb996444ca682f1df8a79d94e1e1014b671f","modified":1597719398638},{"_id":"public/page/4/index.html","hash":"d04bc43fd95e40ffbaa9dce6b3cce085c1d44cb8","modified":1597719398639},{"_id":"public/page/3/index.html","hash":"4408d940ba5819d3a402669ab090bd34450d4de6","modified":1597719398639},{"_id":"public/tags/linux/index.html","hash":"d58418c267ad8273f665cc6d0caf701dd0c0d467","modified":1597719398639},{"_id":"public/page/5/index.html","hash":"5c6bb207b08610f0a9dabcec2c2504cdcfeabb76","modified":1597719398639},{"_id":"public/tags/rpm/index.html","hash":"156cb9cef0baeec6da91105f6086226d874ec9f9","modified":1597719398639},{"_id":"public/tags/yum/index.html","hash":"52a35d4c3e65af3adeb088613cd98fb5279f7d38","modified":1597719398639},{"_id":"public/tags/jenkins/index.html","hash":"3a89a00b94085e4b20ba75f7133655f8ba590829","modified":1597719398639},{"_id":"public/tags/git/index.html","hash":"b72e99de2c07dda0104b14aa4d71ed4c540b0e0f","modified":1597719398640},{"_id":"public/tags/java/index.html","hash":"05507d1272cd1e8cedc034ea386a354ca4f05147","modified":1597719398640},{"_id":"public/tags/单例模式/index.html","hash":"b4985ed1e1bbc2178d001e21571b22548aa5846c","modified":1597719398640},{"_id":"public/tags/设计模式/index.html","hash":"a43284c20c5a8ca54b709144746f9d580ccc386b","modified":1597719398640},{"_id":"public/tags/线程/index.html","hash":"c812d23c79144421b6c43f1c6f708ac481dc451b","modified":1597719398640},{"_id":"public/tags/springsession/index.html","hash":"52075a3781a8c93dc443b03eed4fb7d50718866d","modified":1597719398640},{"_id":"public/tags/session/index.html","hash":"f3385323c921f6ea36f25a30deac4884c0fe780e","modified":1597719398641},{"_id":"public/tags/maven/index.html","hash":"419599f829b48269d7c3ac79bb7526530436c830","modified":1597719398641},{"_id":"public/tags/docker/index.html","hash":"7315d8674a23ecd48ebcda69dc31a756085791cd","modified":1597719398641},{"_id":"public/tags/jpa/index.html","hash":"e73088af4b3b11193d22e738acf830a65aaa3a7c","modified":1597719398641},{"_id":"public/tags/RabbitMq/index.html","hash":"77e08a5f92a447cbf60451446d73374b4d88ce24","modified":1597719398641},{"_id":"public/tags/消息队列/index.html","hash":"65078273c1e6fba769ce7279c8d7972043cb3cdb","modified":1597719398641},{"_id":"public/tags/httpd/index.html","hash":"338580c1fc751a74d6e01e83dd44978f731d1583","modified":1597719398641},{"_id":"public/tags/thymeleaf/index.html","hash":"b4dc8b9445e03bf7c75da751513fc976625ef486","modified":1597719398641},{"_id":"public/tags/solr/index.html","hash":"9008331e19061bc1c2d2a36d49e07498f266a187","modified":1597719398641},{"_id":"public/tags/solr-master/index.html","hash":"fb32e97e961502f1b57e6b4382977ee9c33b812f","modified":1597719398642},{"_id":"public/tags/solr-slave/index.html","hash":"9e73f0f5fa7b12795adbdb211587672de22f46a0","modified":1597719398642},{"_id":"public/tags/性能优化/index.html","hash":"731510ea28d880b34730283309571eab8ebcb641","modified":1597719398642},{"_id":"public/tags/springAdmin/index.html","hash":"9a634be12164fcb59878aa96b2e67fd9e5129f8a","modified":1597719398642},{"_id":"public/tags/spring-cloud/index.html","hash":"049096aea0dfd8f2252c2d5ab90785d79ce43a78","modified":1597719398642},{"_id":"public/tags/mysql/index.html","hash":"f23ab783db0a750c3de56cc427269a4b14c1506f","modified":1597719398642},{"_id":"public/tags/rabbitMq/index.html","hash":"61904cc5e3d6d5ea05e88d893773d1d2f741bc4b","modified":1597719398642},{"_id":"public/tags/spring/index.html","hash":"cbcfd36954c065e91d023263e33a2b5b31633f0f","modified":1597719398642},{"_id":"public/tags/spring-config/index.html","hash":"5ed539838b22ec28aa8454e87c06b0aa68a657db","modified":1597719398642},{"_id":"public/tags/源码/index.html","hash":"f4cb19ba0bbd2753b81fc124f0f4f7815e295017","modified":1597719398642},{"_id":"public/tags/hexo/index.html","hash":"bfda364bf7d0e44d2043f43e39f730521c7b02f2","modified":1597719398642},{"_id":"public/tags/githubpage/index.html","hash":"7efa49bddb447d848f4778297a78eba79f5ee85a","modified":1597719398642},{"_id":"public/tags/hexo-admin/index.html","hash":"5a48a882c334112d2ab23c6af991ef90982f3965","modified":1597719398643},{"_id":"public/tags/nutch/index.html","hash":"1689430509da0a99de4e91cbe7371e3d127c4877","modified":1597719398643},{"_id":"public/tags/IOC容器/index.html","hash":"d038bbb90aec9df8a833619f16d98965fc770dce","modified":1597719398643},{"_id":"public/tags/DI/index.html","hash":"09abf613025d6f0d1605426cdda706c23fe2897b","modified":1597719398643},{"_id":"public/tags/依赖注入/index.html","hash":"d249b6c501573ee0023152f75fe7cf042ed5b9d3","modified":1597719398643},{"_id":"public/tags/notepad/index.html","hash":"1d388af4c28195b0e932e41f7d040dc77fe88bbc","modified":1597719398643},{"_id":"public/tags/Inversion-of-Control/index.html","hash":"63b8811feeef76ba2d9130bd97878604e9940364","modified":1597719398643},{"_id":"public/tags/plantuml/index.html","hash":"4cb26bb09bcac319d7ade8483f623dbb23d38bce","modified":1597719398643},{"_id":"public/tags/atom/index.html","hash":"9e7ab3a5ee6c33e7bd5c9380dfa3f4e4671d80a1","modified":1597719398643},{"_id":"public/tags/work/index.html","hash":"17860006e76fefd787556fc10a836db20dba32d0","modified":1597719398643},{"_id":"public/tags/工作效率/index.html","hash":"8663dd7b268af348aa95ee7b5885c12e82533c57","modified":1597719398643},{"_id":"public/tags/resttemplate/index.html","hash":"752482364d46b4226571c3885b223fb54476c0c7","modified":1597719398643},{"_id":"public/tags/工具/index.html","hash":"ae85afd4caf929e0308dcaca2fc646752f591981","modified":1597719398644},{"_id":"public/tags/tomcat/index.html","hash":"055e1481b7900406b3b587a0ffe8e8da234d221b","modified":1597719398644},{"_id":"public/tags/red-hat-Linux/index.html","hash":"526f1ac796dc6214b4866ff7dc35328b4052a580","modified":1597719398644},{"_id":"public/tags/工作/index.html","hash":"4ee79ac8d1896d225a61f62b4caca3382dfd2ee1","modified":1597719398644},{"_id":"public/tags/tools/index.html","hash":"054f4000e6b391323b242ec6dd598d6ec2b16a8d","modified":1597719398644}],"Category":[{"name":"linux","_id":"ckdzce36x0006n6zqxo1k1xxs"},{"name":"jenkins","_id":"ckdzce37b000dn6zqu1jhbxv4"},{"name":"java","_id":"ckdzce37g000in6zqzghrdc7r"},{"name":"Spring","_id":"ckdzce37k000nn6zqoerhvpoa"},{"name":"spring","_id":"ckdzce37o000un6zq0odl1h04"},{"name":"spring cloud","_id":"ckdzce37z0011n6zqmwt5w7p3"},{"name":"RabbitMq","_id":"ckdzce3840018n6zqkgwhc2lx"},{"name":"设计模式","parent":"ckdzce37g000in6zqzghrdc7r","_id":"ckdzce388001dn6zq1n3avgp4"},{"name":"apache","_id":"ckdzce38e001in6zqnsjn3dra"},{"name":"docker","_id":"ckdzce38j001qn6zqukl108v8"},{"name":"SpringFramework","parent":"ckdzce37k000nn6zqoerhvpoa","_id":"ckdzce38n001yn6zqgf1loxhf"},{"name":"spring boot","parent":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce38s0026n6zq7w1otkib"},{"name":"solr","_id":"ckdzce395002en6zq5qf7s0st"},{"name":"性能优化","_id":"ckdzce39g002rn6zqpavzizk3"},{"name":"消息队列","parent":"ckdzce3840018n6zqkgwhc2lx","_id":"ckdzce39l002zn6zqd0swf99p"},{"name":"springsession","_id":"ckdzce39p0037n6zqpsuy1syz"},{"name":"Spring boot","parent":"ckdzce37k000nn6zqoerhvpoa","_id":"ckdzce39u003fn6zqg5yrwejw"},{"name":"springFramework","parent":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce39z003pn6zqopnnw70a"},{"name":"hexo","_id":"ckdzce3a1003un6zq5wwgx4kc"},{"name":"SpringFramework","parent":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce3a40040n6zqqvzi0zkn"},{"name":"atom","_id":"ckdzce3a60046n6zq2vqvhbxj"},{"name":"work","_id":"ckdzce3a7004an6zql2cdjeny"},{"name":"git","_id":"ckdzce3a9004fn6zqyhu0uoxc"},{"name":"tools","_id":"ckdzce3aa004jn6zqauio3qhw"}],"Data":[],"Page":[{"_content":"google-site-verification: google5415f93fcae2e344.html","source":"google5415f93fcae2e344.html","raw":"google-site-verification: google5415f93fcae2e344.html","date":"2020-08-08T06:21:52.086Z","updated":"2020-08-08T06:21:40.178Z","path":"google5415f93fcae2e344.html","title":"","comments":1,"layout":"page","_id":"ckdzce33q0000n6zqgbcqhbg8","content":"google-site-verification: google5415f93fcae2e344.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google5415f93fcae2e344.html"},{"_content":"Yi3nkSW723","source":"baidu_verify_Yi3nkSW723.html","raw":"Yi3nkSW723","date":"2020-08-08T05:43:40.716Z","updated":"2020-08-08T05:43:27.398Z","path":"baidu_verify_Yi3nkSW723.html","title":"","comments":1,"layout":"page","_id":"ckdzce33x0001n6zqmc0a791h","content":"Yi3nkSW723","site":{"data":{}},"excerpt":"","more":"Yi3nkSW723"},{"title":"关于我","date":"2017-02-20T09:27:32.000Z","_content":"我喜欢计算编程,专注后端开发 性能调优 spring 框架","source":"about/index.md","raw":"title: 关于我\ndate: 2017-02-20 17:27:32\n---\n我喜欢计算编程,专注后端开发 性能调优 spring 框架","updated":"2019-04-30T02:20:37.618Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckdzce36g0002n6zqh2e7aqpw","content":"<p>我喜欢计算编程,专注后端开发 性能调优 spring 框架</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我喜欢计算编程,专注后端开发 性能调优 spring 框架</p>\n"},{"title":"404 Not Found：该页无法显示","comments":0,"fancybox":false,"_content":"\n<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n***\n\n<div class=\"pic\">\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n以下是博主喜欢的一些歌曲，可以听听，稍作休息~\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=320 height=330 src=\"http://music.163.com/outchain/player?type=0&id=112513213&auto=0&height=430\"></iframe>\n</div>","source":"404/index.md","raw":"title: 404 Not Found：该页无法显示\ncomments: false\npermalink: /404\nfancybox: false\n---\n\n<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n***\n\n<div class=\"pic\">\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n以下是博主喜欢的一些歌曲，可以听听，稍作休息~\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=320 height=330 src=\"http://music.163.com/outchain/player?type=0&id=112513213&auto=0&height=430\"></iframe>\n</div>","date":"2019-04-30T02:20:37.610Z","updated":"2019-04-30T02:20:37.610Z","path":"/404.html","layout":"page","_id":"ckdzce36t0004n6zqnctemz0q","content":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n<hr>\n<div class=\"pic\"><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br>以下是博主喜欢的一些歌曲，可以听听，稍作休息~<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"320\" height=\"330\" src=\"http://music.163.com/outchain/player?type=0&id=112513213&auto=0&height=430\"></iframe><br></div>","site":{"data":{}},"excerpt":"","more":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n<hr>\n<div class=\"pic\"><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br>以下是博主喜欢的一些歌曲，可以听听，稍作休息~<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"320\" height=\"330\" src=\"http://music.163.com/outchain/player?type=0&id=112513213&auto=0&height=430\"></iframe><br></div>"},{"title":"tags","date":"2017-02-21T10:32:53.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-02-21 18:32:53\n---\n","updated":"2019-04-30T02:20:37.619Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckdzce3700008n6zq86m9bv1m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-02-21T10:35:57.000Z","_content":"","source":"about/index-1.md","raw":"---\ntitle: about\ndate: 2017-02-21 18:35:57\n---\n","updated":"2019-04-30T02:20:37.618Z","path":"about/index-1.html","comments":1,"layout":"page","_id":"ckdzce374000an6zqd3d73upr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"(二）Red-Hat-升级-rpm软件、YUM软件（root用户）","author":"wen","date":"2018-05-08T07:30:00.000Z","_content":"以下操作是root用户\n\n1 [oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\nrpm 下载链接：http://mirrors.163.com/centos/7/os/x86_64/Packages/\n\n# 查看版本\n```\n> rpm version\n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-76fc51b36f51535f.png)\n\n# 升级rpm\n```\n>rpm -Uvh rpm-4.11.3-25.el7.x86_64.rpm  rpm-build-libs-4.11.3-25.el7.x86_64.rpm rpm-libs-4.11.3-25.el7.x86_64.rpm rpm-python-4.11.3-25.el7.x86_64.rpm --force -i  \n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-2b0c840c69622e92.png)\n# 删除旧的yum\n```\n> rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 yum-3.4.3-125.el7.noarch yum-rhn-plugin-2.0.1-5.el7.noarch --nodeps\n```\n# 安装yum\n```\n> rpm -Uvh yum-3.4.3-154.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm python-urlgrabber-3.10-8.el7.noarch.rpm yum-plugin-fastestmirror-1.1.31-42.el7.noarch.rpm yum-utils-1.1.31-42.el7.noarch.rpm  python-kitchen-1.1.1-5.el7.noarch.rpm python-chardet-2.2.1-1.el7_1.noarch.rpm\n```\n# 编辑 CentOS6-Base.repo\n```\nvi CentOS6-Base.repo 文件\n```\n\n# CentOS-Base.repo\n```\n# CentOS-Base.repo\n#\n# The mirror system uses the connecting IP address of the client and the\n# update status of each mirror to pick mirrors that are updated to and\n# geographically close to the client.  You should use this for CentOS updates\n# unless you are manually picking other mirrors.\n#\n# If the mirrorlist= does not work for you, as a fall back you can try the \n# remarked out baseurl= line instead.\n#\n#\n \n[base]\nname=CentOS-7 - Base - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/os/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/os/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=os\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#released updates \n[updates]\nname=CentOS-7 - Updates - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/updates/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/updates/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=updates\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that may be useful\n[extras]\nname=CentOS-7 - Extras - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/extras/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/extras/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=extras\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-7 - Plus - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/centosplus/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/centosplus/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=centosplus\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#contrib - packages by Centos Users\n[contrib]\nname=CentOS-7 - Contrib - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/contrib/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/contrib/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=contrib\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n\n```\n\n# 复制资源库文件至yum目录\n```\n> cp CentOS6-Base.repo /etc/yum.repos.d/\n```\n# 清除缓存\n```\n>yum clean all\n```\n# 建立yum 缓存\n```\n>yum makecache\n\n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-d31d27becb290491.png)\n\n# 再次更新yum\n```\nyum update yum\n```\n\nyum install yum-rhn*\n\nyum update redhat*","source":"_posts/Red-Hat-升级-rpm软件、YUM软件（root用户）.md","raw":"title: (二）Red-Hat-升级-rpm软件、YUM软件（root用户）\nauthor: wen\ntags:\n  - linux\n  - rpm\n  - yum\ncategories:\n  - linux\ndate: 2018-05-08 15:30:00\n---\n以下操作是root用户\n\n1 [oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\nrpm 下载链接：http://mirrors.163.com/centos/7/os/x86_64/Packages/\n\n# 查看版本\n```\n> rpm version\n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-76fc51b36f51535f.png)\n\n# 升级rpm\n```\n>rpm -Uvh rpm-4.11.3-25.el7.x86_64.rpm  rpm-build-libs-4.11.3-25.el7.x86_64.rpm rpm-libs-4.11.3-25.el7.x86_64.rpm rpm-python-4.11.3-25.el7.x86_64.rpm --force -i  \n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-2b0c840c69622e92.png)\n# 删除旧的yum\n```\n> rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 yum-3.4.3-125.el7.noarch yum-rhn-plugin-2.0.1-5.el7.noarch --nodeps\n```\n# 安装yum\n```\n> rpm -Uvh yum-3.4.3-154.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm python-urlgrabber-3.10-8.el7.noarch.rpm yum-plugin-fastestmirror-1.1.31-42.el7.noarch.rpm yum-utils-1.1.31-42.el7.noarch.rpm  python-kitchen-1.1.1-5.el7.noarch.rpm python-chardet-2.2.1-1.el7_1.noarch.rpm\n```\n# 编辑 CentOS6-Base.repo\n```\nvi CentOS6-Base.repo 文件\n```\n\n# CentOS-Base.repo\n```\n# CentOS-Base.repo\n#\n# The mirror system uses the connecting IP address of the client and the\n# update status of each mirror to pick mirrors that are updated to and\n# geographically close to the client.  You should use this for CentOS updates\n# unless you are manually picking other mirrors.\n#\n# If the mirrorlist= does not work for you, as a fall back you can try the \n# remarked out baseurl= line instead.\n#\n#\n \n[base]\nname=CentOS-7 - Base - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/os/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/os/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=os\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#released updates \n[updates]\nname=CentOS-7 - Updates - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/updates/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/updates/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=updates\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that may be useful\n[extras]\nname=CentOS-7 - Extras - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/extras/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/extras/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=extras\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-7 - Plus - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/centosplus/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/centosplus/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=centosplus\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n \n#contrib - packages by Centos Users\n[contrib]\nname=CentOS-7 - Contrib - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/7/contrib/$basearch/\n        http://mirrors.aliyuncs.com/centos/7/contrib/$basearch/\n#mirrorlist=http://mirrorlist.centos.org/?release=7&arch=$basearch&repo=contrib\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n\n```\n\n# 复制资源库文件至yum目录\n```\n> cp CentOS6-Base.repo /etc/yum.repos.d/\n```\n# 清除缓存\n```\n>yum clean all\n```\n# 建立yum 缓存\n```\n>yum makecache\n\n```\n![logo](Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-d31d27becb290491.png)\n\n# 再次更新yum\n```\nyum update yum\n```\n\nyum install yum-rhn*\n\nyum update redhat*","slug":"Red-Hat-升级-rpm软件、YUM软件（root用户）","published":1,"updated":"2019-05-05T02:41:23.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce36h0003n6zqdq2y4uhw","content":"<p>以下操作是root用户</p>\n<p>1 <a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p>rpm 下载链接：<a href=\"http://mirrors.163.com/centos/7/os/x86_64/Packages/\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a></p>\n<h1 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm version</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-76fc51b36f51535f.png\" alt=\"logo\"></p>\n<h1 id=\"升级rpm\"><a href=\"#升级rpm\" class=\"headerlink\" title=\"升级rpm\"></a>升级rpm</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;rpm -Uvh rpm-4.11.3-25.el7.x86_64.rpm  rpm-build-libs-4.11.3-25.el7.x86_64.rpm rpm-libs-4.11.3-25.el7.x86_64.rpm rpm-python-4.11.3-25.el7.x86_64.rpm --force -i</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-2b0c840c69622e92.png\" alt=\"logo\"></p>\n<h1 id=\"删除旧的yum\"><a href=\"#删除旧的yum\" class=\"headerlink\" title=\"删除旧的yum\"></a>删除旧的yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 yum-3.4.3-125.el7.noarch yum-rhn-plugin-2.0.1-5.el7.noarch --nodeps</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装yum\"><a href=\"#安装yum\" class=\"headerlink\" title=\"安装yum\"></a>安装yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm -Uvh yum-3.4.3-154.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm python-urlgrabber-3.10-8.el7.noarch.rpm yum-plugin-fastestmirror-1.1.31-42.el7.noarch.rpm yum-utils-1.1.31-42.el7.noarch.rpm  python-kitchen-1.1.1-5.el7.noarch.rpm python-chardet-2.2.1-1.el7_1.noarch.rpm</span><br></pre></td></tr></table></figure>\n<h1 id=\"编辑-CentOS6-Base-repo\"><a href=\"#编辑-CentOS6-Base-repo\" class=\"headerlink\" title=\"编辑 CentOS6-Base.repo\"></a>编辑 CentOS6-Base.repo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi CentOS6-Base.repo 文件</span><br></pre></td></tr></table></figure>\n<h1 id=\"CentOS-Base-repo\"><a href=\"#CentOS-Base-repo\" class=\"headerlink\" title=\"CentOS-Base.repo\"></a>CentOS-Base.repo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># CentOS-Base.repo</span><br><span class=\"line\">#</span><br><span class=\"line\"># The mirror system uses the connecting IP address of the client and the</span><br><span class=\"line\"># update status of each mirror to pick mirrors that are updated to and</span><br><span class=\"line\"># geographically close to the client.  You should use this for CentOS updates</span><br><span class=\"line\"># unless you are manually picking other mirrors.</span><br><span class=\"line\">#</span><br><span class=\"line\"># If the mirrorlist= does not work for you, as a fall back you can try the </span><br><span class=\"line\"># remarked out baseurl= line instead.</span><br><span class=\"line\">#</span><br><span class=\"line\">#</span><br><span class=\"line\"> </span><br><span class=\"line\">[base]</span><br><span class=\"line\">name=CentOS-7 - Base - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/os/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/os/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=os</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#released updates </span><br><span class=\"line\">[updates]</span><br><span class=\"line\">name=CentOS-7 - Updates - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/updates/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/updates/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=updates</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#additional packages that may be useful</span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name=CentOS-7 - Extras - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/extras/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/extras/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=extras</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#additional packages that extend functionality of existing packages</span><br><span class=\"line\">[centosplus]</span><br><span class=\"line\">name=CentOS-7 - Plus - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/centosplus/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/centosplus/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=centosplus</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#contrib - packages by Centos Users</span><br><span class=\"line\">[contrib]</span><br><span class=\"line\">name=CentOS-7 - Contrib - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/contrib/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/contrib/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=contrib</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>\n<h1 id=\"复制资源库文件至yum目录\"><a href=\"#复制资源库文件至yum目录\" class=\"headerlink\" title=\"复制资源库文件至yum目录\"></a>复制资源库文件至yum目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cp CentOS6-Base.repo /etc/yum.repos.d/</span><br></pre></td></tr></table></figure>\n<h1 id=\"清除缓存\"><a href=\"#清除缓存\" class=\"headerlink\" title=\"清除缓存\"></a>清除缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;yum clean all</span><br></pre></td></tr></table></figure>\n<h1 id=\"建立yum-缓存\"><a href=\"#建立yum-缓存\" class=\"headerlink\" title=\"建立yum 缓存\"></a>建立yum 缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;yum makecache</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-d31d27becb290491.png\" alt=\"logo\"></p>\n<h1 id=\"再次更新yum\"><a href=\"#再次更新yum\" class=\"headerlink\" title=\"再次更新yum\"></a>再次更新yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update yum</span><br></pre></td></tr></table></figure>\n<p>yum install yum-rhn*</p>\n<p>yum update redhat*</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以下操作是root用户</p>\n<p>1 <a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p>rpm 下载链接：<a href=\"http://mirrors.163.com/centos/7/os/x86_64/Packages/\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a></p>\n<h1 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm version</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-76fc51b36f51535f.png\" alt=\"logo\"></p>\n<h1 id=\"升级rpm\"><a href=\"#升级rpm\" class=\"headerlink\" title=\"升级rpm\"></a>升级rpm</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;rpm -Uvh rpm-4.11.3-25.el7.x86_64.rpm  rpm-build-libs-4.11.3-25.el7.x86_64.rpm rpm-libs-4.11.3-25.el7.x86_64.rpm rpm-python-4.11.3-25.el7.x86_64.rpm --force -i</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-2b0c840c69622e92.png\" alt=\"logo\"></p>\n<h1 id=\"删除旧的yum\"><a href=\"#删除旧的yum\" class=\"headerlink\" title=\"删除旧的yum\"></a>删除旧的yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 yum-3.4.3-125.el7.noarch yum-rhn-plugin-2.0.1-5.el7.noarch --nodeps</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装yum\"><a href=\"#安装yum\" class=\"headerlink\" title=\"安装yum\"></a>安装yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; rpm -Uvh yum-3.4.3-154.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm python-urlgrabber-3.10-8.el7.noarch.rpm yum-plugin-fastestmirror-1.1.31-42.el7.noarch.rpm yum-utils-1.1.31-42.el7.noarch.rpm  python-kitchen-1.1.1-5.el7.noarch.rpm python-chardet-2.2.1-1.el7_1.noarch.rpm</span><br></pre></td></tr></table></figure>\n<h1 id=\"编辑-CentOS6-Base-repo\"><a href=\"#编辑-CentOS6-Base-repo\" class=\"headerlink\" title=\"编辑 CentOS6-Base.repo\"></a>编辑 CentOS6-Base.repo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi CentOS6-Base.repo 文件</span><br></pre></td></tr></table></figure>\n<h1 id=\"CentOS-Base-repo\"><a href=\"#CentOS-Base-repo\" class=\"headerlink\" title=\"CentOS-Base.repo\"></a>CentOS-Base.repo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># CentOS-Base.repo</span><br><span class=\"line\">#</span><br><span class=\"line\"># The mirror system uses the connecting IP address of the client and the</span><br><span class=\"line\"># update status of each mirror to pick mirrors that are updated to and</span><br><span class=\"line\"># geographically close to the client.  You should use this for CentOS updates</span><br><span class=\"line\"># unless you are manually picking other mirrors.</span><br><span class=\"line\">#</span><br><span class=\"line\"># If the mirrorlist= does not work for you, as a fall back you can try the </span><br><span class=\"line\"># remarked out baseurl= line instead.</span><br><span class=\"line\">#</span><br><span class=\"line\">#</span><br><span class=\"line\"> </span><br><span class=\"line\">[base]</span><br><span class=\"line\">name=CentOS-7 - Base - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/os/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/os/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=os</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#released updates </span><br><span class=\"line\">[updates]</span><br><span class=\"line\">name=CentOS-7 - Updates - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/updates/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/updates/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=updates</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#additional packages that may be useful</span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name=CentOS-7 - Extras - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/extras/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/extras/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=extras</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#additional packages that extend functionality of existing packages</span><br><span class=\"line\">[centosplus]</span><br><span class=\"line\">name=CentOS-7 - Plus - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/centosplus/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/centosplus/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=centosplus</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"> </span><br><span class=\"line\">#contrib - packages by Centos Users</span><br><span class=\"line\">[contrib]</span><br><span class=\"line\">name=CentOS-7 - Contrib - mirrors.aliyun.com</span><br><span class=\"line\">failovermethod=priority</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/centos/7/contrib/$basearch/</span><br><span class=\"line\">        http://mirrors.aliyuncs.com/centos/7/contrib/$basearch/</span><br><span class=\"line\">#mirrorlist=http://mirrorlist.centos.org/?release=7&amp;arch=$basearch&amp;repo=contrib</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>\n<h1 id=\"复制资源库文件至yum目录\"><a href=\"#复制资源库文件至yum目录\" class=\"headerlink\" title=\"复制资源库文件至yum目录\"></a>复制资源库文件至yum目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cp CentOS6-Base.repo /etc/yum.repos.d/</span><br></pre></td></tr></table></figure>\n<h1 id=\"清除缓存\"><a href=\"#清除缓存\" class=\"headerlink\" title=\"清除缓存\"></a>清除缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;yum clean all</span><br></pre></td></tr></table></figure>\n<h1 id=\"建立yum-缓存\"><a href=\"#建立yum-缓存\" class=\"headerlink\" title=\"建立yum 缓存\"></a>建立yum 缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;yum makecache</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/05/08/Red-Hat-升级-rpm软件、YUM软件（root用户）/11278290-d31d27becb290491.png\" alt=\"logo\"></p>\n<h1 id=\"再次更新yum\"><a href=\"#再次更新yum\" class=\"headerlink\" title=\"再次更新yum\"></a>再次更新yum</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update yum</span><br></pre></td></tr></table></figure>\n<p>yum install yum-rhn*</p>\n<p>yum update redhat*</p>\n"},{"title":"十一 jenkins 配置git证书","author":"wen","date":"2018-05-11T15:26:00.000Z","_content":"[linux 安装 GIT（root用户）](/2018/05/08/三）linux-安装-GIT（root用户）/)\n[安装jenkins](/2018/05/08/安装jenkins/)\n\n# 一 linux 生成RSA key\nlinux远程登录ssh ywtan@localhost\n```\n  ssh-keygen -t rsa\n```\n![logo](-jenkins-配置git证书/1.png)\n\n全部回车\n```\ncat .ssh/id_rsa(这是刚才设置 rsa_key)\n```\n\n# 二 jenkins 配置git证书\n2.1 在jenkins 页面点击credentials\n![logo](-jenkins-配置git证书/2.png)\n2.2 点击 system\n![logo](-jenkins-配置git证书/3.png)\n2.3 点击 Global credentials (unrestricted)\n![logo](-jenkins-配置git证书/4.png)\n2.4 add Credentials\n![logo](-jenkins-配置git证书/5.png)\n2.5 如图所示填写， key是刚才生成的key，最后点击保存\n![logo](-jenkins-配置git证书/6.png)","source":"_posts/-jenkins-配置git证书.md","raw":"title: 十一 jenkins 配置git证书\nauthor: wen\ntags:\n  - jenkins\n  - git\ncategories:\n  - jenkins\ndate: 2018-05-11 23:26:00\n---\n[linux 安装 GIT（root用户）](/2018/05/08/三）linux-安装-GIT（root用户）/)\n[安装jenkins](/2018/05/08/安装jenkins/)\n\n# 一 linux 生成RSA key\nlinux远程登录ssh ywtan@localhost\n```\n  ssh-keygen -t rsa\n```\n![logo](-jenkins-配置git证书/1.png)\n\n全部回车\n```\ncat .ssh/id_rsa(这是刚才设置 rsa_key)\n```\n\n# 二 jenkins 配置git证书\n2.1 在jenkins 页面点击credentials\n![logo](-jenkins-配置git证书/2.png)\n2.2 点击 system\n![logo](-jenkins-配置git证书/3.png)\n2.3 点击 Global credentials (unrestricted)\n![logo](-jenkins-配置git证书/4.png)\n2.4 add Credentials\n![logo](-jenkins-配置git证书/5.png)\n2.5 如图所示填写， key是刚才生成的key，最后点击保存\n![logo](-jenkins-配置git证书/6.png)","slug":"-jenkins-配置git证书","published":1,"updated":"2019-05-05T02:41:23.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce36u0005n6zqr530lod5","content":"<p><a href=\"/2018/05/08/三）linux-安装-GIT（root用户）/\">linux 安装 GIT（root用户）</a><br><a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a></p>\n<h1 id=\"一-linux-生成RSA-key\"><a href=\"#一-linux-生成RSA-key\" class=\"headerlink\" title=\"一 linux 生成RSA key\"></a>一 linux 生成RSA key</h1><p>linux远程登录ssh ywtan@localhost<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/-jenkins-配置git证书/1.png\" alt=\"logo\"></p>\n<p>全部回车<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat .ssh/id_rsa(这是刚才设置 rsa_key)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二-jenkins-配置git证书\"><a href=\"#二-jenkins-配置git证书\" class=\"headerlink\" title=\"二 jenkins 配置git证书\"></a>二 jenkins 配置git证书</h1><p>2.1 在jenkins 页面点击credentials<br><img src=\"/2018/05/11/-jenkins-配置git证书/2.png\" alt=\"logo\"><br>2.2 点击 system<br><img src=\"/2018/05/11/-jenkins-配置git证书/3.png\" alt=\"logo\"><br>2.3 点击 Global credentials (unrestricted)<br><img src=\"/2018/05/11/-jenkins-配置git证书/4.png\" alt=\"logo\"><br>2.4 add Credentials<br><img src=\"/2018/05/11/-jenkins-配置git证书/5.png\" alt=\"logo\"><br>2.5 如图所示填写， key是刚才生成的key，最后点击保存<br><img src=\"/2018/05/11/-jenkins-配置git证书/6.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"/2018/05/08/三）linux-安装-GIT（root用户）/\">linux 安装 GIT（root用户）</a><br><a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a></p>\n<h1 id=\"一-linux-生成RSA-key\"><a href=\"#一-linux-生成RSA-key\" class=\"headerlink\" title=\"一 linux 生成RSA key\"></a>一 linux 生成RSA key</h1><p>linux远程登录ssh ywtan@localhost<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2018/05/11/-jenkins-配置git证书/1.png\" alt=\"logo\"></p>\n<p>全部回车<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat .ssh/id_rsa(这是刚才设置 rsa_key)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二-jenkins-配置git证书\"><a href=\"#二-jenkins-配置git证书\" class=\"headerlink\" title=\"二 jenkins 配置git证书\"></a>二 jenkins 配置git证书</h1><p>2.1 在jenkins 页面点击credentials<br><img src=\"/2018/05/11/-jenkins-配置git证书/2.png\" alt=\"logo\"><br>2.2 点击 system<br><img src=\"/2018/05/11/-jenkins-配置git证书/3.png\" alt=\"logo\"><br>2.3 点击 Global credentials (unrestricted)<br><img src=\"/2018/05/11/-jenkins-配置git证书/4.png\" alt=\"logo\"><br>2.4 add Credentials<br><img src=\"/2018/05/11/-jenkins-配置git证书/5.png\" alt=\"logo\"><br>2.5 如图所示填写， key是刚才生成的key，最后点击保存<br><img src=\"/2018/05/11/-jenkins-配置git证书/6.png\" alt=\"logo\"></p>\n"},{"title":"java 单例模式","author":"wen","date":"2017-02-20T02:01:00.000Z","_content":"<Excerpt in index | 首页摘要>\n在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后任然是单例的呢？这些问题在看了本文之后都会一一的告诉你答案，赶快来阅读吧<!-- more -->\n<The rest of contents | 余下全文>\n# 什么是单例模式\n在文章开始之前我们还是有必要介绍一下什么是单例模式。单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。\n从概念中体现出了单例的一些特点：\n\n> （1）、在任何情况下，单例类永远只有一个实例存在\n> （2）、单例需要有能力为整个系统提供这一唯一实例  \n\n为了便于读者更好的理解这些概念，下面给出这么一段内容叙述：\n在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。\n\n正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。\n\n## 1、饿汉式单例\n饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：\n```\npackage wen.design.singleton.s01;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = new MySingleton();\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        return instance;\n    }\n}\n```\n以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：\n```\npackage wen.design.singleton.s01;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(MySingleton.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n以上代码运行结果：\n```\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n```\n从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了\n\n## 2、懒汉式单例\n懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：\n```\npackage org.mlinge.s02;  \n  \npublic class MySingleton {  \n      \n    private static MySingleton instance = null;  \n      \n    private MySingleton(){}  \n      \n    public static MySingleton getInstance() {  \n        try {   \n            if(instance != null){//懒汉式   \n                  \n            }else{  \n                //创建实例之前可能会有一些准备性的耗时工作   \n                Thread.sleep(300);  \n                instance = new MySingleton();  \n            }  \n        } catch (InterruptedException e) {   \n            e.printStackTrace();  \n        }  \n        return instance;  \n    }  \n}  \n```\n这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用\n```\npackage wen.design.singleton.s02;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(MySingleton.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n执行结果如下：\n```\n30863650\n7408068\n20469344\n28235257\n23191477\n10884088\n23667197\n20358204\n5807702\n213274\n```\n## 3、线程安全的懒汉式单例\n要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。\n* （1）方法中声明synchronized关键字\n出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：\n\n\n```\npackage wen.design.singleton.s03;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public synchronized static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                instance = new MySingleton();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n\n此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singletonge.s03包下运行，执行结果如下：\n\n```\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n```\n\n从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：\n\n* （2）、 同步代码块实现\n\n\n```\npackage wen.design.singleton.s03;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    //public synchronized static MySingleton getInstance() {\n    public static MySingleton getInstance() {\n        try {\n            synchronized (MySingleton.class) {\n                if(instance != null){//懒汉式\n\n                }else{\n                    //创建实例之前可能会有一些准备性的耗时工作\n                    Thread.sleep(300);\n                    instance = new MySingleton();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。\n* （3）、 针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：\n\n```\npackage wen.design.singleton.s04;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                synchronized (MySingleton.class) {\n                    instance = new MySingleton();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s04包下运行，执行结果如下：\n```\n30863650\n7408068\n20469344\n28235257\n23191477\n10884088\n23667197\n20358204\n20358204\n5807702\n```\n\n从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。\n\n* （4）、 Double Check Locking 双检查锁机制（推荐）\n为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：\n\n```\npackage wen.design.singleton.s05;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    //使用volatile关键字保其可见性\n    volatile private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                synchronized (MySingleton.class) {\n                    if(instance == null){//二次检查\n                        instance = new MySingleton();\n                    }\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n\n```\n\n此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s05包下运行，执行结果如下\n```\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n```\n从运行结果来看，该中方法保证了多线程并发下的线程安全性。\n这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。\n\n## 4、使用静态内置类实现单例模式\nDCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：\n\n```\npackage wen.design.singleton.s06;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    //内部类\n    private static class MySingletonHandler{\n        private static MySingleton instance = new MySingleton();\n    }\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        return MySingletonHandler.instance;\n    }\n}\n\n```\n\n以上代码就是使用静态内置类实现了单例模式，这里将前面验证多线程下执行情况的MyThread类放入到wen.design.singleton.s06包下运行，执行结果如下：\n\n```\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n```\n从运行结果来看，静态内部类实现的单例在多线程并发下单个实例得到了保证。\n\n## 5、序列化与反序列化的单例模式实现\n静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。\n代码实现如下：\n\n```\npackage wen.design.singleton.s07;\n\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    //内部类\n    private static class MySingletonHandler{\n        private static MySingleton instance = new MySingleton();\n    }\n\n    private MySingleton(){}\n    public static MySingleton getInstance() {\n        return MySingletonHandler.instance;\n    }\n    //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉\n    protected Object readResolve() throws ObjectStreamException {\n        System.out.println(\"调用了readResolve方法！\");\n        return MySingletonHandler.instance;\n    }\n}\n\n```\n序列化与反序列化测试代码：\n```\npackage wen.design.singleton.s07;\n\nimport java.io.*;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class SaveAndReadForSingleton {\n    public static void main(String[] args) {\n        MySingleton singleton = MySingleton.getInstance();\n\n        File file = new File(\"MySingleton.txt\");\n\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(singleton);\n            fos.close();\n            oos.close();\n            System.out.println(singleton.hashCode());\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            MySingleton rSingleton = (MySingleton) ois.readObject();\n            fis.close();\n            ois.close();\n            System.out.println(rSingleton.hashCode());\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n运行上面的测试代码，得到的结果如下：\n```\n19235919\n调用了readResolve方法！\n19235919\n\n```\n从运行结果可知，添加readResolve方法后反序列化后得到的实例和序列化前的是同一个实例，单个实例得到了保证\n\n\n## 6、使用static代码块实现单例\n静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。\n```\npackage wen.design.singleton.s08;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton{\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    static{\n        instance = new MySingleton();\n    }\n\n    public static MySingleton getInstance() {\n        return instance;\n    }\n}\n```\n\n测试代码如下：\n```\npackage wen.design.singleton.s08;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(MySingleton.getInstance().hashCode());\n        }\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[3];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n\n运行结果：\n```\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n```\n\n## 7、使用枚举数据类型实现单例模式\n\n枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：\n```\npackage wen.design.singleton.s09;\n\n/**\n * Created by dell on 2017/2/22.\n */\n\npublic enum EnumFactory{\n\n    singletonFactory;\n\n    private MySingleton instance;\n\n    private EnumFactory(){//枚举类的构造方法在类加载是被实例化\n        instance = new MySingleton();\n    }\n\n    public MySingleton getInstance(){\n        return instance;\n    }\n\n}\n\nclass MySingleton{//需要获实现单例的类，比如数据库连接Connection\n    public MySingleton(){}\n}\n\n```\n\n测试代码\n```\npackage wen.design.singleton.s09;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(EnumFactory.singletonFactory.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n\n运行结果：\n```\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n```\n运行结果表明单例得到了保证，但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。\n## 8、完善使用enum枚举实现单例模式\n不暴露枚举类实现细节的封装代码如下：\n```\npackage wen.design.singleton.s10;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class ClassFactory{\n\n    private enum MyEnumSingleton{\n        singletonFactory;\n\n        private MySingleton instance;\n\n        private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化\n            instance = new MySingleton();\n        }\n\n        public MySingleton getInstance(){\n            return instance;\n        }\n    }\n\n    public static MySingleton getInstance(){\n        return MyEnumSingleton.singletonFactory.getInstance();\n    }\n}\n\nclass MySingleton{//需要获实现单例的类，比如数据库连接Connection\n    public MySingleton(){}\n}\n```\n测试代码\n```\npackage wen.design.singleton.s10;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(ClassFactory.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n运行结果\n```\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n```\n验证结果表明，完善后的单例实现更为合理。\n以上就是本文要介绍的所有单例模式的实现，相信认真阅读的读者都已经明白文章开头所引入的那几个问题了，祝大家读得开心:-D！\n\n","source":"_posts/Singleton.md","raw":"title: java 单例模式\ntags:\n  - java\n  - 单例模式\n  - 设计模式\n  - 线程\ncategories:\n  - java\n  - 设计模式\nauthor: wen\ndate: 2017-02-20 10:01:00\n---\n<Excerpt in index | 首页摘要>\n在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后任然是单例的呢？这些问题在看了本文之后都会一一的告诉你答案，赶快来阅读吧<!-- more -->\n<The rest of contents | 余下全文>\n# 什么是单例模式\n在文章开始之前我们还是有必要介绍一下什么是单例模式。单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。\n从概念中体现出了单例的一些特点：\n\n> （1）、在任何情况下，单例类永远只有一个实例存在\n> （2）、单例需要有能力为整个系统提供这一唯一实例  \n\n为了便于读者更好的理解这些概念，下面给出这么一段内容叙述：\n在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。\n\n正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。\n\n## 1、饿汉式单例\n饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：\n```\npackage wen.design.singleton.s01;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = new MySingleton();\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        return instance;\n    }\n}\n```\n以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：\n```\npackage wen.design.singleton.s01;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(MySingleton.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n以上代码运行结果：\n```\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n15779934\n```\n从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了\n\n## 2、懒汉式单例\n懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：\n```\npackage org.mlinge.s02;  \n  \npublic class MySingleton {  \n      \n    private static MySingleton instance = null;  \n      \n    private MySingleton(){}  \n      \n    public static MySingleton getInstance() {  \n        try {   \n            if(instance != null){//懒汉式   \n                  \n            }else{  \n                //创建实例之前可能会有一些准备性的耗时工作   \n                Thread.sleep(300);  \n                instance = new MySingleton();  \n            }  \n        } catch (InterruptedException e) {   \n            e.printStackTrace();  \n        }  \n        return instance;  \n    }  \n}  \n```\n这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用\n```\npackage wen.design.singleton.s02;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(MySingleton.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n执行结果如下：\n```\n30863650\n7408068\n20469344\n28235257\n23191477\n10884088\n23667197\n20358204\n5807702\n213274\n```\n## 3、线程安全的懒汉式单例\n要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。\n* （1）方法中声明synchronized关键字\n出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：\n\n\n```\npackage wen.design.singleton.s03;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public synchronized static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                instance = new MySingleton();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n\n此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singletonge.s03包下运行，执行结果如下：\n\n```\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n```\n\n从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：\n\n* （2）、 同步代码块实现\n\n\n```\npackage wen.design.singleton.s03;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    //public synchronized static MySingleton getInstance() {\n    public static MySingleton getInstance() {\n        try {\n            synchronized (MySingleton.class) {\n                if(instance != null){//懒汉式\n\n                }else{\n                    //创建实例之前可能会有一些准备性的耗时工作\n                    Thread.sleep(300);\n                    instance = new MySingleton();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。\n* （3）、 针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：\n\n```\npackage wen.design.singleton.s04;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                synchronized (MySingleton.class) {\n                    instance = new MySingleton();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n```\n\n此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s04包下运行，执行结果如下：\n```\n30863650\n7408068\n20469344\n28235257\n23191477\n10884088\n23667197\n20358204\n20358204\n5807702\n```\n\n从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。\n\n* （4）、 Double Check Locking 双检查锁机制（推荐）\n为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：\n\n```\npackage wen.design.singleton.s05;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    //使用volatile关键字保其可见性\n    volatile private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        try {\n            if(instance != null){//懒汉式\n\n            }else{\n                //创建实例之前可能会有一些准备性的耗时工作\n                Thread.sleep(300);\n                synchronized (MySingleton.class) {\n                    if(instance == null){//二次检查\n                        instance = new MySingleton();\n                    }\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n}\n\n```\n\n此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s05包下运行，执行结果如下\n```\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n30863650\n```\n从运行结果来看，该中方法保证了多线程并发下的线程安全性。\n这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。\n\n## 4、使用静态内置类实现单例模式\nDCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：\n\n```\npackage wen.design.singleton.s06;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton {\n\n    //内部类\n    private static class MySingletonHandler{\n        private static MySingleton instance = new MySingleton();\n    }\n\n    private MySingleton(){}\n\n    public static MySingleton getInstance() {\n        return MySingletonHandler.instance;\n    }\n}\n\n```\n\n以上代码就是使用静态内置类实现了单例模式，这里将前面验证多线程下执行情况的MyThread类放入到wen.design.singleton.s06包下运行，执行结果如下：\n\n```\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n1696092\n```\n从运行结果来看，静态内部类实现的单例在多线程并发下单个实例得到了保证。\n\n## 5、序列化与反序列化的单例模式实现\n静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。\n代码实现如下：\n\n```\npackage wen.design.singleton.s07;\n\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    //内部类\n    private static class MySingletonHandler{\n        private static MySingleton instance = new MySingleton();\n    }\n\n    private MySingleton(){}\n    public static MySingleton getInstance() {\n        return MySingletonHandler.instance;\n    }\n    //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉\n    protected Object readResolve() throws ObjectStreamException {\n        System.out.println(\"调用了readResolve方法！\");\n        return MySingletonHandler.instance;\n    }\n}\n\n```\n序列化与反序列化测试代码：\n```\npackage wen.design.singleton.s07;\n\nimport java.io.*;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class SaveAndReadForSingleton {\n    public static void main(String[] args) {\n        MySingleton singleton = MySingleton.getInstance();\n\n        File file = new File(\"MySingleton.txt\");\n\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(singleton);\n            fos.close();\n            oos.close();\n            System.out.println(singleton.hashCode());\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            MySingleton rSingleton = (MySingleton) ois.readObject();\n            fis.close();\n            ois.close();\n            System.out.println(rSingleton.hashCode());\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n运行上面的测试代码，得到的结果如下：\n```\n19235919\n调用了readResolve方法！\n19235919\n\n```\n从运行结果可知，添加readResolve方法后反序列化后得到的实例和序列化前的是同一个实例，单个实例得到了保证\n\n\n## 6、使用static代码块实现单例\n静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。\n```\npackage wen.design.singleton.s08;\n\n/**\n * Created by dell on 2017/2/22.\n */\npublic class MySingleton{\n\n    private static MySingleton instance = null;\n\n    private MySingleton(){}\n\n    static{\n        instance = new MySingleton();\n    }\n\n    public static MySingleton getInstance() {\n        return instance;\n    }\n}\n```\n\n测试代码如下：\n```\npackage wen.design.singleton.s08;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(MySingleton.getInstance().hashCode());\n        }\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[3];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n\n运行结果：\n```\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n27979955\n```\n\n## 7、使用枚举数据类型实现单例模式\n\n枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：\n```\npackage wen.design.singleton.s09;\n\n/**\n * Created by dell on 2017/2/22.\n */\n\npublic enum EnumFactory{\n\n    singletonFactory;\n\n    private MySingleton instance;\n\n    private EnumFactory(){//枚举类的构造方法在类加载是被实例化\n        instance = new MySingleton();\n    }\n\n    public MySingleton getInstance(){\n        return instance;\n    }\n\n}\n\nclass MySingleton{//需要获实现单例的类，比如数据库连接Connection\n    public MySingleton(){}\n}\n\n```\n\n测试代码\n```\npackage wen.design.singleton.s09;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(EnumFactory.singletonFactory.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n\n运行结果：\n```\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n15055830\n```\n运行结果表明单例得到了保证，但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。\n## 8、完善使用enum枚举实现单例模式\n不暴露枚举类实现细节的封装代码如下：\n```\npackage wen.design.singleton.s10;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class ClassFactory{\n\n    private enum MyEnumSingleton{\n        singletonFactory;\n\n        private MySingleton instance;\n\n        private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化\n            instance = new MySingleton();\n        }\n\n        public MySingleton getInstance(){\n            return instance;\n        }\n    }\n\n    public static MySingleton getInstance(){\n        return MyEnumSingleton.singletonFactory.getInstance();\n    }\n}\n\nclass MySingleton{//需要获实现单例的类，比如数据库连接Connection\n    public MySingleton(){}\n}\n```\n测试代码\n```\npackage wen.design.singleton.s10;\n\n/**\n * Created by dell on 2017/2/23.\n */\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(ClassFactory.getInstance().hashCode());\n    }\n\n    public static void main(String[] args) {\n\n        MyThread[] mts = new MyThread[10];\n        for(int i = 0 ; i < mts.length ; i++){\n            mts[i] = new MyThread();\n        }\n\n        for (int j = 0; j < mts.length; j++) {\n            mts[j].start();\n        }\n    }\n}\n```\n运行结果\n```\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n25039388\n```\n验证结果表明，完善后的单例实现更为合理。\n以上就是本文要介绍的所有单例模式的实现，相信认真阅读的读者都已经明白文章开头所引入的那几个问题了，祝大家读得开心:-D！\n\n","slug":"Singleton","published":1,"updated":"2019-04-30T02:20:37.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce3710009n6zq6foszl52","content":"<p><excerpt in index | 首页摘要><br>在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后任然是单例的呢？这些问题在看了本文之后都会一一的告诉你答案，赶快来阅读吧<a id=\"more\"></a></excerpt></p>\n<p><the rest of contents | 余下全文></the></p>\n<h1 id=\"什么是单例模式\"><a href=\"#什么是单例模式\" class=\"headerlink\" title=\"什么是单例模式\"></a>什么是单例模式</h1><p>在文章开始之前我们还是有必要介绍一下什么是单例模式。单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。<br>从概念中体现出了单例的一些特点：</p>\n<blockquote>\n<p>（1）、在任何情况下，单例类永远只有一个实例存在<br>（2）、单例需要有能力为整个系统提供这一唯一实例  </p>\n</blockquote>\n<p>为了便于读者更好的理解这些概念，下面给出这么一段内容叙述：<br>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>\n<p>正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。</p>\n<h2 id=\"1、饿汉式单例\"><a href=\"#1、饿汉式单例\" class=\"headerlink\" title=\"1、饿汉式单例\"></a>1、饿汉式单例</h2><p>饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s01;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = new MySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s01;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了</p>\n<h2 id=\"2、懒汉式单例\"><a href=\"#2、懒汉式单例\" class=\"headerlink\" title=\"2、懒汉式单例\"></a>2、懒汉式单例</h2><p>懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.mlinge.s02;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class MySingleton &#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    private static MySingleton instance = null;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    private MySingleton()&#123;&#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public static MySingleton getInstance() &#123;  </span><br><span class=\"line\">        try &#123;   </span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式   </span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125;else&#123;  </span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作   </span><br><span class=\"line\">                Thread.sleep(300);  </span><br><span class=\"line\">                instance = new MySingleton();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;   </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s02;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">7408068</span><br><span class=\"line\">20469344</span><br><span class=\"line\">28235257</span><br><span class=\"line\">23191477</span><br><span class=\"line\">10884088</span><br><span class=\"line\">23667197</span><br><span class=\"line\">20358204</span><br><span class=\"line\">5807702</span><br><span class=\"line\">213274</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3、线程安全的懒汉式单例\"><a href=\"#3、线程安全的懒汉式单例\" class=\"headerlink\" title=\"3、线程安全的懒汉式单例\"></a>3、线程安全的懒汉式单例</h2><p>要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。</p>\n<ul>\n<li>（1）方法中声明synchronized关键字<br>出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s03;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                instance = new MySingleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singletonge.s03包下运行，执行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br></pre></td></tr></table></figure>\n<p>从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：</p>\n<ul>\n<li>（2）、 同步代码块实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s03;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //public synchronized static MySingleton getInstance() &#123;</span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                    Thread.sleep(300);</span><br><span class=\"line\">                    instance = new MySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。</p>\n<ul>\n<li>（3）、 针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s04;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                    instance = new MySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s04包下运行，执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">7408068</span><br><span class=\"line\">20469344</span><br><span class=\"line\">28235257</span><br><span class=\"line\">23191477</span><br><span class=\"line\">10884088</span><br><span class=\"line\">23667197</span><br><span class=\"line\">20358204</span><br><span class=\"line\">20358204</span><br><span class=\"line\">5807702</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。</p>\n<ul>\n<li>（4）、 Double Check Locking 双检查锁机制（推荐）<br>为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s05;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用volatile关键字保其可见性</span><br><span class=\"line\">    volatile private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                    if(instance == null)&#123;//二次检查</span><br><span class=\"line\">                        instance = new MySingleton();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s05包下运行，执行结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果来看，该中方法保证了多线程并发下的线程安全性。<br>这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p>\n<h2 id=\"4、使用静态内置类实现单例模式\"><a href=\"#4、使用静态内置类实现单例模式\" class=\"headerlink\" title=\"4、使用静态内置类实现单例模式\"></a>4、使用静态内置类实现单例模式</h2><p>DCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s06;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //内部类</span><br><span class=\"line\">    private static class MySingletonHandler&#123;</span><br><span class=\"line\">        private static MySingleton instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是使用静态内置类实现了单例模式，这里将前面验证多线程下执行情况的MyThread类放入到wen.design.singleton.s06包下运行，执行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br></pre></td></tr></table></figure>\n<p>从运行结果来看，静态内部类实现的单例在多线程并发下单个实例得到了保证。</p>\n<h2 id=\"5、序列化与反序列化的单例模式实现\"><a href=\"#5、序列化与反序列化的单例模式实现\" class=\"headerlink\" title=\"5、序列化与反序列化的单例模式实现\"></a>5、序列化与反序列化的单例模式实现</h2><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。<br>代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s07;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.ObjectStreamException;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //内部类</span><br><span class=\"line\">    private static class MySingletonHandler&#123;</span><br><span class=\"line\">        private static MySingleton instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉</span><br><span class=\"line\">    protected Object readResolve() throws ObjectStreamException &#123;</span><br><span class=\"line\">        System.out.println(&quot;调用了readResolve方法！&quot;);</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>序列化与反序列化测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s07;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SaveAndReadForSingleton &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        MySingleton singleton = MySingleton.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(&quot;MySingleton.txt&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            FileOutputStream fos = new FileOutputStream(file);</span><br><span class=\"line\">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class=\"line\">            oos.writeObject(singleton);</span><br><span class=\"line\">            fos.close();</span><br><span class=\"line\">            oos.close();</span><br><span class=\"line\">            System.out.println(singleton.hashCode());</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            FileInputStream fis = new FileInputStream(file);</span><br><span class=\"line\">            ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class=\"line\">            MySingleton rSingleton = (MySingleton) ois.readObject();</span><br><span class=\"line\">            fis.close();</span><br><span class=\"line\">            ois.close();</span><br><span class=\"line\">            System.out.println(rSingleton.hashCode());</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行上面的测试代码，得到的结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19235919</span><br><span class=\"line\">调用了readResolve方法！</span><br><span class=\"line\">19235919</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果可知，添加readResolve方法后反序列化后得到的实例和序列化前的是同一个实例，单个实例得到了保证</p>\n<h2 id=\"6、使用static代码块实现单例\"><a href=\"#6、使用static代码块实现单例\" class=\"headerlink\" title=\"6、使用static代码块实现单例\"></a>6、使用static代码块实现单例</h2><p>静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s08;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static&#123;</span><br><span class=\"line\">        instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s08;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[3];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7、使用枚举数据类型实现单例模式\"><a href=\"#7、使用枚举数据类型实现单例模式\" class=\"headerlink\" title=\"7、使用枚举数据类型实现单例模式\"></a>7、使用枚举数据类型实现单例模式</h2><p>枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s09;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public enum EnumFactory&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    singletonFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private EnumFactory()&#123;//枚举类的构造方法在类加载是被实例化</span><br><span class=\"line\">        instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MySingleton getInstance()&#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection</span><br><span class=\"line\">    public MySingleton()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s09;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(EnumFactory.singletonFactory.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br></pre></td></tr></table></figure></p>\n<p>运行结果表明单例得到了保证，但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。</p>\n<h2 id=\"8、完善使用enum枚举实现单例模式\"><a href=\"#8、完善使用enum枚举实现单例模式\" class=\"headerlink\" title=\"8、完善使用enum枚举实现单例模式\"></a>8、完善使用enum枚举实现单例模式</h2><p>不暴露枚举类实现细节的封装代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s10;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ClassFactory&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private enum MyEnumSingleton&#123;</span><br><span class=\"line\">        singletonFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">        private MySingleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">        private MyEnumSingleton()&#123;//枚举类的构造方法在类加载是被实例化</span><br><span class=\"line\">            instance = new MySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public MySingleton getInstance()&#123;</span><br><span class=\"line\">            return instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance()&#123;</span><br><span class=\"line\">        return MyEnumSingleton.singletonFactory.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection</span><br><span class=\"line\">    public MySingleton()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s10;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(ClassFactory.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br></pre></td></tr></table></figure></p>\n<p>验证结果表明，完善后的单例实现更为合理。<br>以上就是本文要介绍的所有单例模式的实现，相信认真阅读的读者都已经明白文章开头所引入的那几个问题了，祝大家读得开心:-D！</p>\n","site":{"data":{}},"excerpt":"<p><excerpt in index | 首页摘要><br>在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后任然是单例的呢？这些问题在看了本文之后都会一一的告诉你答案，赶快来阅读吧</excerpt></p>","more":"<p></p>\n<p><the rest of contents | 余下全文></the></p>\n<h1 id=\"什么是单例模式\"><a href=\"#什么是单例模式\" class=\"headerlink\" title=\"什么是单例模式\"></a>什么是单例模式</h1><p>在文章开始之前我们还是有必要介绍一下什么是单例模式。单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。<br>从概念中体现出了单例的一些特点：</p>\n<blockquote>\n<p>（1）、在任何情况下，单例类永远只有一个实例存在<br>（2）、单例需要有能力为整个系统提供这一唯一实例  </p>\n</blockquote>\n<p>为了便于读者更好的理解这些概念，下面给出这么一段内容叙述：<br>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>\n<p>正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。</p>\n<h2 id=\"1、饿汉式单例\"><a href=\"#1、饿汉式单例\" class=\"headerlink\" title=\"1、饿汉式单例\"></a>1、饿汉式单例</h2><p>饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s01;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = new MySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s01;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br><span class=\"line\">15779934</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了</p>\n<h2 id=\"2、懒汉式单例\"><a href=\"#2、懒汉式单例\" class=\"headerlink\" title=\"2、懒汉式单例\"></a>2、懒汉式单例</h2><p>懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.mlinge.s02;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class MySingleton &#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    private static MySingleton instance = null;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    private MySingleton()&#123;&#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    public static MySingleton getInstance() &#123;  </span><br><span class=\"line\">        try &#123;   </span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式   </span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125;else&#123;  </span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作   </span><br><span class=\"line\">                Thread.sleep(300);  </span><br><span class=\"line\">                instance = new MySingleton();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;   </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s02;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">7408068</span><br><span class=\"line\">20469344</span><br><span class=\"line\">28235257</span><br><span class=\"line\">23191477</span><br><span class=\"line\">10884088</span><br><span class=\"line\">23667197</span><br><span class=\"line\">20358204</span><br><span class=\"line\">5807702</span><br><span class=\"line\">213274</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3、线程安全的懒汉式单例\"><a href=\"#3、线程安全的懒汉式单例\" class=\"headerlink\" title=\"3、线程安全的懒汉式单例\"></a>3、线程安全的懒汉式单例</h2><p>要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。</p>\n<ul>\n<li>（1）方法中声明synchronized关键字<br>出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s03;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                instance = new MySingleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singletonge.s03包下运行，执行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br></pre></td></tr></table></figure>\n<p>从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：</p>\n<ul>\n<li>（2）、 同步代码块实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s03;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //public synchronized static MySingleton getInstance() &#123;</span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                    Thread.sleep(300);</span><br><span class=\"line\">                    instance = new MySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。</p>\n<ul>\n<li>（3）、 针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s04;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                    instance = new MySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s04包下运行，执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">7408068</span><br><span class=\"line\">20469344</span><br><span class=\"line\">28235257</span><br><span class=\"line\">23191477</span><br><span class=\"line\">10884088</span><br><span class=\"line\">23667197</span><br><span class=\"line\">20358204</span><br><span class=\"line\">20358204</span><br><span class=\"line\">5807702</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。</p>\n<ul>\n<li>（4）、 Double Check Locking 双检查锁机制（推荐）<br>为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s05;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用volatile关键字保其可见性</span><br><span class=\"line\">    volatile private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(instance != null)&#123;//懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                //创建实例之前可能会有一些准备性的耗时工作</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                synchronized (MySingleton.class) &#123;</span><br><span class=\"line\">                    if(instance == null)&#123;//二次检查</span><br><span class=\"line\">                        instance = new MySingleton();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入wen.design.singleton.s05包下运行，执行结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br><span class=\"line\">30863650</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果来看，该中方法保证了多线程并发下的线程安全性。<br>这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p>\n<h2 id=\"4、使用静态内置类实现单例模式\"><a href=\"#4、使用静态内置类实现单例模式\" class=\"headerlink\" title=\"4、使用静态内置类实现单例模式\"></a>4、使用静态内置类实现单例模式</h2><p>DCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s06;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //内部类</span><br><span class=\"line\">    private static class MySingletonHandler&#123;</span><br><span class=\"line\">        private static MySingleton instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是使用静态内置类实现了单例模式，这里将前面验证多线程下执行情况的MyThread类放入到wen.design.singleton.s06包下运行，执行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br><span class=\"line\">1696092</span><br></pre></td></tr></table></figure>\n<p>从运行结果来看，静态内部类实现的单例在多线程并发下单个实例得到了保证。</p>\n<h2 id=\"5、序列化与反序列化的单例模式实现\"><a href=\"#5、序列化与反序列化的单例模式实现\" class=\"headerlink\" title=\"5、序列化与反序列化的单例模式实现\"></a>5、序列化与反序列化的单例模式实现</h2><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。<br>代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s07;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.ObjectStreamException;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //内部类</span><br><span class=\"line\">    private static class MySingletonHandler&#123;</span><br><span class=\"line\">        private static MySingleton instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉</span><br><span class=\"line\">    protected Object readResolve() throws ObjectStreamException &#123;</span><br><span class=\"line\">        System.out.println(&quot;调用了readResolve方法！&quot;);</span><br><span class=\"line\">        return MySingletonHandler.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>序列化与反序列化测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s07;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SaveAndReadForSingleton &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        MySingleton singleton = MySingleton.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(&quot;MySingleton.txt&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            FileOutputStream fos = new FileOutputStream(file);</span><br><span class=\"line\">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class=\"line\">            oos.writeObject(singleton);</span><br><span class=\"line\">            fos.close();</span><br><span class=\"line\">            oos.close();</span><br><span class=\"line\">            System.out.println(singleton.hashCode());</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            FileInputStream fis = new FileInputStream(file);</span><br><span class=\"line\">            ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class=\"line\">            MySingleton rSingleton = (MySingleton) ois.readObject();</span><br><span class=\"line\">            fis.close();</span><br><span class=\"line\">            ois.close();</span><br><span class=\"line\">            System.out.println(rSingleton.hashCode());</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行上面的测试代码，得到的结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19235919</span><br><span class=\"line\">调用了readResolve方法！</span><br><span class=\"line\">19235919</span><br></pre></td></tr></table></figure></p>\n<p>从运行结果可知，添加readResolve方法后反序列化后得到的实例和序列化前的是同一个实例，单个实例得到了保证</p>\n<h2 id=\"6、使用static代码块实现单例\"><a href=\"#6、使用static代码块实现单例\" class=\"headerlink\" title=\"6、使用static代码块实现单例\"></a>6、使用static代码块实现单例</h2><p>静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s08;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MySingleton&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static MySingleton instance = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static&#123;</span><br><span class=\"line\">        instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s08;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            System.out.println(MySingleton.getInstance().hashCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[3];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br><span class=\"line\">27979955</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7、使用枚举数据类型实现单例模式\"><a href=\"#7、使用枚举数据类型实现单例模式\" class=\"headerlink\" title=\"7、使用枚举数据类型实现单例模式\"></a>7、使用枚举数据类型实现单例模式</h2><p>枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s09;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/22.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public enum EnumFactory&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    singletonFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MySingleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private EnumFactory()&#123;//枚举类的构造方法在类加载是被实例化</span><br><span class=\"line\">        instance = new MySingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MySingleton getInstance()&#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection</span><br><span class=\"line\">    public MySingleton()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s09;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(EnumFactory.singletonFactory.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br><span class=\"line\">15055830</span><br></pre></td></tr></table></figure></p>\n<p>运行结果表明单例得到了保证，但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。</p>\n<h2 id=\"8、完善使用enum枚举实现单例模式\"><a href=\"#8、完善使用enum枚举实现单例模式\" class=\"headerlink\" title=\"8、完善使用enum枚举实现单例模式\"></a>8、完善使用enum枚举实现单例模式</h2><p>不暴露枚举类实现细节的封装代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s10;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ClassFactory&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private enum MyEnumSingleton&#123;</span><br><span class=\"line\">        singletonFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">        private MySingleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">        private MyEnumSingleton()&#123;//枚举类的构造方法在类加载是被实例化</span><br><span class=\"line\">            instance = new MySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public MySingleton getInstance()&#123;</span><br><span class=\"line\">            return instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static MySingleton getInstance()&#123;</span><br><span class=\"line\">        return MyEnumSingleton.singletonFactory.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection</span><br><span class=\"line\">    public MySingleton()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package wen.design.singleton.s10;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Created by dell on 2017/2/23.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyThread extends Thread&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(ClassFactory.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread[] mts = new MyThread[10];</span><br><span class=\"line\">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;</span><br><span class=\"line\">            mts[i] = new MyThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int j = 0; j &lt; mts.length; j++) &#123;</span><br><span class=\"line\">            mts[j].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br><span class=\"line\">25039388</span><br></pre></td></tr></table></figure></p>\n<p>验证结果表明，完善后的单例实现更为合理。<br>以上就是本文要介绍的所有单例模式的实现，相信认真阅读的读者都已经明白文章开头所引入的那几个问题了，祝大家读得开心:-D！</p>"},{"title":"Spring Bean 生命周期","author":"wen","date":"2020-08-09T12:38:00.000Z","_content":"# 问题\n* spring 如何产生Bean\n* @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？\n* Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？\n* Spring什么时候解析了@Import注解，如何解析的？\n* Spring什么时候解析了@Bean注解？\n\n# 如何产生bean\n\n```\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n```\n[如何在spring源码中新建model及创建上面的代码](/2020/08/07/spring源码编译/#新建Model)\n[关于ApplicationContext](/2020/08/08/spring源码（一）/#ApplicationContext)\n[spring实例化过程.png](https://www.processon.com/view/link/5f3bce04f346fb06decb7923)\n以上代码：\n* 从一个Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。\n* 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。\n* 对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。\n\n# 启动过程分析\n记住，一定要在电脑中打开源码，不然纯看是很累的。\n[spring源码注释](https://github.com/smallwenzi/springframeworkcode)\n分支是springcode\n\nSpring bean 默认是单例\n为了弄清楚Bean是怎么来的，花费了大把功夫，现在要把Bean Definition的加载、解析、处理、注册到bean工厂的过程记下来\n * \tAnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n [实例化AnnotationConfigApplicationContext(Class<?>... componentClasses](#AnnotationConfigApplicationContext构造方法)\n \t* this()\n    \t* [调用父类GenericApplicationContext的构造函数](#GenericApplicationContext-构造方法)\n        \t* this.beanFactory = new DefaultListableBeanFactory();\n            [实例化DefaultListableBeanFactory](#DefaultListableBeanFactory-构造方法)\n    \t* \tthis.reader = new AnnotatedBeanDefinitionReader(this);\n        [实例化AnnotatedBeanDefinitionReader](#初始化一个Bean读取器AnnotatedBeanDefinitionReader)\n        \t* [registerAnnotationConfigProcessors方法负责向容器里面注册相关的类](#AnnotationConfigUtils-registerAnnotationConfigProcessors)\n        * \tthis.scanner = new ClassPathBeanDefinitionScanner(this);\n            初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的\n    *  [register(componentClasses);](#register-componentClasses)\n    \t* [AnnotatedBeanDefinitionReader 类register 方法](#AnnotatedBeanDefinitionReader-类register-方法)\n        \t* [AnnotatedBeanDefinitionReader的方法doRegisterBean](#AnnotatedBeanDefinitionReader的方法doRegisterBean) 把appconfig注册至bean容器中但是未实例化\n    *  [refresh();](#refresh)\n    \t*  prepareRefresh();\n         刷新前的预处理;\n        * \tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的\n        * prepareBeanFactory(beanFactory);\n         BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器，BeanPostProcessor和XXXAware自动装配等）\n        * postProcessBeanFactory(beanFactory);\n          BeanFactory准备工作完成后进行的后置处理工作\n        * invokeBeanFactoryPostProcessors(beanFactory);\n        执行BeanFactoryPostProcessor的方法；\n        * registerBeanPostProcessors(beanFactory);\n         注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行\n        * initMessageSource();\n        初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；\n        * initApplicationEventMulticaster();\n        初始化事件派发器\n        * \tonRefresh();\n        子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器\n        * registerListeners();\n        注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的\n        * finishBeanFactoryInitialization(beanFactory);\n         初始化所有剩下的非懒加载的单例bean\n        * \tfinishRefresh();\n        完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）\n   \n## AnnotationConfigApplicationContext构造方法\n```\npublic class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {\n\n\tprivate final AnnotatedBeanDefinitionReader reader;\n\n\tprivate final ClassPathBeanDefinitionScanner scanner;\n    \n    /**\n     AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n    这句代码调用以下方法\n   根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少\n  */\n\tpublic AnnotationConfigApplicationContext(Class<?>... componentClasses) {\n     //详细看AnnotationConfigApplicationContext 无参构造\n\t\tthis();\n\t\tregister(componentClasses);\n\t\trefresh();\n\t}\n    \n   public AnnotationConfigApplicationContext() {\n    ////调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()\n     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader\n\t\tthis.reader = new AnnotatedBeanDefinitionReader(this);\n        //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器\n\t\tthis.scanner = new ClassPathBeanDefinitionScanner(this);\n\t}\n    \n}\n```\n* 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数\n\t* 父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory\n   * 本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner\n\t* scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的\n* \n* \n\n### GenericApplicationContext 构造方法\n```\npublic class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {\n \tprivate final DefaultListableBeanFactory beanFactory;\n    public GenericApplicationContext() {\n    //初始化一个BeanFactory\n\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t}\n\n}\n```\n#### DefaultListableBeanFactory 构造方法\n\n默认实现了ListableBeanFactory和BeanDefinitionRegistry接口，基于bean definition对象，是一个成熟的bean factroy。\n\n最典型的应用是：在访问bean前，先注册所有的definition（可能从bean definition配置文件中）。使用预先建立的bean定义元数据对象，从本地的bean definition表中查询bean definition因而将不会花费太多成本。\n\nDefaultListableBeanFactory既可以作为一个单独的beanFactory，也可以作为自定义beanFactory的父类。\n![DefaultListableBeanFactory类图](Spring-Bean-生命周期/DefaultListableBeanFactory.png)\n\n```\npublic class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n        //存储BeanDefinition对象\n\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\n    \n   \t/** 存储 spring bean 单例对象  */\n\tprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\t/**\n\t * Create a new DefaultListableBeanFactory.\n\t */\n\tpublic DefaultListableBeanFactory() {\n\t\tsuper();\n\t}\n }\n```\n##### AbstractAutowireCapableBeanFactory构造方法\n```\n\tpublic AbstractAutowireCapableBeanFactory() {\n\n\tsuper();\n    //自动装配时忽略指定接口或类的依赖注入\n\t\tignoreDependencyInterface(BeanNameAware.class);\n\t\tignoreDependencyInterface(BeanFactoryAware.class);\n\t\tignoreDependencyInterface(BeanClassLoaderAware.class);\n        }\n```\n###### \tAbstractBeanFactory\n```\n/**\n\t * Create a new AbstractBeanFactory.\n\t */\n\tpublic AbstractBeanFactory() {\n\t}\n ```\n### //初始化一个Bean读取器AnnotatedBeanDefinitionReader\n\n```\nthis.reader = new AnnotatedBeanDefinitionReader(this);\n```\n#### AnnotatedBeanDefinitionReader构造方法\n```\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\t//这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了\n\t\tthis(registry, getOrCreateEnvironment(registry));\n\t}\n```\nAnnotatedBeanDefinitionReader 方法\n```\n\tpublic AnnotatedBeanDefinitionReader (BeanDefinitionRegistry registry, Environment environment) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.registry = registry;\n\t\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);\n\t\t//让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：\n this.registry 是    AnnotationConfigApplicationContext的实例了   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t}\n```\n#### AnnotationConfigUtils.registerAnnotationConfigProcessors\n```\n\tpublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n\t\tregisterAnnotationConfigProcessors(registry, null);\n\t}\n```\n在看registerAnnotationConfigProcessors方法\n* 这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。\n\t\t* ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，\n\t\t* BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，\n\t\t* BeanFactoryPostProcessor是Spring的扩展点之一，\n\t\t*  ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。\n\t\t* 除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。\n\t\t* BeanPostProcessor接口也是Spring的扩展点之一。\n\n执行完方法\nbeanDefs 有5个\n * ConfigurationClassPostProcessor\n * AutowiredAnnotationBeanPostProcessor \n * CommonAnnotationBeanPostProcessor\n * EventListenerMethodProcessor\n * DefaultEventListenerFactory\n```\n// this.registry 是    AnnotationConfigApplicationContext的实例了   \nsource=null\n\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n           //这里返回AnnotationConfigApplicationContext对象中DefaultListableBeanFactory类实例\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\nBeanDefinition\t\tif (beanFactory != null) {\n\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\t//用来支持Spring的Ordered类、@Order注解和@Priority注解。\n                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t/**\n\t\t * 注册解析我们配置类的后置处理器ConfigurationClassPostProcessor\n\t\t * org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\t//如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\t\t/**\n\t\t * 注册处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor\n\t\t *\n\t\t org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor\n\t\t * org.springframework.context.annotation.internalCommonAnnotationProcessor\n\t\t */\n\t\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\n\t\t */\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 处理监听方法的注解解析器EventListenerMethodProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\t\t/**\n\t\t * 注册事件监听器工厂\n\t\t */\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n```\n##### ConfigurationClassPostProcessor\n![ConfigurationClassPostProcessor类图](Spring-Bean-生命周期/ConfigurationClassPostProcessor.png)\n\t* ConfigurationClassPostProcessor是一个BeanFactory的后置处理器，因此它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。\n    * ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。\n    * ConfigurationClassPostProcessor这个类是Spring内置的一个BeanFactory后置处理器，是在this()方法中将其添加到BeanDefinitionMap中的\n    * [postProcessBeanDefinitionRegistry](#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法中)调用\n   ```\n   registry是DefaultListableBeanFactory对象\n   public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n\t\tint registryId = System.identityHashCode(registry);\n\t\tif (this.registriesPostProcessed.contains(registryId)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"postProcessBeanDefinitionRegistry already called on this post-processor against \" + registry);\n\t\t}\n\t\tif (this.factoriesPostProcessed.contains(registryId)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"postProcessBeanFactory already called on this post-processor against \" + registry);\n\t\t}\n\t\tthis.registriesPostProcessed.add(registryId);\n\n\t\tprocessConfigBeanDefinitions(registry);\n\t}\n   ```\n  * processConfigBeanDefinitions 方法 \n     * 从Beanfactory找出含有Configuration 或Component或ComponentScan或Import或ImportResource类 目前只有appconfig类符合\n     * ConfigurationClassParser.parse（）\n     解析appconfig（AnnotatedGenericBeanDefinition 定义）\n     \t* 1 处理内部类\n        \n        * 2 处理@PropertySources注解：进行一些配置信息的解析\n        \n        * 3 处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析\n        \n        * 4 处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：\n        \n\t\t\t\t* 遍历这些@Import注解内部的属性类集合\n                \n\t\t\t\t* 如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第7步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理\n                \n\t\t\t\t* 如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中\n                \n\t\t\t\t* 其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类\n                \n    * 5 处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中\n    \n\t* 6 处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中\n    \n\t* 7 处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理\n    \n  ```\n  public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\t/* 获得所有的BeanDefinition的Name，放入candidateNames数组\n\t\t目前6个：\n\t\tConfigurationClassPostProcessor\n\t\tAutowiredAnnotationBeanPostProcessor\n\t\tCommonAnnotationBeanPostProcessor\n\t\tEventListenerMethodProcessor\n\t\tDefaultEventListenerFactory\n\t\tappconfig\n\t\t */\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n         //循环candidateNames数组\n\t\tfor (String beanName : candidateNames) {\n\t\t\t//根据beanName获得BeanDefinition\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\t/*  内部有两个标记位来标记是否已经处理过了\n\t\t\t 这里会引发一连串知识盲点\n\t\t\t当我们注册配置类的时候，可以不加Configuration注解，\n\t\t\t直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类\n\t\t\t如果加了Configuration注解，就称之为Full配置类\n\t\t\t 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类\n\t\t\t如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了\n\t\t\t 写一个A类，其中有一个构造方法，打印出“你好”\n\t\t\t 再写一个配置类，里面有两个bean注解的方法\n\t\t\t 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA\n\t\t\t 第二个方法又调用了getA方法\n\t\t\t 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次\n\t\t\t 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写\n\t\t\t */\n\t\t\tif (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），\n\t\t\t在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记\n\t\t\t满足条件，加入到configCandidates */\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n        // 如果没有配置类，直接返回\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n        //处理排序\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\t// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\t//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(\n\t\t\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\t//解析配置类（传统意义上的配置类或者是普通bean，核心来了） candidates 仅appConfig类\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\t//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\t//把configClasses加入到alreadyParsed，代表\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\t//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较\n\t\t\t//如果大于的话，说明有新的BeanDefinition注册进来了\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\t//循环alreadyParsed。把类名加入到alreadyParsedClasses\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n  \n  ```\n  \t* ConfigurationClassParser.parse方法\n    ```\n    public void parse(Set<BeanDefinitionHolder> configCandidates) {\n\t\t//循环传进来的配置类\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd = holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\t//如果获得BeanDefinition是AnnotatedBeanDefinition的实例\n\t\t\t\tif (bd instanceof AnnotatedBeanDefinition) {\n\t\t\t\t\tparse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Failed to parse configuration class [\" + bd.getBeanClassName() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\t//执行DeferredImportSelector\n\t\tthis.deferredImportSelectorHandler.process();\n\t}\n    \tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}\n    \n    \n    protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {\n\t\t//判断是否需要跳过\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = asSourceClass(configClass, filter);\n\t\tdo {\n\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n\t\t}\n\t\twhile (sourceClass != null);\n\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}\n\n\n\n\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */\n\t@Nullable\n\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\t//递归处理内部类，一般不会写内部类\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\t//处理@PropertySource注解，@PropertySource注解用来加载properties文件\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\t//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\t//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\t//循环处理componentScans\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\t//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\t//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//处理@Import注解\n\t\t//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解\n\t\t//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar\n\t\t//getImports(sourceClass)是获得import的内容，返回的是一个set\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\t//处理@ImportResource注解\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n    \n    ```\n##### AutowiredAnnotationBeanPostProcessor\n ![AutowiredAnnotationBeanPostProcessor类图](Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png)\n \t* AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有@Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。  \n    *  关于作用后续内容会说到\n##### CommonAnnotationBeanPostProcessor\n  ![CommonAnnotationBeanPostProcessor图](Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png)\n    * CommonAnnotationBeanPostProcessor类在spring中是一个极其重要的类，它负责解析@Resource、@WebServiceRef、@EJB三个注解。这三个注解都是定义在javax.*包下的注解，属于java中的注解\n    * 关于作用后续内容会说到\n ##### PersistenceAnnotationBeanPostProcessor\n   ![PersistenceAnnotationBeanPostProcessor图](Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png)\n \t* PersistenceAnnotationBeanPostProcessor是Spring提供的用于处理注解@PersistenceUnit和@PersistenceContext的BeanPostProcessor。用于注入相应的JPA资源:EntityManagerFactory和EntityManager (或者它们的子类变量)。\n    * 关于作用后续内容会说到\n##### EventListenerMethodProcessor\n    ![EventListenerMethodProcessor图](Spring-Bean-生命周期/EventListenerMethodProcessor.png)\n \t* EventListenerMethodProcessor 是 Spring 事件机制中非常重要的一个组件。它管理了一组EventListenerFactory组件,用来将应用中每个使用@EventListener注解定义的事件监听方法变成一个ApplicationListener实例注册到容器。换句话讲，框架开发者，或者应用开发者使用注解@EventListener定义的事件处理方法，如果没有EventListenerMethodProcessor的发现和注册，是不会被容器看到和使用的。\n    * 关于作用后续内容会说到\n##### DefaultEventListenerFactory\n    ![DefaultEventListenerFactory图](Spring-Bean-生命周期/DefaultEventListenerFactory.png)\n \t* 监听器工厂\n    * 关于作用后续内容会说到\n\n\n#### registerPostProcessor 方法\nregisterPostProcessor方法内部就是注册Bean，\n```\nprivate static BeanDefinitionHolder registerPostProcessor(\n\t\t\tBeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {\n\t    //为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的\n\t\tdefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t//BeanDefinitionRegistry是接口，实现类：AnnotationConfigApplicationContext 实现方法位于：GenericApplicationContext\n\t\t//方法实现this.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\n\t\tregistry.registerBeanDefinition(beanName, definition);\n\t\treturn new BeanDefinitionHolder(definition, beanName);\n\t}\n```\n* RootBeanDefinition 是BeanDefinition接口子类\n BeanDefinition是什么，顾名思义，它是用来描述Bean的，\n\t *  里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，\n\t *  是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，\n     \n![RootBeanDefinition类图](Spring-Bean-生命周期/RootBeanDefinition.png)\n\n至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。\n### 初始化扫描器\nthis.scanner = new ClassPathBeanDefinitionScanner(this);\n### \tregister(componentClasses);\n* 把传入的类进行注册，这里有两个情况，\n* 传入传统的配置类\n* 传入bean（虽然一般没有人会这么做\n* 看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类\n* 但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean\n\n```\n@Override\n//componentClasses= AppConfig.class\npublic void register(Class<?>...componentClasses) {\n\t\tAssert.notEmpty(componentClasses, \"At least one component class must be specified\");\n       //AnnotatedBeanDefinitionReader 类对象\n\t\tthis.reader.register(componentClasses);\n\t}\n    \n```\n\n#### AnnotatedBeanDefinitionReader 类register 方法\n\n```\n//componentClasses= AppConfig.class\npublic void register (Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}\n```\n\n#### AnnotatedBeanDefinitionReader 类 registerBean方法\n\n\tpublic void registerBean(Class<?> beanClass) {\n\t\tdoRegisterBean(beanClass, null, null, null, null);\n\t}\n\n\n\n#### AnnotatedBeanDefinitionReader的方法doRegisterBean\n\n* 1 通过AnnotatedGenericBeanDefinition的构造方法，\n\t 获得配置类的BeanDefinition，这里是不是似曾相似，\n\t 在注册ConfigurationClassPostProcessor类的时候，\n\t 也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，\n\t 现在是通过AnnotatedGenericBeanDefinition去获得。\n* 2 判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。\n* 3 然后是解析作用域，如果没有设置的话，默认为单例。\n* 4 获得BeanName。\n* 5 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。\n* 6 限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。\n* 7 把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。\n* 8 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：\n\n```\n//beanClass= AppConfig.class\n其它参数都是null\nprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类\n\t\t//转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n\t\t//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析\n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n\t\t//解析bean的作用域，如果没有设置的话，默认为单例\n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n\t\t//获得beanName\n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\t\t//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n\t\t//限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种\n\t\t//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，\n\t\t//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理\n\t\t//但是spring提供了其他方式去注册bean，就可能会传入了\n\t\tif (qualifiers != null) {\n\t\t\t//可以传入qualifier数组，所以需要循环处理\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\n\t\t\t\t//Primary注解优先\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\t//Lazy注解\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse { //其他，AnnotatedGenericBeanDefinition有个Map<String,AutowireCandidateQualifier>属性，直接push进去\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\t\t//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中\n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\t//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，\n\t\t//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap\n\t\t//beanDefinitionNames是一个List<String>,用来保存beanName\n\t\t//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n\n```\n* AnnotatedGenericBeanDefinition\n类注解初始化\n![AnnotatedGenericBeanDefinition类图](AnnotatedGenericBeanDefinition.png)\n\n### refresh\nSpring容器创建之后，会调用它的refresh方法刷新Spring应用的上下文。\n#### prepareRefresh();\n//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等\n```\n\tprotected void prepareRefresh() {\n\t\t// Switch to active.\n\t\tthis.startupDate = System.currentTimeMillis();\n\t\tthis.closed.set(false);\n\t\tthis.active.set(true);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Refreshing \" + this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Refreshing \" + getDisplayName());\n\t\t\t}\n\t\t}\n\n\t\t// 空方法\n\t\tinitPropertySources();\n\n\t\t// 验证环境信息里一些必须存在的属性\n\t\tgetEnvironment().validateRequiredProperties();\n\n\t\t// Store pre-refresh ApplicationListeners...\n\t\tif (this.earlyApplicationListeners == null) {\n\t\t\tthis.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n\t\t}\n\t\telse {\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tthis.applicationListeners.clear();\n\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t}\n\n\t\t// Allow for the collection of early ApplicationEvents,\n\t\t// to be published once the multicaster is available...\n\t\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n\t}\n\n```\n####  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n获取AnnotationConfigApplicationContext 中\nDefaultListableBeanFactory对象，DefaultListableBeanFactory是ConfigurableListableBeanFactory子类\n\n#### prepareBeanFactory(beanFactory);\n配置这个工厂的标准环境，比如context的类加载器和post-processors后处理器。\n```\n/**\n\t * 设置了一个类加载器\n\t * 设置了bean表达式解析器\n\t * 添加了属性编辑器的支持\n\t * 添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口\n\t * 设置了一些忽略自动装配的接口\n\t * 设置了一些允许自动装配的接口，并且进行了赋值操作\n\t * 在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean\n\t */\n\tprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\t// Tell the internal bean factory to use the context's class loader etc.\n\t\t//设置类加载器\n\t\tbeanFactory.setBeanClassLoader(getClassLoader());\n\t\t//设置bean表达式解析器\n\t\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n\t\t//属性编辑器支持\n\t\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n\t\t//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口\n\t\t// Configure the bean factory with context callbacks.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\t\t//以下接口，忽略自动装配\n\t\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n\t\t//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值\n\t\t// BeanFactory interface not registered as resolvable type in a plain factory.\n\t\t// MessageSource registered (and found for autowiring) as a bean.\n\t\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n\t\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n\t\t//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口\n\t\t// Register early post-processor for detecting inner beans as ApplicationListeners.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found.\n\t\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\t// Set a temporary ClassLoader for type matching.\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\n\t\t//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean\n\t\t// 注册环境变量\n\t\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n\t\t}\n\t}\n```\n* ApplicationContextAwareProcessor\nApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor,用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性:\n\n * EnvironmentAware\n * EmbeddedValueResolverAware\n * ResourceLoaderAware\n * ApplicationEventPublisherAware\n * MessageSourceAware\n * ApplicationContextAware\n ApplicationContextAwareProcessor自己会被应用程序上下文自动注册到bean容器,不需要应用开发人员操心\n 后续内容会分析作用\n* ApplicationListenerDetector\n *  1、在Bean初始化完成之后：如果Bean是单例的则并且bean instanceof ApplicationListener。加入到this.applicationListeners中。\n\n * 2、在Bean销毁之前搞事情： 如果Bean是一个ApplicationListener，则会从ApplicationEventMulticaster（事件广播器）中提前删除了\n 后续内容会分析作用\n* LoadTimeWeaverAwareProcessor \n 增加对 AspectJ 的支持\n 后续说到aop会详细说\n#### postProcessBeanFactory(beanFactory);\n 空方法\n#### invokeBeanFactoryPostProcessors(beanFactory);\n在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。\n```\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n\t\t//spring允许我们手动添加BeanFactoryPostProcessor\n\t\t//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);\n\t\t//getBeanFactoryPostProcessors() 在外部可以手动添加一个后置处理器，而不是交给Spring去扫描\n\t\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\t\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\t}\n\n```\n\n##### \tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法\n先介绍两个接口：\n\n* BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理\n* BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理\n\n过程：\n* beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if\n\n\t * 1 定义了一个Set（processedBeans），装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。\n\t * 2 定义了两个List，\n     \t* 一个是regularPostProcessors，用来装载BeanFactoryPostProcessor\n        \n      * 一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。\n      \n\t * 3 循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。\n     \n\t * 4 定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。\n     \n\t * 5 getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。\n     \n\t * 6 循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，\n     \t* 判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了(当然现在还没有处理，但是马上就要处理了)\n\t * 7 进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。\n\t * 8 把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。\n\t * 9 可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。\n\t * 10 清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。\n\t * 11 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。\n\t * 12 处理排序。\n\t * 13 合并Processors，合并的理由和上面是一样的。\n\t * 14 执行我们自定义的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。\n\t * 15 清空临时变量。\n\t * 16 在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。\n\t * 17 regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的postProcessBeanFactory方法\n     * 18 regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据\n\t * 19 查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。\n```\n//beanFactory=DefaultListableBeanFactory\n//beanFactoryPostProcessors 没有添加 所以size=0\npublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\tSet<String> processedBeans = new HashSet<>();\n       //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if\n\t\tif (beanFactory instanceof BeanDefinitionRegistry) {\n\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n\t\t\t//regularPostProcessors 用来存放BeanFactoryPostProcessor，\n\t\t\tList<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n\t\t\t//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor,BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor\n\t\t\tList<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\t\t\t/*\n\t\t\t循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据\n\t\t\t因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的\n\t\t\t只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据\n\t\t\t*/\n\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t/* 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor\n\t\t\t\t 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor\n\t\t\t\t是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去\n\n\t\t\t */\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n\t\t\t\t\tBeanDefinitionRegistryPostProcessor registryProcessor =\n\t\t\t\t\t\t\t(BeanDefinitionRegistryPostProcessor) postProcessor;\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\n\t\t\t/* 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor\n\t\t\tBeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor\n\t\t\t */\n\t\t\tList<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\t/*\n\t\t\t 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n\t\t\t 对象是：ConfigurationClassPostProcessor\n\t\t\t */\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\t/*\n\t\t\t\t\t获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors\n\t\t\t\t\tConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口\n\t\t\t\t\tBeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口\n\t\t\t\t\tConfigurationClassPostProcessor是极其重要的类\n\t\t\t\t\t里面执行了扫描Bean，Import，ImportResouce等各种操作\n\t\t\t\t\t用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑\n\t\t\t\t\t */\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//处理排序\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t/* 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的\n\t\t\t一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法\n\t\t\t而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法\n\t\t\t所以这里需要把处理器放入一个集合中，后续统一执行父类的方法\n\t\t\t */\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t/*可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法\n\t\t\tSpring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理\n\t\t\t如果不想用这个组件，直接把注册组件的那一步去掉就可以\n\t\t\t */\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t//因为currentRegistryProcessors是一个临时变量，所以需要清除\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\t// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口\n\t\t\t// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans\n\t\t\t// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理\n\t\t\t// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//处理排序\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t//合并Processors\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t//执行我们自定义的BeanDefinitionRegistryPostProcessor\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t//清空临时变量\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，\n\t\t\t// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\t//registryProcessors集合装载BeanDefinitionRegistryPostProcessor\n\t\t\t//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\t//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法\n\t\t\t//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t//找到BeanFactoryPostProcessor实现类的BeanName数组\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\t//循环BeanName数组\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\t//如果这个Bean被执行过了，跳过\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\t//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\t//如果实现了Ordered接口，加入到orderedPostProcessorNames\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\t//执行priorityOrderedPostProcessors\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t//执行实现了Ordered接口的BeanFactoryPostProcessor\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, e.g. replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}\n\n```\n[ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry](#ConfigurationClassPostProcessor)\n\n\n \n#### registerBeanPostProcessors(beanFactory);\n#### initMessageSource();\n#### initApplicationEventMulticaster();\n#### onRefresh();\n#### registerListeners();\n#### finishBeanFactoryInitialization(beanFactory);\n#### finishRefresh();\n\n## 循环依赖","source":"_posts/Spring-Bean-生命周期.md","raw":"title: Spring Bean 生命周期\nauthor: wen\ntags: []\ncategories:\n  - Spring\n  - SpringFramework\ndate: 2020-08-09 20:38:00\n---\n# 问题\n* spring 如何产生Bean\n* @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？\n* Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？\n* Spring什么时候解析了@Import注解，如何解析的？\n* Spring什么时候解析了@Bean注解？\n\n# 如何产生bean\n\n```\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n```\n[如何在spring源码中新建model及创建上面的代码](/2020/08/07/spring源码编译/#新建Model)\n[关于ApplicationContext](/2020/08/08/spring源码（一）/#ApplicationContext)\n[spring实例化过程.png](https://www.processon.com/view/link/5f3bce04f346fb06decb7923)\n以上代码：\n* 从一个Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。\n* 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。\n* 对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。\n\n# 启动过程分析\n记住，一定要在电脑中打开源码，不然纯看是很累的。\n[spring源码注释](https://github.com/smallwenzi/springframeworkcode)\n分支是springcode\n\nSpring bean 默认是单例\n为了弄清楚Bean是怎么来的，花费了大把功夫，现在要把Bean Definition的加载、解析、处理、注册到bean工厂的过程记下来\n * \tAnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n [实例化AnnotationConfigApplicationContext(Class<?>... componentClasses](#AnnotationConfigApplicationContext构造方法)\n \t* this()\n    \t* [调用父类GenericApplicationContext的构造函数](#GenericApplicationContext-构造方法)\n        \t* this.beanFactory = new DefaultListableBeanFactory();\n            [实例化DefaultListableBeanFactory](#DefaultListableBeanFactory-构造方法)\n    \t* \tthis.reader = new AnnotatedBeanDefinitionReader(this);\n        [实例化AnnotatedBeanDefinitionReader](#初始化一个Bean读取器AnnotatedBeanDefinitionReader)\n        \t* [registerAnnotationConfigProcessors方法负责向容器里面注册相关的类](#AnnotationConfigUtils-registerAnnotationConfigProcessors)\n        * \tthis.scanner = new ClassPathBeanDefinitionScanner(this);\n            初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的\n    *  [register(componentClasses);](#register-componentClasses)\n    \t* [AnnotatedBeanDefinitionReader 类register 方法](#AnnotatedBeanDefinitionReader-类register-方法)\n        \t* [AnnotatedBeanDefinitionReader的方法doRegisterBean](#AnnotatedBeanDefinitionReader的方法doRegisterBean) 把appconfig注册至bean容器中但是未实例化\n    *  [refresh();](#refresh)\n    \t*  prepareRefresh();\n         刷新前的预处理;\n        * \tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的\n        * prepareBeanFactory(beanFactory);\n         BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器，BeanPostProcessor和XXXAware自动装配等）\n        * postProcessBeanFactory(beanFactory);\n          BeanFactory准备工作完成后进行的后置处理工作\n        * invokeBeanFactoryPostProcessors(beanFactory);\n        执行BeanFactoryPostProcessor的方法；\n        * registerBeanPostProcessors(beanFactory);\n         注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行\n        * initMessageSource();\n        初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；\n        * initApplicationEventMulticaster();\n        初始化事件派发器\n        * \tonRefresh();\n        子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器\n        * registerListeners();\n        注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的\n        * finishBeanFactoryInitialization(beanFactory);\n         初始化所有剩下的非懒加载的单例bean\n        * \tfinishRefresh();\n        完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）\n   \n## AnnotationConfigApplicationContext构造方法\n```\npublic class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {\n\n\tprivate final AnnotatedBeanDefinitionReader reader;\n\n\tprivate final ClassPathBeanDefinitionScanner scanner;\n    \n    /**\n     AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n    这句代码调用以下方法\n   根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少\n  */\n\tpublic AnnotationConfigApplicationContext(Class<?>... componentClasses) {\n     //详细看AnnotationConfigApplicationContext 无参构造\n\t\tthis();\n\t\tregister(componentClasses);\n\t\trefresh();\n\t}\n    \n   public AnnotationConfigApplicationContext() {\n    ////调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()\n     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader\n\t\tthis.reader = new AnnotatedBeanDefinitionReader(this);\n        //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器\n\t\tthis.scanner = new ClassPathBeanDefinitionScanner(this);\n\t}\n    \n}\n```\n* 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数\n\t* 父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory\n   * 本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner\n\t* scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的\n* \n* \n\n### GenericApplicationContext 构造方法\n```\npublic class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {\n \tprivate final DefaultListableBeanFactory beanFactory;\n    public GenericApplicationContext() {\n    //初始化一个BeanFactory\n\t\tthis.beanFactory = new DefaultListableBeanFactory();\n\t}\n\n}\n```\n#### DefaultListableBeanFactory 构造方法\n\n默认实现了ListableBeanFactory和BeanDefinitionRegistry接口，基于bean definition对象，是一个成熟的bean factroy。\n\n最典型的应用是：在访问bean前，先注册所有的definition（可能从bean definition配置文件中）。使用预先建立的bean定义元数据对象，从本地的bean definition表中查询bean definition因而将不会花费太多成本。\n\nDefaultListableBeanFactory既可以作为一个单独的beanFactory，也可以作为自定义beanFactory的父类。\n![DefaultListableBeanFactory类图](Spring-Bean-生命周期/DefaultListableBeanFactory.png)\n\n```\npublic class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n        //存储BeanDefinition对象\n\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\n    \n   \t/** 存储 spring bean 单例对象  */\n\tprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\t/**\n\t * Create a new DefaultListableBeanFactory.\n\t */\n\tpublic DefaultListableBeanFactory() {\n\t\tsuper();\n\t}\n }\n```\n##### AbstractAutowireCapableBeanFactory构造方法\n```\n\tpublic AbstractAutowireCapableBeanFactory() {\n\n\tsuper();\n    //自动装配时忽略指定接口或类的依赖注入\n\t\tignoreDependencyInterface(BeanNameAware.class);\n\t\tignoreDependencyInterface(BeanFactoryAware.class);\n\t\tignoreDependencyInterface(BeanClassLoaderAware.class);\n        }\n```\n###### \tAbstractBeanFactory\n```\n/**\n\t * Create a new AbstractBeanFactory.\n\t */\n\tpublic AbstractBeanFactory() {\n\t}\n ```\n### //初始化一个Bean读取器AnnotatedBeanDefinitionReader\n\n```\nthis.reader = new AnnotatedBeanDefinitionReader(this);\n```\n#### AnnotatedBeanDefinitionReader构造方法\n```\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\t//这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了\n\t\tthis(registry, getOrCreateEnvironment(registry));\n\t}\n```\nAnnotatedBeanDefinitionReader 方法\n```\n\tpublic AnnotatedBeanDefinitionReader (BeanDefinitionRegistry registry, Environment environment) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.registry = registry;\n\t\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);\n\t\t//让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：\n this.registry 是    AnnotationConfigApplicationContext的实例了   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t}\n```\n#### AnnotationConfigUtils.registerAnnotationConfigProcessors\n```\n\tpublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n\t\tregisterAnnotationConfigProcessors(registry, null);\n\t}\n```\n在看registerAnnotationConfigProcessors方法\n* 这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。\n\t\t* ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，\n\t\t* BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，\n\t\t* BeanFactoryPostProcessor是Spring的扩展点之一，\n\t\t*  ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。\n\t\t* 除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。\n\t\t* BeanPostProcessor接口也是Spring的扩展点之一。\n\n执行完方法\nbeanDefs 有5个\n * ConfigurationClassPostProcessor\n * AutowiredAnnotationBeanPostProcessor \n * CommonAnnotationBeanPostProcessor\n * EventListenerMethodProcessor\n * DefaultEventListenerFactory\n```\n// this.registry 是    AnnotationConfigApplicationContext的实例了   \nsource=null\n\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n           //这里返回AnnotationConfigApplicationContext对象中DefaultListableBeanFactory类实例\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\nBeanDefinition\t\tif (beanFactory != null) {\n\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\t//用来支持Spring的Ordered类、@Order注解和@Priority注解。\n                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t/**\n\t\t * 注册解析我们配置类的后置处理器ConfigurationClassPostProcessor\n\t\t * org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\t//如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\t\t/**\n\t\t * 注册处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor\n\t\t *\n\t\t org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor\n\t\t * org.springframework.context.annotation.internalCommonAnnotationProcessor\n\t\t */\n\t\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\n\t\t */\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t/**\n\t\t * 处理监听方法的注解解析器EventListenerMethodProcessor\n\t\t */\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\t\t/**\n\t\t * 注册事件监听器工厂\n\t\t */\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n```\n##### ConfigurationClassPostProcessor\n![ConfigurationClassPostProcessor类图](Spring-Bean-生命周期/ConfigurationClassPostProcessor.png)\n\t* ConfigurationClassPostProcessor是一个BeanFactory的后置处理器，因此它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。\n    * ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。\n    * ConfigurationClassPostProcessor这个类是Spring内置的一个BeanFactory后置处理器，是在this()方法中将其添加到BeanDefinitionMap中的\n    * [postProcessBeanDefinitionRegistry](#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法中)调用\n   ```\n   registry是DefaultListableBeanFactory对象\n   public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n\t\tint registryId = System.identityHashCode(registry);\n\t\tif (this.registriesPostProcessed.contains(registryId)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"postProcessBeanDefinitionRegistry already called on this post-processor against \" + registry);\n\t\t}\n\t\tif (this.factoriesPostProcessed.contains(registryId)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"postProcessBeanFactory already called on this post-processor against \" + registry);\n\t\t}\n\t\tthis.registriesPostProcessed.add(registryId);\n\n\t\tprocessConfigBeanDefinitions(registry);\n\t}\n   ```\n  * processConfigBeanDefinitions 方法 \n     * 从Beanfactory找出含有Configuration 或Component或ComponentScan或Import或ImportResource类 目前只有appconfig类符合\n     * ConfigurationClassParser.parse（）\n     解析appconfig（AnnotatedGenericBeanDefinition 定义）\n     \t* 1 处理内部类\n        \n        * 2 处理@PropertySources注解：进行一些配置信息的解析\n        \n        * 3 处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析\n        \n        * 4 处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：\n        \n\t\t\t\t* 遍历这些@Import注解内部的属性类集合\n                \n\t\t\t\t* 如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第7步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理\n                \n\t\t\t\t* 如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中\n                \n\t\t\t\t* 其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类\n                \n    * 5 处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中\n    \n\t* 6 处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中\n    \n\t* 7 处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理\n    \n  ```\n  public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\t/* 获得所有的BeanDefinition的Name，放入candidateNames数组\n\t\t目前6个：\n\t\tConfigurationClassPostProcessor\n\t\tAutowiredAnnotationBeanPostProcessor\n\t\tCommonAnnotationBeanPostProcessor\n\t\tEventListenerMethodProcessor\n\t\tDefaultEventListenerFactory\n\t\tappconfig\n\t\t */\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n         //循环candidateNames数组\n\t\tfor (String beanName : candidateNames) {\n\t\t\t//根据beanName获得BeanDefinition\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\t/*  内部有两个标记位来标记是否已经处理过了\n\t\t\t 这里会引发一连串知识盲点\n\t\t\t当我们注册配置类的时候，可以不加Configuration注解，\n\t\t\t直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类\n\t\t\t如果加了Configuration注解，就称之为Full配置类\n\t\t\t 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类\n\t\t\t如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了\n\t\t\t 写一个A类，其中有一个构造方法，打印出“你好”\n\t\t\t 再写一个配置类，里面有两个bean注解的方法\n\t\t\t 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA\n\t\t\t 第二个方法又调用了getA方法\n\t\t\t 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次\n\t\t\t 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写\n\t\t\t */\n\t\t\tif (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），\n\t\t\t在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记\n\t\t\t满足条件，加入到configCandidates */\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n        // 如果没有配置类，直接返回\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n        //处理排序\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\t// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\t//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(\n\t\t\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\t//解析配置类（传统意义上的配置类或者是普通bean，核心来了） candidates 仅appConfig类\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\t//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\t//把configClasses加入到alreadyParsed，代表\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\t//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较\n\t\t\t//如果大于的话，说明有新的BeanDefinition注册进来了\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\t//循环alreadyParsed。把类名加入到alreadyParsedClasses\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n  \n  ```\n  \t* ConfigurationClassParser.parse方法\n    ```\n    public void parse(Set<BeanDefinitionHolder> configCandidates) {\n\t\t//循环传进来的配置类\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd = holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\t//如果获得BeanDefinition是AnnotatedBeanDefinition的实例\n\t\t\t\tif (bd instanceof AnnotatedBeanDefinition) {\n\t\t\t\t\tparse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Failed to parse configuration class [\" + bd.getBeanClassName() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\t//执行DeferredImportSelector\n\t\tthis.deferredImportSelectorHandler.process();\n\t}\n    \tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}\n    \n    \n    protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {\n\t\t//判断是否需要跳过\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = asSourceClass(configClass, filter);\n\t\tdo {\n\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n\t\t}\n\t\twhile (sourceClass != null);\n\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}\n\n\n\n\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */\n\t@Nullable\n\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\t//递归处理内部类，一般不会写内部类\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\t//处理@PropertySource注解，@PropertySource注解用来加载properties文件\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\t//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\t//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\t//循环处理componentScans\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\t//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\t//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//处理@Import注解\n\t\t//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解\n\t\t//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar\n\t\t//getImports(sourceClass)是获得import的内容，返回的是一个set\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\t//处理@ImportResource注解\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n    \n    ```\n##### AutowiredAnnotationBeanPostProcessor\n ![AutowiredAnnotationBeanPostProcessor类图](Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png)\n \t* AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有@Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。  \n    *  关于作用后续内容会说到\n##### CommonAnnotationBeanPostProcessor\n  ![CommonAnnotationBeanPostProcessor图](Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png)\n    * CommonAnnotationBeanPostProcessor类在spring中是一个极其重要的类，它负责解析@Resource、@WebServiceRef、@EJB三个注解。这三个注解都是定义在javax.*包下的注解，属于java中的注解\n    * 关于作用后续内容会说到\n ##### PersistenceAnnotationBeanPostProcessor\n   ![PersistenceAnnotationBeanPostProcessor图](Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png)\n \t* PersistenceAnnotationBeanPostProcessor是Spring提供的用于处理注解@PersistenceUnit和@PersistenceContext的BeanPostProcessor。用于注入相应的JPA资源:EntityManagerFactory和EntityManager (或者它们的子类变量)。\n    * 关于作用后续内容会说到\n##### EventListenerMethodProcessor\n    ![EventListenerMethodProcessor图](Spring-Bean-生命周期/EventListenerMethodProcessor.png)\n \t* EventListenerMethodProcessor 是 Spring 事件机制中非常重要的一个组件。它管理了一组EventListenerFactory组件,用来将应用中每个使用@EventListener注解定义的事件监听方法变成一个ApplicationListener实例注册到容器。换句话讲，框架开发者，或者应用开发者使用注解@EventListener定义的事件处理方法，如果没有EventListenerMethodProcessor的发现和注册，是不会被容器看到和使用的。\n    * 关于作用后续内容会说到\n##### DefaultEventListenerFactory\n    ![DefaultEventListenerFactory图](Spring-Bean-生命周期/DefaultEventListenerFactory.png)\n \t* 监听器工厂\n    * 关于作用后续内容会说到\n\n\n#### registerPostProcessor 方法\nregisterPostProcessor方法内部就是注册Bean，\n```\nprivate static BeanDefinitionHolder registerPostProcessor(\n\t\t\tBeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {\n\t    //为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的\n\t\tdefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t//BeanDefinitionRegistry是接口，实现类：AnnotationConfigApplicationContext 实现方法位于：GenericApplicationContext\n\t\t//方法实现this.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\n\t\tregistry.registerBeanDefinition(beanName, definition);\n\t\treturn new BeanDefinitionHolder(definition, beanName);\n\t}\n```\n* RootBeanDefinition 是BeanDefinition接口子类\n BeanDefinition是什么，顾名思义，它是用来描述Bean的，\n\t *  里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，\n\t *  是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，\n     \n![RootBeanDefinition类图](Spring-Bean-生命周期/RootBeanDefinition.png)\n\n至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。\n### 初始化扫描器\nthis.scanner = new ClassPathBeanDefinitionScanner(this);\n### \tregister(componentClasses);\n* 把传入的类进行注册，这里有两个情况，\n* 传入传统的配置类\n* 传入bean（虽然一般没有人会这么做\n* 看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类\n* 但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean\n\n```\n@Override\n//componentClasses= AppConfig.class\npublic void register(Class<?>...componentClasses) {\n\t\tAssert.notEmpty(componentClasses, \"At least one component class must be specified\");\n       //AnnotatedBeanDefinitionReader 类对象\n\t\tthis.reader.register(componentClasses);\n\t}\n    \n```\n\n#### AnnotatedBeanDefinitionReader 类register 方法\n\n```\n//componentClasses= AppConfig.class\npublic void register (Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}\n```\n\n#### AnnotatedBeanDefinitionReader 类 registerBean方法\n\n\tpublic void registerBean(Class<?> beanClass) {\n\t\tdoRegisterBean(beanClass, null, null, null, null);\n\t}\n\n\n\n#### AnnotatedBeanDefinitionReader的方法doRegisterBean\n\n* 1 通过AnnotatedGenericBeanDefinition的构造方法，\n\t 获得配置类的BeanDefinition，这里是不是似曾相似，\n\t 在注册ConfigurationClassPostProcessor类的时候，\n\t 也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，\n\t 现在是通过AnnotatedGenericBeanDefinition去获得。\n* 2 判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。\n* 3 然后是解析作用域，如果没有设置的话，默认为单例。\n* 4 获得BeanName。\n* 5 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。\n* 6 限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。\n* 7 把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。\n* 8 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：\n\n```\n//beanClass= AppConfig.class\n其它参数都是null\nprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类\n\t\t//转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n\t\t//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析\n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n\t\t//解析bean的作用域，如果没有设置的话，默认为单例\n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n\t\t//获得beanName\n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\t\t//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n\t\t//限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种\n\t\t//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，\n\t\t//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理\n\t\t//但是spring提供了其他方式去注册bean，就可能会传入了\n\t\tif (qualifiers != null) {\n\t\t\t//可以传入qualifier数组，所以需要循环处理\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\n\t\t\t\t//Primary注解优先\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\t//Lazy注解\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse { //其他，AnnotatedGenericBeanDefinition有个Map<String,AutowireCandidateQualifier>属性，直接push进去\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\t\t//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中\n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\t//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，\n\t\t//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap\n\t\t//beanDefinitionNames是一个List<String>,用来保存beanName\n\t\t//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n\n```\n* AnnotatedGenericBeanDefinition\n类注解初始化\n![AnnotatedGenericBeanDefinition类图](AnnotatedGenericBeanDefinition.png)\n\n### refresh\nSpring容器创建之后，会调用它的refresh方法刷新Spring应用的上下文。\n#### prepareRefresh();\n//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等\n```\n\tprotected void prepareRefresh() {\n\t\t// Switch to active.\n\t\tthis.startupDate = System.currentTimeMillis();\n\t\tthis.closed.set(false);\n\t\tthis.active.set(true);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Refreshing \" + this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Refreshing \" + getDisplayName());\n\t\t\t}\n\t\t}\n\n\t\t// 空方法\n\t\tinitPropertySources();\n\n\t\t// 验证环境信息里一些必须存在的属性\n\t\tgetEnvironment().validateRequiredProperties();\n\n\t\t// Store pre-refresh ApplicationListeners...\n\t\tif (this.earlyApplicationListeners == null) {\n\t\t\tthis.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n\t\t}\n\t\telse {\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tthis.applicationListeners.clear();\n\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t}\n\n\t\t// Allow for the collection of early ApplicationEvents,\n\t\t// to be published once the multicaster is available...\n\t\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n\t}\n\n```\n####  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n获取AnnotationConfigApplicationContext 中\nDefaultListableBeanFactory对象，DefaultListableBeanFactory是ConfigurableListableBeanFactory子类\n\n#### prepareBeanFactory(beanFactory);\n配置这个工厂的标准环境，比如context的类加载器和post-processors后处理器。\n```\n/**\n\t * 设置了一个类加载器\n\t * 设置了bean表达式解析器\n\t * 添加了属性编辑器的支持\n\t * 添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口\n\t * 设置了一些忽略自动装配的接口\n\t * 设置了一些允许自动装配的接口，并且进行了赋值操作\n\t * 在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean\n\t */\n\tprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\t// Tell the internal bean factory to use the context's class loader etc.\n\t\t//设置类加载器\n\t\tbeanFactory.setBeanClassLoader(getClassLoader());\n\t\t//设置bean表达式解析器\n\t\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n\t\t//属性编辑器支持\n\t\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n\t\t//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口\n\t\t// Configure the bean factory with context callbacks.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\t\t//以下接口，忽略自动装配\n\t\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n\t\t//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值\n\t\t// BeanFactory interface not registered as resolvable type in a plain factory.\n\t\t// MessageSource registered (and found for autowiring) as a bean.\n\t\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n\t\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n\t\t//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口\n\t\t// Register early post-processor for detecting inner beans as ApplicationListeners.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found.\n\t\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\t// Set a temporary ClassLoader for type matching.\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\n\t\t//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean\n\t\t// 注册环境变量\n\t\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n\t\t}\n\t}\n```\n* ApplicationContextAwareProcessor\nApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor,用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性:\n\n * EnvironmentAware\n * EmbeddedValueResolverAware\n * ResourceLoaderAware\n * ApplicationEventPublisherAware\n * MessageSourceAware\n * ApplicationContextAware\n ApplicationContextAwareProcessor自己会被应用程序上下文自动注册到bean容器,不需要应用开发人员操心\n 后续内容会分析作用\n* ApplicationListenerDetector\n *  1、在Bean初始化完成之后：如果Bean是单例的则并且bean instanceof ApplicationListener。加入到this.applicationListeners中。\n\n * 2、在Bean销毁之前搞事情： 如果Bean是一个ApplicationListener，则会从ApplicationEventMulticaster（事件广播器）中提前删除了\n 后续内容会分析作用\n* LoadTimeWeaverAwareProcessor \n 增加对 AspectJ 的支持\n 后续说到aop会详细说\n#### postProcessBeanFactory(beanFactory);\n 空方法\n#### invokeBeanFactoryPostProcessors(beanFactory);\n在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。\n```\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n\t\t//spring允许我们手动添加BeanFactoryPostProcessor\n\t\t//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);\n\t\t//getBeanFactoryPostProcessors() 在外部可以手动添加一个后置处理器，而不是交给Spring去扫描\n\t\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\t\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\t}\n\n```\n\n##### \tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法\n先介绍两个接口：\n\n* BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理\n* BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理\n\n过程：\n* beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if\n\n\t * 1 定义了一个Set（processedBeans），装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。\n\t * 2 定义了两个List，\n     \t* 一个是regularPostProcessors，用来装载BeanFactoryPostProcessor\n        \n      * 一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。\n      \n\t * 3 循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。\n     \n\t * 4 定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。\n     \n\t * 5 getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。\n     \n\t * 6 循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，\n     \t* 判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了(当然现在还没有处理，但是马上就要处理了)\n\t * 7 进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。\n\t * 8 把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。\n\t * 9 可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。\n\t * 10 清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。\n\t * 11 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。\n\t * 12 处理排序。\n\t * 13 合并Processors，合并的理由和上面是一样的。\n\t * 14 执行我们自定义的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。\n\t * 15 清空临时变量。\n\t * 16 在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。\n\t * 17 regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的postProcessBeanFactory方法\n     * 18 regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据\n\t * 19 查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。\n```\n//beanFactory=DefaultListableBeanFactory\n//beanFactoryPostProcessors 没有添加 所以size=0\npublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\tSet<String> processedBeans = new HashSet<>();\n       //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if\n\t\tif (beanFactory instanceof BeanDefinitionRegistry) {\n\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n\t\t\t//regularPostProcessors 用来存放BeanFactoryPostProcessor，\n\t\t\tList<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n\t\t\t//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor,BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor\n\t\t\tList<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\t\t\t/*\n\t\t\t循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据\n\t\t\t因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的\n\t\t\t只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据\n\t\t\t*/\n\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t/* 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor\n\t\t\t\t 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor\n\t\t\t\t是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去\n\n\t\t\t */\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n\t\t\t\t\tBeanDefinitionRegistryPostProcessor registryProcessor =\n\t\t\t\t\t\t\t(BeanDefinitionRegistryPostProcessor) postProcessor;\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\n\t\t\t/* 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor\n\t\t\tBeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor\n\t\t\t */\n\t\t\tList<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\t/*\n\t\t\t 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n\t\t\t 对象是：ConfigurationClassPostProcessor\n\t\t\t */\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\t/*\n\t\t\t\t\t获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors\n\t\t\t\t\tConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口\n\t\t\t\t\tBeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口\n\t\t\t\t\tConfigurationClassPostProcessor是极其重要的类\n\t\t\t\t\t里面执行了扫描Bean，Import，ImportResouce等各种操作\n\t\t\t\t\t用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑\n\t\t\t\t\t */\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//处理排序\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t/* 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的\n\t\t\t一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法\n\t\t\t而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法\n\t\t\t所以这里需要把处理器放入一个集合中，后续统一执行父类的方法\n\t\t\t */\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t/*可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法\n\t\t\tSpring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理\n\t\t\t如果不想用这个组件，直接把注册组件的那一步去掉就可以\n\t\t\t */\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t//因为currentRegistryProcessors是一个临时变量，所以需要清除\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\t// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口\n\t\t\t// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans\n\t\t\t// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理\n\t\t\t// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//处理排序\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t//合并Processors\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t//执行我们自定义的BeanDefinitionRegistryPostProcessor\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t//清空临时变量\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，\n\t\t\t// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\t//registryProcessors集合装载BeanDefinitionRegistryPostProcessor\n\t\t\t//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\t//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法\n\t\t\t//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t//找到BeanFactoryPostProcessor实现类的BeanName数组\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\t//循环BeanName数组\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\t//如果这个Bean被执行过了，跳过\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\t//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\t//如果实现了Ordered接口，加入到orderedPostProcessorNames\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\t//执行priorityOrderedPostProcessors\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t//执行实现了Ordered接口的BeanFactoryPostProcessor\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, e.g. replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}\n\n```\n[ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry](#ConfigurationClassPostProcessor)\n\n\n \n#### registerBeanPostProcessors(beanFactory);\n#### initMessageSource();\n#### initApplicationEventMulticaster();\n#### onRefresh();\n#### registerListeners();\n#### finishBeanFactoryInitialization(beanFactory);\n#### finishRefresh();\n\n## 循环依赖","slug":"Spring-Bean-生命周期","published":1,"updated":"2020-08-18T13:36:41.156Z","_id":"ckdzce376000bn6zquf8ef1vk","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ul>\n<li>spring 如何产生Bean</li>\n<li>@Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li>\n<li>Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li>\n<li>Spring什么时候解析了@Import注解，如何解析的？</li>\n<li>Spring什么时候解析了@Bean注解？</li>\n</ul>\n<h1 id=\"如何产生bean\"><a href=\"#如何产生bean\" class=\"headerlink\" title=\"如何产生bean\"></a>如何产生bean</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"/2020/08/07/spring源码编译/#新建Model\">如何在spring源码中新建model及创建上面的代码</a><br><a href=\"/2020/08/08/spring源码（一）/#ApplicationContext\">关于ApplicationContext</a><br><a href=\"https://www.processon.com/view/link/5f3bce04f346fb06decb7923\" target=\"_blank\" rel=\"noopener\">spring实例化过程.png</a><br>以上代码：</p>\n<ul>\n<li>从一个Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。</li>\n<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>\n<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>\n</ul>\n<h1 id=\"启动过程分析\"><a href=\"#启动过程分析\" class=\"headerlink\" title=\"启动过程分析\"></a>启动过程分析</h1><p>记住，一定要在电脑中打开源码，不然纯看是很累的。<br><a href=\"https://github.com/smallwenzi/springframeworkcode\" target=\"_blank\" rel=\"noopener\">spring源码注释</a><br>分支是springcode</p>\n<p>Spring bean 默认是单例<br>为了弄清楚Bean是怎么来的，花费了大把功夫，现在要把Bean Definition的加载、解析、处理、注册到bean工厂的过程记下来</p>\n<ul>\n<li>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);<br><a href=\"#AnnotationConfigApplicationContext构造方法\">实例化AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses</a><ul>\n<li>this()<ul>\n<li><a href=\"#GenericApplicationContext-构造方法\">调用父类GenericApplicationContext的构造函数</a><ul>\n<li>this.beanFactory = new DefaultListableBeanFactory();<br><a href=\"#DefaultListableBeanFactory-构造方法\">实例化DefaultListableBeanFactory</a></li>\n</ul>\n</li>\n<li>this.reader = new AnnotatedBeanDefinitionReader(this);<br><a href=\"#初始化一个Bean读取器AnnotatedBeanDefinitionReader\">实例化AnnotatedBeanDefinitionReader</a><ul>\n<li><a href=\"#AnnotationConfigUtils-registerAnnotationConfigProcessors\">registerAnnotationConfigProcessors方法负责向容器里面注册相关的类</a></li>\n</ul>\n</li>\n<li>this.scanner = new ClassPathBeanDefinitionScanner(this);<br>初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>\n</ul>\n</li>\n<li><a href=\"#register-componentClasses\">register(componentClasses);</a><ul>\n<li><a href=\"#AnnotatedBeanDefinitionReader-类register-方法\">AnnotatedBeanDefinitionReader 类register 方法</a><ul>\n<li><a href=\"#AnnotatedBeanDefinitionReader的方法doRegisterBean\">AnnotatedBeanDefinitionReader的方法doRegisterBean</a> 把appconfig注册至bean容器中但是未实例化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#refresh\">refresh();</a><ul>\n<li>prepareRefresh();<br>刷新前的预处理;</li>\n<li>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的</li>\n<li>prepareBeanFactory(beanFactory);<br>BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器，BeanPostProcessor和XXXAware自动装配等）</li>\n<li>postProcessBeanFactory(beanFactory);<br>BeanFactory准备工作完成后进行的后置处理工作</li>\n<li>invokeBeanFactoryPostProcessors(beanFactory);<br>执行BeanFactoryPostProcessor的方法；</li>\n<li>registerBeanPostProcessors(beanFactory);<br>注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行</li>\n<li>initMessageSource();<br>初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</li>\n<li>initApplicationEventMulticaster();<br>初始化事件派发器</li>\n<li>onRefresh();<br>子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器</li>\n<li>registerListeners();<br>注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的</li>\n<li>finishBeanFactoryInitialization(beanFactory);<br>初始化所有剩下的非懒加载的单例bean</li>\n<li>finishRefresh();<br>完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AnnotationConfigApplicationContext构造方法\"><a href=\"#AnnotationConfigApplicationContext构造方法\" class=\"headerlink\" title=\"AnnotationConfigApplicationContext构造方法\"></a>AnnotationConfigApplicationContext构造方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final AnnotatedBeanDefinitionReader reader;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final ClassPathBeanDefinitionScanner scanner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">    这句代码调用以下方法</span><br><span class=\"line\">   根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少</span><br><span class=\"line\">  */</span><br><span class=\"line\">\tpublic AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) &#123;</span><br><span class=\"line\">     //详细看AnnotationConfigApplicationContext 无参构造</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tregister(componentClasses);</span><br><span class=\"line\">\t\trefresh();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   public AnnotationConfigApplicationContext() &#123;</span><br><span class=\"line\">    ////调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()</span><br><span class=\"line\">     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader</span><br><span class=\"line\">\t\tthis.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class=\"line\">        //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器</span><br><span class=\"line\">\t\tthis.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调用无参构造函数，会先调用父类GenericApplicationContext的构造函数<ul>\n<li>父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory<ul>\n<li>本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner</li>\n</ul>\n</li>\n<li>scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>\n</ul>\n</li>\n<li></li>\n<li></li>\n</ul>\n<h3 id=\"GenericApplicationContext-构造方法\"><a href=\"#GenericApplicationContext-构造方法\" class=\"headerlink\" title=\"GenericApplicationContext 构造方法\"></a>GenericApplicationContext 构造方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry &#123;</span><br><span class=\"line\"> \tprivate final DefaultListableBeanFactory beanFactory;</span><br><span class=\"line\">    public GenericApplicationContext() &#123;</span><br><span class=\"line\">    //初始化一个BeanFactory</span><br><span class=\"line\">\t\tthis.beanFactory = new DefaultListableBeanFactory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DefaultListableBeanFactory-构造方法\"><a href=\"#DefaultListableBeanFactory-构造方法\" class=\"headerlink\" title=\"DefaultListableBeanFactory 构造方法\"></a>DefaultListableBeanFactory 构造方法</h4><p>默认实现了ListableBeanFactory和BeanDefinitionRegistry接口，基于bean definition对象，是一个成熟的bean factroy。</p>\n<p>最典型的应用是：在访问bean前，先注册所有的definition（可能从bean definition配置文件中）。使用预先建立的bean定义元数据对象，从本地的bean definition表中查询bean definition因而将不会花费太多成本。</p>\n<p>DefaultListableBeanFactory既可以作为一个单独的beanFactory，也可以作为自定义beanFactory的父类。<br><img src=\"/2020/08/09/Spring-Bean-生命周期/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory</span><br><span class=\"line\">        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class=\"line\">        //存储BeanDefinition对象</span><br><span class=\"line\">\tprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t/** 存储 spring bean 单例对象  */</span><br><span class=\"line\">\tprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Create a new DefaultListableBeanFactory.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic DefaultListableBeanFactory() &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"AbstractAutowireCapableBeanFactory构造方法\"><a href=\"#AbstractAutowireCapableBeanFactory构造方法\" class=\"headerlink\" title=\"AbstractAutowireCapableBeanFactory构造方法\"></a>AbstractAutowireCapableBeanFactory构造方法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AbstractAutowireCapableBeanFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">super();</span><br><span class=\"line\">   //自动装配时忽略指定接口或类的依赖注入</span><br><span class=\"line\">\tignoreDependencyInterface(BeanNameAware.class);</span><br><span class=\"line\">\tignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class=\"line\">\tignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"AbstractBeanFactory\"><a href=\"#AbstractBeanFactory\" class=\"headerlink\" title=\"AbstractBeanFactory\"></a>AbstractBeanFactory</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * Create a new AbstractBeanFactory.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic AbstractBeanFactory() &#123;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化一个Bean读取器AnnotatedBeanDefinitionReader\"><a href=\"#初始化一个Bean读取器AnnotatedBeanDefinitionReader\" class=\"headerlink\" title=\"//初始化一个Bean读取器AnnotatedBeanDefinitionReader\"></a>//初始化一个Bean读取器AnnotatedBeanDefinitionReader</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.reader = new AnnotatedBeanDefinitionReader(this);</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader构造方法\"><a href=\"#AnnotatedBeanDefinitionReader构造方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader构造方法\"></a>AnnotatedBeanDefinitionReader构造方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t//这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了</span><br><span class=\"line\">\tthis(registry, getOrCreateEnvironment(registry));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AnnotatedBeanDefinitionReader 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AnnotatedBeanDefinitionReader (BeanDefinitionRegistry registry, Environment environment) &#123;</span><br><span class=\"line\">\tAssert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class=\"line\">\tAssert.notNull(environment, &quot;Environment must not be null&quot;);</span><br><span class=\"line\">\tthis.registry = registry;</span><br><span class=\"line\">\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);</span><br><span class=\"line\">\t//让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：</span><br><span class=\"line\">this.registry 是    AnnotationConfigApplicationContext的实例了   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"AnnotationConfigUtils-registerAnnotationConfigProcessors\"><a href=\"#AnnotationConfigUtils-registerAnnotationConfigProcessors\" class=\"headerlink\" title=\"AnnotationConfigUtils.registerAnnotationConfigProcessors\"></a>AnnotationConfigUtils.registerAnnotationConfigProcessors</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tregisterAnnotationConfigProcessors(registry, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在看registerAnnotationConfigProcessors方法</p>\n<ul>\n<li>这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。<pre><code>* ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，\n* BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，\n* BeanFactoryPostProcessor是Spring的扩展点之一，\n*  ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。\n* 除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。\n* BeanPostProcessor接口也是Spring的扩展点之一。\n</code></pre></li>\n</ul>\n<p>执行完方法<br>beanDefs 有5个</p>\n<ul>\n<li>ConfigurationClassPostProcessor</li>\n<li>AutowiredAnnotationBeanPostProcessor </li>\n<li>CommonAnnotationBeanPostProcessor</li>\n<li>EventListenerMethodProcessor</li>\n<li>DefaultEventListenerFactory<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// this.registry 是    AnnotationConfigApplicationContext的实例了   </span><br><span class=\"line\">source=null</span><br><span class=\"line\">\tpublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class=\"line\">           //这里返回AnnotationConfigApplicationContext对象中DefaultListableBeanFactory类实例</span><br><span class=\"line\">\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class=\"line\">BeanDefinition\t\tif (beanFactory != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class=\"line\">\t\t\t\t//用来支持Spring的Ordered类、@Order注解和@Priority注解。</span><br><span class=\"line\">                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class=\"line\">\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t\t * 注册解析我们配置类的后置处理器ConfigurationClassPostProcessor</span><br><span class=\"line\">\t\t * org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\t//如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t *</span><br><span class=\"line\">\t\t org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t * org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br><span class=\"line\">\t\tif (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><br><span class=\"line\">\t\tif (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition();</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class=\"line\">\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t\t\t&quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 处理监听方法的注解解析器EventListenerMethodProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册事件监听器工厂</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn beanDefs;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"ConfigurationClassPostProcessor\"><a href=\"#ConfigurationClassPostProcessor\" class=\"headerlink\" title=\"ConfigurationClassPostProcessor\"></a>ConfigurationClassPostProcessor</h5><p><img src=\"/2020/08/09/Spring-Bean-生命周期/ConfigurationClassPostProcessor.png\" alt=\"ConfigurationClassPostProcessor类图\"></p>\n<pre><code>* ConfigurationClassPostProcessor是一个BeanFactory的后置处理器，因此它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。\n* ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。\n* ConfigurationClassPostProcessor这个类是Spring内置的一个BeanFactory后置处理器，是在this()方法中将其添加到BeanDefinitionMap中的\n* [postProcessBeanDefinitionRegistry](#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法中)调用\n</code></pre>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  registry是DefaultListableBeanFactory对象</span><br><span class=\"line\">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tint registryId = System.identityHashCode(registry);</span><br><span class=\"line\">\tif (this.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class=\"line\">\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (this.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class=\"line\">\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.registriesPostProcessed.add(registryId);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprocessConfigBeanDefinitions(registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>processConfigBeanDefinitions 方法 </p>\n<ul>\n<li>从Beanfactory找出含有Configuration 或Component或ComponentScan或Import或ImportResource类 目前只有appconfig类符合</li>\n<li><p>ConfigurationClassParser.parse（）<br>解析appconfig（AnnotatedGenericBeanDefinition 定义）</p>\n<ul>\n<li><p>1 处理内部类</p>\n<ul>\n<li><p>2 处理@PropertySources注解：进行一些配置信息的解析</p>\n</li>\n<li><p>3 处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</p>\n</li>\n<li><p>4 处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：</p>\n<ul>\n<li><p>遍历这些@Import注解内部的属性类集合</p>\n</li>\n<li><p>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第7步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</p>\n</li>\n<li><p>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</p>\n</li>\n<li><p>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>5 处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</p>\n</li>\n<li><p>6 处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</p>\n</li>\n<li><p>7 处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tList&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t/* 获得所有的BeanDefinition的Name，放入candidateNames数组</span><br><span class=\"line\">\t目前6个：</span><br><span class=\"line\">\tConfigurationClassPostProcessor</span><br><span class=\"line\">\tAutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">\tCommonAnnotationBeanPostProcessor</span><br><span class=\"line\">\tEventListenerMethodProcessor</span><br><span class=\"line\">\tDefaultEventListenerFactory</span><br><span class=\"line\">\tappconfig</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tString[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class=\"line\">        //循环candidateNames数组</span><br><span class=\"line\">\tfor (String beanName : candidateNames) &#123;</span><br><span class=\"line\">\t\t//根据beanName获得BeanDefinition</span><br><span class=\"line\">\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class=\"line\">\t\t/*  内部有两个标记位来标记是否已经处理过了</span><br><span class=\"line\">\t\t 这里会引发一连串知识盲点</span><br><span class=\"line\">\t\t当我们注册配置类的时候，可以不加Configuration注解，</span><br><span class=\"line\">\t\t直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类</span><br><span class=\"line\">\t\t如果加了Configuration注解，就称之为Full配置类</span><br><span class=\"line\">\t\t 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类</span><br><span class=\"line\">\t\t如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了</span><br><span class=\"line\">\t\t 写一个A类，其中有一个构造方法，打印出“你好”</span><br><span class=\"line\">\t\t 再写一个配置类，里面有两个bean注解的方法</span><br><span class=\"line\">\t\t 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA</span><br><span class=\"line\">\t\t 第二个方法又调用了getA方法</span><br><span class=\"line\">\t\t 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次</span><br><span class=\"line\">\t\t 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123;</span><br><span class=\"line\">\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\tlogger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/* 判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），</span><br><span class=\"line\">\t\t在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记</span><br><span class=\"line\">\t\t满足条件，加入到configCandidates */</span><br><span class=\"line\">\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class=\"line\">\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">       // 如果没有配置类，直接返回</span><br><span class=\"line\">\t// Return immediately if no @Configuration classes were found</span><br><span class=\"line\">\tif (configCandidates.isEmpty()) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">       //处理排序</span><br><span class=\"line\">\t// Sort by previously determined @Order value, if applicable</span><br><span class=\"line\">\tconfigCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class=\"line\">\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class=\"line\">\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class=\"line\">\t\treturn Integer.compare(i1, i2);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Detect any custom bean name generation strategy supplied through the enclosing application context</span><br><span class=\"line\">\tSingletonBeanRegistry sbr = null;</span><br><span class=\"line\">\t// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if</span><br><span class=\"line\">\tif (registry instanceof SingletonBeanRegistry) &#123;</span><br><span class=\"line\">\t\tsbr = (SingletonBeanRegistry) registry;</span><br><span class=\"line\">\t\tif (!this.localBeanNameGeneratorSet) &#123;</span><br><span class=\"line\">\t\t\t//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做</span><br><span class=\"line\">\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class=\"line\">\t\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class=\"line\">\t\t\tif (generator != null) &#123;</span><br><span class=\"line\">\t\t\t\tthis.componentScanBeanNameGenerator = generator;</span><br><span class=\"line\">\t\t\t\tthis.importBeanNameGenerator = generator;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.environment == null) &#123;</span><br><span class=\"line\">\t\tthis.environment = new StandardEnvironment();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Parse each @Configuration class</span><br><span class=\"line\">\tConfigurationClassParser parser = new ConfigurationClassParser(</span><br><span class=\"line\">\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,</span><br><span class=\"line\">\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSet&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class=\"line\">\tSet&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());</span><br><span class=\"line\">\tdo &#123;</span><br><span class=\"line\">\t\t//解析配置类（传统意义上的配置类或者是普通bean，核心来了） candidates 仅appConfig类</span><br><span class=\"line\">\t\tparser.parse(candidates);</span><br><span class=\"line\">\t\tparser.validate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class=\"line\">\t\tconfigClasses.removeAll(alreadyParsed);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Read the model and create bean definitions based on its content</span><br><span class=\"line\">\t\tif (this.reader == null) &#123;</span><br><span class=\"line\">\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(</span><br><span class=\"line\">\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,</span><br><span class=\"line\">\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition</span><br><span class=\"line\">\t\tthis.reader.loadBeanDefinitions(configClasses);</span><br><span class=\"line\">\t\t//把configClasses加入到alreadyParsed，代表</span><br><span class=\"line\">\t\talreadyParsed.addAll(configClasses);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcandidates.clear();</span><br><span class=\"line\">\t\t//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较</span><br><span class=\"line\">\t\t//如果大于的话，说明有新的BeanDefinition注册进来了</span><br><span class=\"line\">\t\tif (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class=\"line\">\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class=\"line\">\t\t\tSet&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class=\"line\">\t\t\tSet&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t\t//循环alreadyParsed。把类名加入到alreadyParsedClasses</span><br><span class=\"line\">\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class=\"line\">\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (String candidateName : newCandidateNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class=\"line\">\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class=\"line\">\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcandidateNames = newCandidateNames;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (!candidates.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><br><span class=\"line\">\tif (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;</span><br><span class=\"line\">\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span><br><span class=\"line\">\t\t// for a shared cache since it&apos;ll be cleared by the ApplicationContext.</span><br><span class=\"line\">\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ConfigurationClassParser.parse方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;</span><br><span class=\"line\">\t//循环传进来的配置类</span><br><span class=\"line\">\tfor (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class=\"line\">\t\tBeanDefinition bd = holder.getBeanDefinition();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t//如果获得BeanDefinition是AnnotatedBeanDefinition的实例</span><br><span class=\"line\">\t\t\tif (bd instanceof AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">\t\t\t\tparse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class=\"line\">\t\t\t\tparse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\tparse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">\t\t\tthrow ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Throwable ex) &#123;</span><br><span class=\"line\">\t\t\tthrow new BeanDefinitionStoreException(</span><br><span class=\"line\">\t\t\t\t\t&quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//执行DeferredImportSelector</span><br><span class=\"line\">\tthis.deferredImportSelectorHandler.process();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   \tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException &#123;</span><br><span class=\"line\">\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123;</span><br><span class=\"line\">\t//判断是否需要跳过</span><br><span class=\"line\">\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tConfigurationClass existingClass = this.configurationClasses.get(configClass);</span><br><span class=\"line\">\tif (existingClass != null) &#123;</span><br><span class=\"line\">\t\tif (configClass.isImported()) &#123;</span><br><span class=\"line\">\t\t\tif (existingClass.isImported()) &#123;</span><br><span class=\"line\">\t\t\t\texistingClass.mergeImportedBy(configClass);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\t// Explicit bean definition found, probably replacing an import.</span><br><span class=\"line\">\t\t\t// Let&apos;s remove the old one and go with the new one.</span><br><span class=\"line\">\t\t\tthis.configurationClasses.remove(configClass);</span><br><span class=\"line\">\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Recursively process the configuration class and its superclass hierarchy.</span><br><span class=\"line\">\tSourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class=\"line\">\tdo &#123;</span><br><span class=\"line\">\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (sourceClass != null);</span><br><span class=\"line\"></span><br><span class=\"line\">\tthis.configurationClasses.put(configClass, configClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Apply processing and build a complete &#123;@link ConfigurationClass&#125; by reading the</span><br><span class=\"line\"> * annotations, members and methods from the source class. This method can be called</span><br><span class=\"line\"> * multiple times as relevant sources are discovered.</span><br><span class=\"line\"> * @param configClass the configuration class being build</span><br><span class=\"line\"> * @param sourceClass a source class</span><br><span class=\"line\"> * @return the superclass, or &#123;@code null&#125; if none found or previously processed</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected final SourceClass doProcessConfigurationClass(</span><br><span class=\"line\">\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span><br><span class=\"line\">\t\tthrows IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class=\"line\">\t\t// Recursively process any member (nested) classes first</span><br><span class=\"line\">\t\t//递归处理内部类，一般不会写内部类</span><br><span class=\"line\">\t\tprocessMemberClasses(configClass, sourceClass, filter);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @PropertySource annotations</span><br><span class=\"line\">\t//处理@PropertySource注解，@PropertySource注解用来加载properties文件</span><br><span class=\"line\">\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class=\"line\">\t\t\tsourceClass.getMetadata(), PropertySources.class,</span><br><span class=\"line\">\t\t\torg.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class=\"line\">\t\tif (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class=\"line\">\t\t\tprocessPropertySource(propertySource);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tlogger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class=\"line\">\t\t\t\t\t&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @ComponentScan annotations</span><br><span class=\"line\">\t//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等</span><br><span class=\"line\">\tSet&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class=\"line\">\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class=\"line\">\t//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if</span><br><span class=\"line\">\tif (!componentScans.isEmpty() &amp;&amp;</span><br><span class=\"line\">\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class=\"line\">\t\t//循环处理componentScans</span><br><span class=\"line\">\t\tfor (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class=\"line\">\t\t\t// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class=\"line\">\t\t\t//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称</span><br><span class=\"line\">\t\t\tSet&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class=\"line\">\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class=\"line\">\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class=\"line\">\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class=\"line\">\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class=\"line\">\t\t\t\tif (bdCand == null) &#123;</span><br><span class=\"line\">\t\t\t\t\tbdCand = holder.getBeanDefinition();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class=\"line\">\t\t\t\t\t//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解</span><br><span class=\"line\">\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//处理@Import注解</span><br><span class=\"line\">\t//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解</span><br><span class=\"line\">\t//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar</span><br><span class=\"line\">\t//getImports(sourceClass)是获得import的内容，返回的是一个set</span><br><span class=\"line\">\t// Process any @Import annotations</span><br><span class=\"line\">\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @ImportResource annotations</span><br><span class=\"line\">\t//处理@ImportResource注解</span><br><span class=\"line\">\tAnnotationAttributes importResource =</span><br><span class=\"line\">\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class=\"line\">\tif (importResource != null) &#123;</span><br><span class=\"line\">\t\tString[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class=\"line\">\t\tClass&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class=\"line\">\t\tfor (String resource : resources) &#123;</span><br><span class=\"line\">\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class=\"line\">\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收</span><br><span class=\"line\">\t// Process individual @Bean methods</span><br><span class=\"line\">\tSet&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class=\"line\">\tfor (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class=\"line\">\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process default methods on interfaces</span><br><span class=\"line\">\tprocessInterfaces(configClass, sourceClass);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process superclass, if any</span><br><span class=\"line\">\tif (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class=\"line\">\t\tString superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class=\"line\">\t\tif (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class=\"line\">\t\t\tthis.knownSuperclasses.put(superclass, configClass);</span><br><span class=\"line\">\t\t\t// Superclass found, return its annotation metadata and recurse</span><br><span class=\"line\">\t\t\treturn sourceClass.getSuperClass();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// No superclass -&gt; processing is complete</span><br><span class=\"line\">\treturn null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"AutowiredAnnotationBeanPostProcessor\"><a href=\"#AutowiredAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"AutowiredAnnotationBeanPostProcessor\"></a>AutowiredAnnotationBeanPostProcessor</h5><p> <img src=\"/2020/08/09/Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png\" alt=\"AutowiredAnnotationBeanPostProcessor类图\"></p>\n<pre><code> * AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有@Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。  \n*  关于作用后续内容会说到\n</code></pre><h5 id=\"CommonAnnotationBeanPostProcessor\"><a href=\"#CommonAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"CommonAnnotationBeanPostProcessor\"></a>CommonAnnotationBeanPostProcessor</h5><p>  <img src=\"/2020/08/09/Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png\" alt=\"CommonAnnotationBeanPostProcessor图\"></p>\n<pre><code>* CommonAnnotationBeanPostProcessor类在spring中是一个极其重要的类，它负责解析@Resource、@WebServiceRef、@EJB三个注解。这三个注解都是定义在javax.*包下的注解，属于java中的注解\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"PersistenceAnnotationBeanPostProcessor\"><a href=\"#PersistenceAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"PersistenceAnnotationBeanPostProcessor\"></a>PersistenceAnnotationBeanPostProcessor</h5><p>   <img src=\"/2020/08/09/Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png\" alt=\"PersistenceAnnotationBeanPostProcessor图\"></p>\n<pre><code> * PersistenceAnnotationBeanPostProcessor是Spring提供的用于处理注解@PersistenceUnit和@PersistenceContext的BeanPostProcessor。用于注入相应的JPA资源:EntityManagerFactory和EntityManager (或者它们的子类变量)。\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"EventListenerMethodProcessor\"><a href=\"#EventListenerMethodProcessor\" class=\"headerlink\" title=\"EventListenerMethodProcessor\"></a>EventListenerMethodProcessor</h5><pre><code>![EventListenerMethodProcessor图](Spring-Bean-生命周期/EventListenerMethodProcessor.png)\n * EventListenerMethodProcessor 是 Spring 事件机制中非常重要的一个组件。它管理了一组EventListenerFactory组件,用来将应用中每个使用@EventListener注解定义的事件监听方法变成一个ApplicationListener实例注册到容器。换句话讲，框架开发者，或者应用开发者使用注解@EventListener定义的事件处理方法，如果没有EventListenerMethodProcessor的发现和注册，是不会被容器看到和使用的。\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"DefaultEventListenerFactory\"><a href=\"#DefaultEventListenerFactory\" class=\"headerlink\" title=\"DefaultEventListenerFactory\"></a>DefaultEventListenerFactory</h5><pre><code>![DefaultEventListenerFactory图](Spring-Bean-生命周期/DefaultEventListenerFactory.png)\n * 监听器工厂\n* 关于作用后续内容会说到\n</code></pre><h4 id=\"registerPostProcessor-方法\"><a href=\"#registerPostProcessor-方法\" class=\"headerlink\" title=\"registerPostProcessor 方法\"></a>registerPostProcessor 方法</h4><p>registerPostProcessor方法内部就是注册Bean，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static BeanDefinitionHolder registerPostProcessor(</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) &#123;</span><br><span class=\"line\">\t    //为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的</span><br><span class=\"line\">\t\tdefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class=\"line\">\t\t//BeanDefinitionRegistry是接口，实现类：AnnotationConfigApplicationContext 实现方法位于：GenericApplicationContext</span><br><span class=\"line\">\t\t//方法实现this.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tregistry.registerBeanDefinition(beanName, definition);</span><br><span class=\"line\">\t\treturn new BeanDefinitionHolder(definition, beanName);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>RootBeanDefinition 是BeanDefinition接口子类<br>BeanDefinition是什么，顾名思义，它是用来描述Bean的，<ul>\n<li>里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，</li>\n<li>是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/09/Spring-Bean-生命周期/RootBeanDefinition.png\" alt=\"RootBeanDefinition类图\"></p>\n<p>至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。</p>\n<h3 id=\"初始化扫描器\"><a href=\"#初始化扫描器\" class=\"headerlink\" title=\"初始化扫描器\"></a>初始化扫描器</h3><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p>\n<h3 id=\"register-componentClasses\"><a href=\"#register-componentClasses\" class=\"headerlink\" title=\"register(componentClasses);\"></a>register(componentClasses);</h3><ul>\n<li>把传入的类进行注册，这里有两个情况，</li>\n<li>传入传统的配置类</li>\n<li>传入bean（虽然一般没有人会这么做</li>\n<li>看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类</li>\n<li>但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">//componentClasses= AppConfig.class</span><br><span class=\"line\">public void register(Class&lt;?&gt;...componentClasses) &#123;</span><br><span class=\"line\">\t\tAssert.notEmpty(componentClasses, &quot;At least one component class must be specified&quot;);</span><br><span class=\"line\">       //AnnotatedBeanDefinitionReader 类对象</span><br><span class=\"line\">\t\tthis.reader.register(componentClasses);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader-类register-方法\"><a href=\"#AnnotatedBeanDefinitionReader-类register-方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader 类register 方法\"></a>AnnotatedBeanDefinitionReader 类register 方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//componentClasses= AppConfig.class</span><br><span class=\"line\">public void register (Class&lt;?&gt;... componentClasses) &#123;</span><br><span class=\"line\">\t\tfor (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class=\"line\">\t\t\tregisterBean(componentClass);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader-类-registerBean方法\"><a href=\"#AnnotatedBeanDefinitionReader-类-registerBean方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader 类 registerBean方法\"></a>AnnotatedBeanDefinitionReader 类 registerBean方法</h4><pre><code>public void registerBean(Class&lt;?&gt; beanClass) {\n    doRegisterBean(beanClass, null, null, null, null);\n}\n</code></pre><h4 id=\"AnnotatedBeanDefinitionReader的方法doRegisterBean\"><a href=\"#AnnotatedBeanDefinitionReader的方法doRegisterBean\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader的方法doRegisterBean\"></a>AnnotatedBeanDefinitionReader的方法doRegisterBean</h4><ul>\n<li>1 通过AnnotatedGenericBeanDefinition的构造方法，<br>   获得配置类的BeanDefinition，这里是不是似曾相似，<br>   在注册ConfigurationClassPostProcessor类的时候，<br>   也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，<br>   现在是通过AnnotatedGenericBeanDefinition去获得。</li>\n<li>2 判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。</li>\n<li>3 然后是解析作用域，如果没有设置的话，默认为单例。</li>\n<li>4 获得BeanName。</li>\n<li>5 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。</li>\n<li>6 限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。</li>\n<li>7 把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。</li>\n<li>8 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//beanClass= AppConfig.class</span><br><span class=\"line\">其它参数都是null</span><br><span class=\"line\">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class=\"line\">\t\t\t@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class=\"line\">\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class=\"line\">        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类</span><br><span class=\"line\">\t\t//转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解</span><br><span class=\"line\">\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class=\"line\">\t\t//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span><br><span class=\"line\">\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tabd.setInstanceSupplier(supplier);</span><br><span class=\"line\">\t\t//解析bean的作用域，如果没有设置的话，默认为单例</span><br><span class=\"line\">\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class=\"line\">\t\tabd.setScope(scopeMetadata.getScopeName());</span><br><span class=\"line\">\t\t//获得beanName</span><br><span class=\"line\">\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class=\"line\">\t\t//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description</span><br><span class=\"line\">\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class=\"line\">\t\t//限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种</span><br><span class=\"line\">\t\t//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，</span><br><span class=\"line\">\t\t//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span><br><span class=\"line\">\t\t//但是spring提供了其他方式去注册bean，就可能会传入了</span><br><span class=\"line\">\t\tif (qualifiers != null) &#123;</span><br><span class=\"line\">\t\t\t//可以传入qualifier数组，所以需要循环处理</span><br><span class=\"line\">\t\t\tfor (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//Primary注解优先</span><br><span class=\"line\">\t\t\t\tif (Primary.class == qualifier) &#123;</span><br><span class=\"line\">\t\t\t\t\tabd.setPrimary(true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t//Lazy注解</span><br><span class=\"line\">\t\t\t\telse if (Lazy.class == qualifier) &#123;</span><br><span class=\"line\">\t\t\t\t\tabd.setLazyInit(true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse &#123; //其他，AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier&gt;属性，直接push进去</span><br><span class=\"line\">\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (customizers != null) &#123;</span><br><span class=\"line\">\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class=\"line\">\t\t\t\tcustomizer.customize(abd);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中</span><br><span class=\"line\">\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class=\"line\">\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class=\"line\">\t\t//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，</span><br><span class=\"line\">\t\t//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span><br><span class=\"line\">\t\t//beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName</span><br><span class=\"line\">\t\t//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span><br><span class=\"line\">\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>AnnotatedGenericBeanDefinition<br>类注解初始化<br><img src=\"/2020/08/09/Spring-Bean-生命周期/AnnotatedGenericBeanDefinition.png\" alt=\"AnnotatedGenericBeanDefinition类图\"></li>\n</ul>\n<h3 id=\"refresh\"><a href=\"#refresh\" class=\"headerlink\" title=\"refresh\"></a>refresh</h3><p>Spring容器创建之后，会调用它的refresh方法刷新Spring应用的上下文。</p>\n<h4 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh();\"></a>prepareRefresh();</h4><p>//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void prepareRefresh() &#123;</span><br><span class=\"line\">\t// Switch to active.</span><br><span class=\"line\">\tthis.startupDate = System.currentTimeMillis();</span><br><span class=\"line\">\tthis.closed.set(false);</span><br><span class=\"line\">\tthis.active.set(true);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tif (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.trace(&quot;Refreshing &quot; + this);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(&quot;Refreshing &quot; + getDisplayName());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 空方法</span><br><span class=\"line\">\tinitPropertySources();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 验证环境信息里一些必须存在的属性</span><br><span class=\"line\">\tgetEnvironment().validateRequiredProperties();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Store pre-refresh ApplicationListeners...</span><br><span class=\"line\">\tif (this.earlyApplicationListeners == null) &#123;</span><br><span class=\"line\">\t\tthis.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\t// Reset local application listeners to pre-refresh state.</span><br><span class=\"line\">\t\tthis.applicationListeners.clear();</span><br><span class=\"line\">\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Allow for the collection of early ApplicationEvents,</span><br><span class=\"line\">\t// to be published once the multicaster is available...</span><br><span class=\"line\">\tthis.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory\"><a href=\"#ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory\" class=\"headerlink\" title=\"ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\"></a>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</h4><p>获取AnnotationConfigApplicationContext 中<br>DefaultListableBeanFactory对象，DefaultListableBeanFactory是ConfigurableListableBeanFactory子类</p>\n<h4 id=\"prepareBeanFactory-beanFactory\"><a href=\"#prepareBeanFactory-beanFactory\" class=\"headerlink\" title=\"prepareBeanFactory(beanFactory);\"></a>prepareBeanFactory(beanFactory);</h4><p>配置这个工厂的标准环境，比如context的类加载器和post-processors后处理器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * 设置了一个类加载器</span><br><span class=\"line\">\t * 设置了bean表达式解析器</span><br><span class=\"line\">\t * 添加了属性编辑器的支持</span><br><span class=\"line\">\t * 添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t * 设置了一些忽略自动装配的接口</span><br><span class=\"line\">\t * 设置了一些允许自动装配的接口，并且进行了赋值操作</span><br><span class=\"line\">\t * 在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">\t\t// Tell the internal bean factory to use the context&apos;s class loader etc.</span><br><span class=\"line\">\t\t//设置类加载器</span><br><span class=\"line\">\t\tbeanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\">\t\t//设置bean表达式解析器</span><br><span class=\"line\">\t\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t//属性编辑器支持</span><br><span class=\"line\">\t\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t\t// Configure the bean factory with context callbacks.</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class=\"line\">\t\t//以下接口，忽略自动装配</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值</span><br><span class=\"line\">\t\t// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class=\"line\">\t\t// MessageSource registered (and found for autowiring) as a bean.</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t\t// Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class=\"line\">\t\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t\t// Set a temporary ClassLoader for type matching.</span><br><span class=\"line\">\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean</span><br><span class=\"line\">\t\t// 注册环境变量</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>ApplicationContextAwareProcessor<br>ApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor,用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性:</p>\n<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ResourceLoaderAware</li>\n<li>ApplicationEventPublisherAware</li>\n<li>MessageSourceAware</li>\n<li>ApplicationContextAware<br>ApplicationContextAwareProcessor自己会被应用程序上下文自动注册到bean容器,不需要应用开发人员操心<br>后续内容会分析作用</li>\n</ul>\n</li>\n<li><p>ApplicationListenerDetector</p>\n<ul>\n<li><p>1、在Bean初始化完成之后：如果Bean是单例的则并且bean instanceof ApplicationListener。加入到this.applicationListeners中。</p>\n</li>\n<li><p>2、在Bean销毁之前搞事情： 如果Bean是一个ApplicationListener，则会从ApplicationEventMulticaster（事件广播器）中提前删除了<br>后续内容会分析作用</p>\n</li>\n</ul>\n</li>\n<li>LoadTimeWeaverAwareProcessor<br>增加对 AspectJ 的支持<br>后续说到aop会详细说<h4 id=\"postProcessBeanFactory-beanFactory\"><a href=\"#postProcessBeanFactory-beanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory(beanFactory);\"></a>postProcessBeanFactory(beanFactory);</h4>空方法<h4 id=\"invokeBeanFactoryPostProcessors-beanFactory\"><a href=\"#invokeBeanFactoryPostProcessors-beanFactory\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors(beanFactory);\"></a>invokeBeanFactoryPostProcessors(beanFactory);</h4>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">\t\t//spring允许我们手动添加BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);</span><br><span class=\"line\">\t\t//getBeanFactoryPostProcessors() 在外部可以手动添加一个后置处理器，而不是交给Spring去扫描</span><br><span class=\"line\">\t\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class=\"line\">\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class=\"line\">\t\tif (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法\"><a href=\"#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法\" class=\"headerlink\" title=\"PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法\"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法</h5><p>先介绍两个接口：</p>\n<ul>\n<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>\n<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>\n</ul>\n<p>过程：</p>\n<ul>\n<li><p>beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</p>\n<ul>\n<li>1 定义了一个Set（processedBeans），装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。</li>\n<li><p>2 定义了两个List，</p>\n<ul>\n<li>一个是regularPostProcessors，用来装载BeanFactoryPostProcessor</li>\n</ul>\n<ul>\n<li>一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。</li>\n</ul>\n</li>\n<li><p>3 循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。</p>\n</li>\n<li><p>4 定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。</p>\n</li>\n<li><p>5 getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。</p>\n</li>\n<li><p>6 循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，</p>\n<ul>\n<li>判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了(当然现在还没有处理，但是马上就要处理了)</li>\n</ul>\n</li>\n<li>7 进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>\n<li>8 把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>\n<li>9 可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。</li>\n<li>10 清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。</li>\n<li>11 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。</li>\n<li>12 处理排序。</li>\n<li>13 合并Processors，合并的理由和上面是一样的。</li>\n<li>14 执行我们自定义的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>\n<li>15 清空临时变量。</li>\n<li>16 在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>\n<li>17 regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的postProcessBeanFactory方法</li>\n<li>18 regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</li>\n<li>19 查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//beanFactory=DefaultListableBeanFactory</span><br><span class=\"line\">//beanFactoryPostProcessors 没有添加 所以size=0</span><br><span class=\"line\">public static void invokeBeanFactoryPostProcessors(</span><br><span class=\"line\">\t\t\tConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class=\"line\">\t\tSet&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class=\"line\">       //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</span><br><span class=\"line\">\t\tif (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class=\"line\">\t\t\t//regularPostProcessors 用来存放BeanFactoryPostProcessor，</span><br><span class=\"line\">\t\t\tList&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t\t//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor,BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据</span><br><span class=\"line\">\t\t\t因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的</span><br><span class=\"line\">\t\t\t只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class=\"line\">\t\t\t/* 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t\t 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t\t是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class=\"line\">\t\t\t\t\tBeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class=\"line\">\t\t\t\t\t\t\t(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class=\"line\">\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class=\"line\">\t\t\t\t\tregistryProcessors.add(registryProcessor);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\t\tregularPostProcessors.add(postProcessor);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">\t\t\t// uninitialized to let the bean factory post-processors apply to them!</span><br><span class=\"line\">\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class=\"line\">\t\t\t// PriorityOrdered, Ordered, and the rest.</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t/* 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class=\"line\">\t\t\t 对象是：ConfigurationClassPostProcessor</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tString[] postProcessorNames =</span><br><span class=\"line\">\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">\t\t\t\t\t/*</span><br><span class=\"line\">\t\t\t\t\t获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors</span><br><span class=\"line\">\t\t\t\t\tConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口</span><br><span class=\"line\">\t\t\t\t\tBeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口</span><br><span class=\"line\">\t\t\t\t\tConfigurationClassPostProcessor是极其重要的类</span><br><span class=\"line\">\t\t\t\t\t里面执行了扫描Bean，Import，ImportResouce等各种操作</span><br><span class=\"line\">\t\t\t\t\t用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑</span><br><span class=\"line\">\t\t\t\t\t */</span><br><span class=\"line\">\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\t//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了</span><br><span class=\"line\">\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//处理排序</span><br><span class=\"line\">\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t/* 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span><br><span class=\"line\">\t\t\t一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法</span><br><span class=\"line\">\t\t\t而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法</span><br><span class=\"line\">\t\t\t所以这里需要把处理器放入一个集合中，后续统一执行父类的方法</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t/*可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法</span><br><span class=\"line\">\t\t\tSpring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理</span><br><span class=\"line\">\t\t\t如果不想用这个组件，直接把注册组件的那一步去掉就可以</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t//因为currentRegistryProcessors是一个临时变量，所以需要清除</span><br><span class=\"line\">\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class=\"line\">\t\t\t// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span><br><span class=\"line\">\t\t\t// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span><br><span class=\"line\">\t\t\t// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理</span><br><span class=\"line\">\t\t\t// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span><br><span class=\"line\">\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//处理排序</span><br><span class=\"line\">\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t//合并Processors</span><br><span class=\"line\">\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t//执行我们自定义的BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t//清空临时变量</span><br><span class=\"line\">\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span><br><span class=\"line\">\t\t\t// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class=\"line\">\t\t\tboolean reiterate = true;</span><br><span class=\"line\">\t\t\twhile (reiterate) &#123;</span><br><span class=\"line\">\t\t\t\treiterate = false;</span><br><span class=\"line\">\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (!processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t\t\treiterate = true;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class=\"line\">\t\t\t//registryProcessors集合装载BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span><br><span class=\"line\">\t\t\t//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\t// Invoke factory processors registered with the context instance.</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">\t\t// uninitialized to let the bean factory post-processors apply to them!</span><br><span class=\"line\">\t\t//找到BeanFactoryPostProcessor实现类的BeanName数组</span><br><span class=\"line\">\t\tString[] postProcessorNames =</span><br><span class=\"line\">\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class=\"line\">\t\t// Ordered, and the rest.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tList&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tList&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t//循环BeanName数组</span><br><span class=\"line\">\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t//如果这个Bean被执行过了，跳过</span><br><span class=\"line\">\t\t\tif (processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">\t\t\t\t// skip - already processed in first phase above</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors</span><br><span class=\"line\">\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//如果实现了Ordered接口，加入到orderedPostProcessorNames</span><br><span class=\"line\">\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">\t\t\t\torderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\t//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames</span><br><span class=\"line\">\t\t\t\tnonOrderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class=\"line\">\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t//执行priorityOrderedPostProcessors</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//执行实现了Ordered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class=\"line\">\t\tfor (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class=\"line\">\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class=\"line\">\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class=\"line\">\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Clear cached merged bean definitions since the post-processors might have</span><br><span class=\"line\">\t\t// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class=\"line\">\t\tbeanFactory.clearMetadataCache();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"#ConfigurationClassPostProcessor\">ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</a></p>\n<h4 id=\"registerBeanPostProcessors-beanFactory\"><a href=\"#registerBeanPostProcessors-beanFactory\" class=\"headerlink\" title=\"registerBeanPostProcessors(beanFactory);\"></a>registerBeanPostProcessors(beanFactory);</h4><h4 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource();\"></a>initMessageSource();</h4><h4 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster();\"></a>initApplicationEventMulticaster();</h4><h4 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh();\"></a>onRefresh();</h4><h4 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners();\"></a>registerListeners();</h4><h4 id=\"finishBeanFactoryInitialization-beanFactory\"><a href=\"#finishBeanFactoryInitialization-beanFactory\" class=\"headerlink\" title=\"finishBeanFactoryInitialization(beanFactory);\"></a>finishBeanFactoryInitialization(beanFactory);</h4><h4 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh();\"></a>finishRefresh();</h4><h2 id=\"循环依赖\"><a href=\"#循环依赖\" class=\"headerlink\" title=\"循环依赖\"></a>循环依赖</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ul>\n<li>spring 如何产生Bean</li>\n<li>@Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li>\n<li>Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li>\n<li>Spring什么时候解析了@Import注解，如何解析的？</li>\n<li>Spring什么时候解析了@Bean注解？</li>\n</ul>\n<h1 id=\"如何产生bean\"><a href=\"#如何产生bean\" class=\"headerlink\" title=\"如何产生bean\"></a>如何产生bean</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"/2020/08/07/spring源码编译/#新建Model\">如何在spring源码中新建model及创建上面的代码</a><br><a href=\"/2020/08/08/spring源码（一）/#ApplicationContext\">关于ApplicationContext</a><br><a href=\"https://www.processon.com/view/link/5f3bce04f346fb06decb7923\" target=\"_blank\" rel=\"noopener\">spring实例化过程.png</a><br>以上代码：</p>\n<ul>\n<li>从一个Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。</li>\n<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>\n<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>\n</ul>\n<h1 id=\"启动过程分析\"><a href=\"#启动过程分析\" class=\"headerlink\" title=\"启动过程分析\"></a>启动过程分析</h1><p>记住，一定要在电脑中打开源码，不然纯看是很累的。<br><a href=\"https://github.com/smallwenzi/springframeworkcode\" target=\"_blank\" rel=\"noopener\">spring源码注释</a><br>分支是springcode</p>\n<p>Spring bean 默认是单例<br>为了弄清楚Bean是怎么来的，花费了大把功夫，现在要把Bean Definition的加载、解析、处理、注册到bean工厂的过程记下来</p>\n<ul>\n<li>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);<br><a href=\"#AnnotationConfigApplicationContext构造方法\">实例化AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses</a><ul>\n<li>this()<ul>\n<li><a href=\"#GenericApplicationContext-构造方法\">调用父类GenericApplicationContext的构造函数</a><ul>\n<li>this.beanFactory = new DefaultListableBeanFactory();<br><a href=\"#DefaultListableBeanFactory-构造方法\">实例化DefaultListableBeanFactory</a></li>\n</ul>\n</li>\n<li>this.reader = new AnnotatedBeanDefinitionReader(this);<br><a href=\"#初始化一个Bean读取器AnnotatedBeanDefinitionReader\">实例化AnnotatedBeanDefinitionReader</a><ul>\n<li><a href=\"#AnnotationConfigUtils-registerAnnotationConfigProcessors\">registerAnnotationConfigProcessors方法负责向容器里面注册相关的类</a></li>\n</ul>\n</li>\n<li>this.scanner = new ClassPathBeanDefinitionScanner(this);<br>初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>\n</ul>\n</li>\n<li><a href=\"#register-componentClasses\">register(componentClasses);</a><ul>\n<li><a href=\"#AnnotatedBeanDefinitionReader-类register-方法\">AnnotatedBeanDefinitionReader 类register 方法</a><ul>\n<li><a href=\"#AnnotatedBeanDefinitionReader的方法doRegisterBean\">AnnotatedBeanDefinitionReader的方法doRegisterBean</a> 把appconfig注册至bean容器中但是未实例化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#refresh\">refresh();</a><ul>\n<li>prepareRefresh();<br>刷新前的预处理;</li>\n<li>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的</li>\n<li>prepareBeanFactory(beanFactory);<br>BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器，BeanPostProcessor和XXXAware自动装配等）</li>\n<li>postProcessBeanFactory(beanFactory);<br>BeanFactory准备工作完成后进行的后置处理工作</li>\n<li>invokeBeanFactoryPostProcessors(beanFactory);<br>执行BeanFactoryPostProcessor的方法；</li>\n<li>registerBeanPostProcessors(beanFactory);<br>注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行</li>\n<li>initMessageSource();<br>初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</li>\n<li>initApplicationEventMulticaster();<br>初始化事件派发器</li>\n<li>onRefresh();<br>子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器</li>\n<li>registerListeners();<br>注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的</li>\n<li>finishBeanFactoryInitialization(beanFactory);<br>初始化所有剩下的非懒加载的单例bean</li>\n<li>finishRefresh();<br>完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AnnotationConfigApplicationContext构造方法\"><a href=\"#AnnotationConfigApplicationContext构造方法\" class=\"headerlink\" title=\"AnnotationConfigApplicationContext构造方法\"></a>AnnotationConfigApplicationContext构造方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final AnnotatedBeanDefinitionReader reader;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final ClassPathBeanDefinitionScanner scanner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">    这句代码调用以下方法</span><br><span class=\"line\">   根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少</span><br><span class=\"line\">  */</span><br><span class=\"line\">\tpublic AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) &#123;</span><br><span class=\"line\">     //详细看AnnotationConfigApplicationContext 无参构造</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tregister(componentClasses);</span><br><span class=\"line\">\t\trefresh();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   public AnnotationConfigApplicationContext() &#123;</span><br><span class=\"line\">    ////调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()</span><br><span class=\"line\">     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader</span><br><span class=\"line\">\t\tthis.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class=\"line\">        //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器</span><br><span class=\"line\">\t\tthis.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调用无参构造函数，会先调用父类GenericApplicationContext的构造函数<ul>\n<li>父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory<ul>\n<li>本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner</li>\n</ul>\n</li>\n<li>scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>\n</ul>\n</li>\n<li></li>\n<li></li>\n</ul>\n<h3 id=\"GenericApplicationContext-构造方法\"><a href=\"#GenericApplicationContext-构造方法\" class=\"headerlink\" title=\"GenericApplicationContext 构造方法\"></a>GenericApplicationContext 构造方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry &#123;</span><br><span class=\"line\"> \tprivate final DefaultListableBeanFactory beanFactory;</span><br><span class=\"line\">    public GenericApplicationContext() &#123;</span><br><span class=\"line\">    //初始化一个BeanFactory</span><br><span class=\"line\">\t\tthis.beanFactory = new DefaultListableBeanFactory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DefaultListableBeanFactory-构造方法\"><a href=\"#DefaultListableBeanFactory-构造方法\" class=\"headerlink\" title=\"DefaultListableBeanFactory 构造方法\"></a>DefaultListableBeanFactory 构造方法</h4><p>默认实现了ListableBeanFactory和BeanDefinitionRegistry接口，基于bean definition对象，是一个成熟的bean factroy。</p>\n<p>最典型的应用是：在访问bean前，先注册所有的definition（可能从bean definition配置文件中）。使用预先建立的bean定义元数据对象，从本地的bean definition表中查询bean definition因而将不会花费太多成本。</p>\n<p>DefaultListableBeanFactory既可以作为一个单独的beanFactory，也可以作为自定义beanFactory的父类。<br><img src=\"/2020/08/09/Spring-Bean-生命周期/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory</span><br><span class=\"line\">        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class=\"line\">        //存储BeanDefinition对象</span><br><span class=\"line\">\tprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t/** 存储 spring bean 单例对象  */</span><br><span class=\"line\">\tprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Create a new DefaultListableBeanFactory.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic DefaultListableBeanFactory() &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"AbstractAutowireCapableBeanFactory构造方法\"><a href=\"#AbstractAutowireCapableBeanFactory构造方法\" class=\"headerlink\" title=\"AbstractAutowireCapableBeanFactory构造方法\"></a>AbstractAutowireCapableBeanFactory构造方法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AbstractAutowireCapableBeanFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">super();</span><br><span class=\"line\">   //自动装配时忽略指定接口或类的依赖注入</span><br><span class=\"line\">\tignoreDependencyInterface(BeanNameAware.class);</span><br><span class=\"line\">\tignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class=\"line\">\tignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"AbstractBeanFactory\"><a href=\"#AbstractBeanFactory\" class=\"headerlink\" title=\"AbstractBeanFactory\"></a>AbstractBeanFactory</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * Create a new AbstractBeanFactory.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic AbstractBeanFactory() &#123;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化一个Bean读取器AnnotatedBeanDefinitionReader\"><a href=\"#初始化一个Bean读取器AnnotatedBeanDefinitionReader\" class=\"headerlink\" title=\"//初始化一个Bean读取器AnnotatedBeanDefinitionReader\"></a>//初始化一个Bean读取器AnnotatedBeanDefinitionReader</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.reader = new AnnotatedBeanDefinitionReader(this);</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader构造方法\"><a href=\"#AnnotatedBeanDefinitionReader构造方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader构造方法\"></a>AnnotatedBeanDefinitionReader构造方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t//这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了</span><br><span class=\"line\">\tthis(registry, getOrCreateEnvironment(registry));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AnnotatedBeanDefinitionReader 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AnnotatedBeanDefinitionReader (BeanDefinitionRegistry registry, Environment environment) &#123;</span><br><span class=\"line\">\tAssert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class=\"line\">\tAssert.notNull(environment, &quot;Environment must not be null&quot;);</span><br><span class=\"line\">\tthis.registry = registry;</span><br><span class=\"line\">\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);</span><br><span class=\"line\">\t//让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：</span><br><span class=\"line\">this.registry 是    AnnotationConfigApplicationContext的实例了   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"AnnotationConfigUtils-registerAnnotationConfigProcessors\"><a href=\"#AnnotationConfigUtils-registerAnnotationConfigProcessors\" class=\"headerlink\" title=\"AnnotationConfigUtils.registerAnnotationConfigProcessors\"></a>AnnotationConfigUtils.registerAnnotationConfigProcessors</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tregisterAnnotationConfigProcessors(registry, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在看registerAnnotationConfigProcessors方法</p>\n<ul>\n<li>这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。<pre><code>* ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，\n* BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，\n* BeanFactoryPostProcessor是Spring的扩展点之一，\n*  ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。\n* 除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。\n* BeanPostProcessor接口也是Spring的扩展点之一。\n</code></pre></li>\n</ul>\n<p>执行完方法<br>beanDefs 有5个</p>\n<ul>\n<li>ConfigurationClassPostProcessor</li>\n<li>AutowiredAnnotationBeanPostProcessor </li>\n<li>CommonAnnotationBeanPostProcessor</li>\n<li>EventListenerMethodProcessor</li>\n<li>DefaultEventListenerFactory<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// this.registry 是    AnnotationConfigApplicationContext的实例了   </span><br><span class=\"line\">source=null</span><br><span class=\"line\">\tpublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class=\"line\">           //这里返回AnnotationConfigApplicationContext对象中DefaultListableBeanFactory类实例</span><br><span class=\"line\">\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class=\"line\">BeanDefinition\t\tif (beanFactory != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class=\"line\">\t\t\t\t//用来支持Spring的Ordered类、@Order注解和@Priority注解。</span><br><span class=\"line\">                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class=\"line\">\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t\t * 注册解析我们配置类的后置处理器ConfigurationClassPostProcessor</span><br><span class=\"line\">\t\t * org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\t//如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t *</span><br><span class=\"line\">\t\t org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t * org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br><span class=\"line\">\t\tif (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><br><span class=\"line\">\t\tif (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition();</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class=\"line\">\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t\t\t&quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 处理监听方法的注解解析器EventListenerMethodProcessor</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 注册事件监听器工厂</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class=\"line\">\t\t\tdef.setSource(source);</span><br><span class=\"line\">\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn beanDefs;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"ConfigurationClassPostProcessor\"><a href=\"#ConfigurationClassPostProcessor\" class=\"headerlink\" title=\"ConfigurationClassPostProcessor\"></a>ConfigurationClassPostProcessor</h5><p><img src=\"/2020/08/09/Spring-Bean-生命周期/ConfigurationClassPostProcessor.png\" alt=\"ConfigurationClassPostProcessor类图\"></p>\n<pre><code>* ConfigurationClassPostProcessor是一个BeanFactory的后置处理器，因此它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。\n* ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。\n* ConfigurationClassPostProcessor这个类是Spring内置的一个BeanFactory后置处理器，是在this()方法中将其添加到BeanDefinitionMap中的\n* [postProcessBeanDefinitionRegistry](#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法中)调用\n</code></pre>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  registry是DefaultListableBeanFactory对象</span><br><span class=\"line\">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tint registryId = System.identityHashCode(registry);</span><br><span class=\"line\">\tif (this.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class=\"line\">\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (this.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class=\"line\">\t\tthrow new IllegalStateException(</span><br><span class=\"line\">\t\t\t\t&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.registriesPostProcessed.add(registryId);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprocessConfigBeanDefinitions(registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>processConfigBeanDefinitions 方法 </p>\n<ul>\n<li>从Beanfactory找出含有Configuration 或Component或ComponentScan或Import或ImportResource类 目前只有appconfig类符合</li>\n<li><p>ConfigurationClassParser.parse（）<br>解析appconfig（AnnotatedGenericBeanDefinition 定义）</p>\n<ul>\n<li><p>1 处理内部类</p>\n<ul>\n<li><p>2 处理@PropertySources注解：进行一些配置信息的解析</p>\n</li>\n<li><p>3 处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</p>\n</li>\n<li><p>4 处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：</p>\n<ul>\n<li><p>遍历这些@Import注解内部的属性类集合</p>\n</li>\n<li><p>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第7步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</p>\n</li>\n<li><p>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</p>\n</li>\n<li><p>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>5 处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</p>\n</li>\n<li><p>6 处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</p>\n</li>\n<li><p>7 处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\tList&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t/* 获得所有的BeanDefinition的Name，放入candidateNames数组</span><br><span class=\"line\">\t目前6个：</span><br><span class=\"line\">\tConfigurationClassPostProcessor</span><br><span class=\"line\">\tAutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">\tCommonAnnotationBeanPostProcessor</span><br><span class=\"line\">\tEventListenerMethodProcessor</span><br><span class=\"line\">\tDefaultEventListenerFactory</span><br><span class=\"line\">\tappconfig</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tString[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class=\"line\">        //循环candidateNames数组</span><br><span class=\"line\">\tfor (String beanName : candidateNames) &#123;</span><br><span class=\"line\">\t\t//根据beanName获得BeanDefinition</span><br><span class=\"line\">\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class=\"line\">\t\t/*  内部有两个标记位来标记是否已经处理过了</span><br><span class=\"line\">\t\t 这里会引发一连串知识盲点</span><br><span class=\"line\">\t\t当我们注册配置类的时候，可以不加Configuration注解，</span><br><span class=\"line\">\t\t直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类</span><br><span class=\"line\">\t\t如果加了Configuration注解，就称之为Full配置类</span><br><span class=\"line\">\t\t 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类</span><br><span class=\"line\">\t\t如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了</span><br><span class=\"line\">\t\t 写一个A类，其中有一个构造方法，打印出“你好”</span><br><span class=\"line\">\t\t 再写一个配置类，里面有两个bean注解的方法</span><br><span class=\"line\">\t\t 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA</span><br><span class=\"line\">\t\t 第二个方法又调用了getA方法</span><br><span class=\"line\">\t\t 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次</span><br><span class=\"line\">\t\t 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tif (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123;</span><br><span class=\"line\">\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\tlogger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/* 判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），</span><br><span class=\"line\">\t\t在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记</span><br><span class=\"line\">\t\t满足条件，加入到configCandidates */</span><br><span class=\"line\">\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class=\"line\">\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">       // 如果没有配置类，直接返回</span><br><span class=\"line\">\t// Return immediately if no @Configuration classes were found</span><br><span class=\"line\">\tif (configCandidates.isEmpty()) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">       //处理排序</span><br><span class=\"line\">\t// Sort by previously determined @Order value, if applicable</span><br><span class=\"line\">\tconfigCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class=\"line\">\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class=\"line\">\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class=\"line\">\t\treturn Integer.compare(i1, i2);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Detect any custom bean name generation strategy supplied through the enclosing application context</span><br><span class=\"line\">\tSingletonBeanRegistry sbr = null;</span><br><span class=\"line\">\t// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if</span><br><span class=\"line\">\tif (registry instanceof SingletonBeanRegistry) &#123;</span><br><span class=\"line\">\t\tsbr = (SingletonBeanRegistry) registry;</span><br><span class=\"line\">\t\tif (!this.localBeanNameGeneratorSet) &#123;</span><br><span class=\"line\">\t\t\t//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做</span><br><span class=\"line\">\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class=\"line\">\t\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class=\"line\">\t\t\tif (generator != null) &#123;</span><br><span class=\"line\">\t\t\t\tthis.componentScanBeanNameGenerator = generator;</span><br><span class=\"line\">\t\t\t\tthis.importBeanNameGenerator = generator;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.environment == null) &#123;</span><br><span class=\"line\">\t\tthis.environment = new StandardEnvironment();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Parse each @Configuration class</span><br><span class=\"line\">\tConfigurationClassParser parser = new ConfigurationClassParser(</span><br><span class=\"line\">\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,</span><br><span class=\"line\">\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSet&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class=\"line\">\tSet&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());</span><br><span class=\"line\">\tdo &#123;</span><br><span class=\"line\">\t\t//解析配置类（传统意义上的配置类或者是普通bean，核心来了） candidates 仅appConfig类</span><br><span class=\"line\">\t\tparser.parse(candidates);</span><br><span class=\"line\">\t\tparser.validate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class=\"line\">\t\tconfigClasses.removeAll(alreadyParsed);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Read the model and create bean definitions based on its content</span><br><span class=\"line\">\t\tif (this.reader == null) &#123;</span><br><span class=\"line\">\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(</span><br><span class=\"line\">\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,</span><br><span class=\"line\">\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition</span><br><span class=\"line\">\t\tthis.reader.loadBeanDefinitions(configClasses);</span><br><span class=\"line\">\t\t//把configClasses加入到alreadyParsed，代表</span><br><span class=\"line\">\t\talreadyParsed.addAll(configClasses);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcandidates.clear();</span><br><span class=\"line\">\t\t//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较</span><br><span class=\"line\">\t\t//如果大于的话，说明有新的BeanDefinition注册进来了</span><br><span class=\"line\">\t\tif (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class=\"line\">\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class=\"line\">\t\t\tSet&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class=\"line\">\t\t\tSet&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t\t//循环alreadyParsed。把类名加入到alreadyParsedClasses</span><br><span class=\"line\">\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class=\"line\">\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (String candidateName : newCandidateNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class=\"line\">\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class=\"line\">\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcandidateNames = newCandidateNames;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (!candidates.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><br><span class=\"line\">\tif (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;</span><br><span class=\"line\">\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span><br><span class=\"line\">\t\t// for a shared cache since it&apos;ll be cleared by the ApplicationContext.</span><br><span class=\"line\">\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ConfigurationClassParser.parse方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;</span><br><span class=\"line\">\t//循环传进来的配置类</span><br><span class=\"line\">\tfor (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class=\"line\">\t\tBeanDefinition bd = holder.getBeanDefinition();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t//如果获得BeanDefinition是AnnotatedBeanDefinition的实例</span><br><span class=\"line\">\t\t\tif (bd instanceof AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">\t\t\t\tparse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class=\"line\">\t\t\t\tparse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\tparse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">\t\t\tthrow ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Throwable ex) &#123;</span><br><span class=\"line\">\t\t\tthrow new BeanDefinitionStoreException(</span><br><span class=\"line\">\t\t\t\t\t&quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//执行DeferredImportSelector</span><br><span class=\"line\">\tthis.deferredImportSelectorHandler.process();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   \tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException &#123;</span><br><span class=\"line\">\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123;</span><br><span class=\"line\">\t//判断是否需要跳过</span><br><span class=\"line\">\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tConfigurationClass existingClass = this.configurationClasses.get(configClass);</span><br><span class=\"line\">\tif (existingClass != null) &#123;</span><br><span class=\"line\">\t\tif (configClass.isImported()) &#123;</span><br><span class=\"line\">\t\t\tif (existingClass.isImported()) &#123;</span><br><span class=\"line\">\t\t\t\texistingClass.mergeImportedBy(configClass);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\t// Explicit bean definition found, probably replacing an import.</span><br><span class=\"line\">\t\t\t// Let&apos;s remove the old one and go with the new one.</span><br><span class=\"line\">\t\t\tthis.configurationClasses.remove(configClass);</span><br><span class=\"line\">\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Recursively process the configuration class and its superclass hierarchy.</span><br><span class=\"line\">\tSourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class=\"line\">\tdo &#123;</span><br><span class=\"line\">\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (sourceClass != null);</span><br><span class=\"line\"></span><br><span class=\"line\">\tthis.configurationClasses.put(configClass, configClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Apply processing and build a complete &#123;@link ConfigurationClass&#125; by reading the</span><br><span class=\"line\"> * annotations, members and methods from the source class. This method can be called</span><br><span class=\"line\"> * multiple times as relevant sources are discovered.</span><br><span class=\"line\"> * @param configClass the configuration class being build</span><br><span class=\"line\"> * @param sourceClass a source class</span><br><span class=\"line\"> * @return the superclass, or &#123;@code null&#125; if none found or previously processed</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected final SourceClass doProcessConfigurationClass(</span><br><span class=\"line\">\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span><br><span class=\"line\">\t\tthrows IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class=\"line\">\t\t// Recursively process any member (nested) classes first</span><br><span class=\"line\">\t\t//递归处理内部类，一般不会写内部类</span><br><span class=\"line\">\t\tprocessMemberClasses(configClass, sourceClass, filter);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @PropertySource annotations</span><br><span class=\"line\">\t//处理@PropertySource注解，@PropertySource注解用来加载properties文件</span><br><span class=\"line\">\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class=\"line\">\t\t\tsourceClass.getMetadata(), PropertySources.class,</span><br><span class=\"line\">\t\t\torg.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class=\"line\">\t\tif (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class=\"line\">\t\t\tprocessPropertySource(propertySource);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tlogger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class=\"line\">\t\t\t\t\t&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @ComponentScan annotations</span><br><span class=\"line\">\t//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等</span><br><span class=\"line\">\tSet&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class=\"line\">\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class=\"line\">\t//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if</span><br><span class=\"line\">\tif (!componentScans.isEmpty() &amp;&amp;</span><br><span class=\"line\">\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class=\"line\">\t\t//循环处理componentScans</span><br><span class=\"line\">\t\tfor (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class=\"line\">\t\t\t// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class=\"line\">\t\t\t//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称</span><br><span class=\"line\">\t\t\tSet&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class=\"line\">\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class=\"line\">\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class=\"line\">\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class=\"line\">\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class=\"line\">\t\t\t\tif (bdCand == null) &#123;</span><br><span class=\"line\">\t\t\t\t\tbdCand = holder.getBeanDefinition();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class=\"line\">\t\t\t\t\t//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解</span><br><span class=\"line\">\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//处理@Import注解</span><br><span class=\"line\">\t//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解</span><br><span class=\"line\">\t//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar</span><br><span class=\"line\">\t//getImports(sourceClass)是获得import的内容，返回的是一个set</span><br><span class=\"line\">\t// Process any @Import annotations</span><br><span class=\"line\">\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process any @ImportResource annotations</span><br><span class=\"line\">\t//处理@ImportResource注解</span><br><span class=\"line\">\tAnnotationAttributes importResource =</span><br><span class=\"line\">\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class=\"line\">\tif (importResource != null) &#123;</span><br><span class=\"line\">\t\tString[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class=\"line\">\t\tClass&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class=\"line\">\t\tfor (String resource : resources) &#123;</span><br><span class=\"line\">\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class=\"line\">\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收</span><br><span class=\"line\">\t// Process individual @Bean methods</span><br><span class=\"line\">\tSet&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class=\"line\">\tfor (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class=\"line\">\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process default methods on interfaces</span><br><span class=\"line\">\tprocessInterfaces(configClass, sourceClass);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Process superclass, if any</span><br><span class=\"line\">\tif (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class=\"line\">\t\tString superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class=\"line\">\t\tif (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class=\"line\">\t\t\tthis.knownSuperclasses.put(superclass, configClass);</span><br><span class=\"line\">\t\t\t// Superclass found, return its annotation metadata and recurse</span><br><span class=\"line\">\t\t\treturn sourceClass.getSuperClass();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// No superclass -&gt; processing is complete</span><br><span class=\"line\">\treturn null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"AutowiredAnnotationBeanPostProcessor\"><a href=\"#AutowiredAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"AutowiredAnnotationBeanPostProcessor\"></a>AutowiredAnnotationBeanPostProcessor</h5><p> <img src=\"/2020/08/09/Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png\" alt=\"AutowiredAnnotationBeanPostProcessor类图\"></p>\n<pre><code> * AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有@Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。  \n*  关于作用后续内容会说到\n</code></pre><h5 id=\"CommonAnnotationBeanPostProcessor\"><a href=\"#CommonAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"CommonAnnotationBeanPostProcessor\"></a>CommonAnnotationBeanPostProcessor</h5><p>  <img src=\"/2020/08/09/Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png\" alt=\"CommonAnnotationBeanPostProcessor图\"></p>\n<pre><code>* CommonAnnotationBeanPostProcessor类在spring中是一个极其重要的类，它负责解析@Resource、@WebServiceRef、@EJB三个注解。这三个注解都是定义在javax.*包下的注解，属于java中的注解\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"PersistenceAnnotationBeanPostProcessor\"><a href=\"#PersistenceAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"PersistenceAnnotationBeanPostProcessor\"></a>PersistenceAnnotationBeanPostProcessor</h5><p>   <img src=\"/2020/08/09/Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png\" alt=\"PersistenceAnnotationBeanPostProcessor图\"></p>\n<pre><code> * PersistenceAnnotationBeanPostProcessor是Spring提供的用于处理注解@PersistenceUnit和@PersistenceContext的BeanPostProcessor。用于注入相应的JPA资源:EntityManagerFactory和EntityManager (或者它们的子类变量)。\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"EventListenerMethodProcessor\"><a href=\"#EventListenerMethodProcessor\" class=\"headerlink\" title=\"EventListenerMethodProcessor\"></a>EventListenerMethodProcessor</h5><pre><code>![EventListenerMethodProcessor图](Spring-Bean-生命周期/EventListenerMethodProcessor.png)\n * EventListenerMethodProcessor 是 Spring 事件机制中非常重要的一个组件。它管理了一组EventListenerFactory组件,用来将应用中每个使用@EventListener注解定义的事件监听方法变成一个ApplicationListener实例注册到容器。换句话讲，框架开发者，或者应用开发者使用注解@EventListener定义的事件处理方法，如果没有EventListenerMethodProcessor的发现和注册，是不会被容器看到和使用的。\n* 关于作用后续内容会说到\n</code></pre><h5 id=\"DefaultEventListenerFactory\"><a href=\"#DefaultEventListenerFactory\" class=\"headerlink\" title=\"DefaultEventListenerFactory\"></a>DefaultEventListenerFactory</h5><pre><code>![DefaultEventListenerFactory图](Spring-Bean-生命周期/DefaultEventListenerFactory.png)\n * 监听器工厂\n* 关于作用后续内容会说到\n</code></pre><h4 id=\"registerPostProcessor-方法\"><a href=\"#registerPostProcessor-方法\" class=\"headerlink\" title=\"registerPostProcessor 方法\"></a>registerPostProcessor 方法</h4><p>registerPostProcessor方法内部就是注册Bean，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static BeanDefinitionHolder registerPostProcessor(</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) &#123;</span><br><span class=\"line\">\t    //为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的</span><br><span class=\"line\">\t\tdefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class=\"line\">\t\t//BeanDefinitionRegistry是接口，实现类：AnnotationConfigApplicationContext 实现方法位于：GenericApplicationContext</span><br><span class=\"line\">\t\t//方法实现this.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tregistry.registerBeanDefinition(beanName, definition);</span><br><span class=\"line\">\t\treturn new BeanDefinitionHolder(definition, beanName);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>RootBeanDefinition 是BeanDefinition接口子类<br>BeanDefinition是什么，顾名思义，它是用来描述Bean的，<ul>\n<li>里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，</li>\n<li>是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/09/Spring-Bean-生命周期/RootBeanDefinition.png\" alt=\"RootBeanDefinition类图\"></p>\n<p>至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。</p>\n<h3 id=\"初始化扫描器\"><a href=\"#初始化扫描器\" class=\"headerlink\" title=\"初始化扫描器\"></a>初始化扫描器</h3><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p>\n<h3 id=\"register-componentClasses\"><a href=\"#register-componentClasses\" class=\"headerlink\" title=\"register(componentClasses);\"></a>register(componentClasses);</h3><ul>\n<li>把传入的类进行注册，这里有两个情况，</li>\n<li>传入传统的配置类</li>\n<li>传入bean（虽然一般没有人会这么做</li>\n<li>看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类</li>\n<li>但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">//componentClasses= AppConfig.class</span><br><span class=\"line\">public void register(Class&lt;?&gt;...componentClasses) &#123;</span><br><span class=\"line\">\t\tAssert.notEmpty(componentClasses, &quot;At least one component class must be specified&quot;);</span><br><span class=\"line\">       //AnnotatedBeanDefinitionReader 类对象</span><br><span class=\"line\">\t\tthis.reader.register(componentClasses);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader-类register-方法\"><a href=\"#AnnotatedBeanDefinitionReader-类register-方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader 类register 方法\"></a>AnnotatedBeanDefinitionReader 类register 方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//componentClasses= AppConfig.class</span><br><span class=\"line\">public void register (Class&lt;?&gt;... componentClasses) &#123;</span><br><span class=\"line\">\t\tfor (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class=\"line\">\t\t\tregisterBean(componentClass);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotatedBeanDefinitionReader-类-registerBean方法\"><a href=\"#AnnotatedBeanDefinitionReader-类-registerBean方法\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader 类 registerBean方法\"></a>AnnotatedBeanDefinitionReader 类 registerBean方法</h4><pre><code>public void registerBean(Class&lt;?&gt; beanClass) {\n    doRegisterBean(beanClass, null, null, null, null);\n}\n</code></pre><h4 id=\"AnnotatedBeanDefinitionReader的方法doRegisterBean\"><a href=\"#AnnotatedBeanDefinitionReader的方法doRegisterBean\" class=\"headerlink\" title=\"AnnotatedBeanDefinitionReader的方法doRegisterBean\"></a>AnnotatedBeanDefinitionReader的方法doRegisterBean</h4><ul>\n<li>1 通过AnnotatedGenericBeanDefinition的构造方法，<br>   获得配置类的BeanDefinition，这里是不是似曾相似，<br>   在注册ConfigurationClassPostProcessor类的时候，<br>   也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，<br>   现在是通过AnnotatedGenericBeanDefinition去获得。</li>\n<li>2 判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。</li>\n<li>3 然后是解析作用域，如果没有设置的话，默认为单例。</li>\n<li>4 获得BeanName。</li>\n<li>5 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。</li>\n<li>6 限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。</li>\n<li>7 把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。</li>\n<li>8 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//beanClass= AppConfig.class</span><br><span class=\"line\">其它参数都是null</span><br><span class=\"line\">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class=\"line\">\t\t\t@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class=\"line\">\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class=\"line\">        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类</span><br><span class=\"line\">\t\t//转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解</span><br><span class=\"line\">\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class=\"line\">\t\t//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span><br><span class=\"line\">\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tabd.setInstanceSupplier(supplier);</span><br><span class=\"line\">\t\t//解析bean的作用域，如果没有设置的话，默认为单例</span><br><span class=\"line\">\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class=\"line\">\t\tabd.setScope(scopeMetadata.getScopeName());</span><br><span class=\"line\">\t\t//获得beanName</span><br><span class=\"line\">\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class=\"line\">\t\t//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description</span><br><span class=\"line\">\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class=\"line\">\t\t//限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种</span><br><span class=\"line\">\t\t//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，</span><br><span class=\"line\">\t\t//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span><br><span class=\"line\">\t\t//但是spring提供了其他方式去注册bean，就可能会传入了</span><br><span class=\"line\">\t\tif (qualifiers != null) &#123;</span><br><span class=\"line\">\t\t\t//可以传入qualifier数组，所以需要循环处理</span><br><span class=\"line\">\t\t\tfor (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//Primary注解优先</span><br><span class=\"line\">\t\t\t\tif (Primary.class == qualifier) &#123;</span><br><span class=\"line\">\t\t\t\t\tabd.setPrimary(true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t//Lazy注解</span><br><span class=\"line\">\t\t\t\telse if (Lazy.class == qualifier) &#123;</span><br><span class=\"line\">\t\t\t\t\tabd.setLazyInit(true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse &#123; //其他，AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier&gt;属性，直接push进去</span><br><span class=\"line\">\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (customizers != null) &#123;</span><br><span class=\"line\">\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class=\"line\">\t\t\t\tcustomizer.customize(abd);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中</span><br><span class=\"line\">\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class=\"line\">\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class=\"line\">\t\t//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，</span><br><span class=\"line\">\t\t//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span><br><span class=\"line\">\t\t//beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName</span><br><span class=\"line\">\t\t//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span><br><span class=\"line\">\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>AnnotatedGenericBeanDefinition<br>类注解初始化<br><img src=\"/2020/08/09/Spring-Bean-生命周期/AnnotatedGenericBeanDefinition.png\" alt=\"AnnotatedGenericBeanDefinition类图\"></li>\n</ul>\n<h3 id=\"refresh\"><a href=\"#refresh\" class=\"headerlink\" title=\"refresh\"></a>refresh</h3><p>Spring容器创建之后，会调用它的refresh方法刷新Spring应用的上下文。</p>\n<h4 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh();\"></a>prepareRefresh();</h4><p>//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void prepareRefresh() &#123;</span><br><span class=\"line\">\t// Switch to active.</span><br><span class=\"line\">\tthis.startupDate = System.currentTimeMillis();</span><br><span class=\"line\">\tthis.closed.set(false);</span><br><span class=\"line\">\tthis.active.set(true);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tif (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.trace(&quot;Refreshing &quot; + this);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(&quot;Refreshing &quot; + getDisplayName());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 空方法</span><br><span class=\"line\">\tinitPropertySources();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 验证环境信息里一些必须存在的属性</span><br><span class=\"line\">\tgetEnvironment().validateRequiredProperties();</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Store pre-refresh ApplicationListeners...</span><br><span class=\"line\">\tif (this.earlyApplicationListeners == null) &#123;</span><br><span class=\"line\">\t\tthis.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\t// Reset local application listeners to pre-refresh state.</span><br><span class=\"line\">\t\tthis.applicationListeners.clear();</span><br><span class=\"line\">\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Allow for the collection of early ApplicationEvents,</span><br><span class=\"line\">\t// to be published once the multicaster is available...</span><br><span class=\"line\">\tthis.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory\"><a href=\"#ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory\" class=\"headerlink\" title=\"ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\"></a>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</h4><p>获取AnnotationConfigApplicationContext 中<br>DefaultListableBeanFactory对象，DefaultListableBeanFactory是ConfigurableListableBeanFactory子类</p>\n<h4 id=\"prepareBeanFactory-beanFactory\"><a href=\"#prepareBeanFactory-beanFactory\" class=\"headerlink\" title=\"prepareBeanFactory(beanFactory);\"></a>prepareBeanFactory(beanFactory);</h4><p>配置这个工厂的标准环境，比如context的类加载器和post-processors后处理器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * 设置了一个类加载器</span><br><span class=\"line\">\t * 设置了bean表达式解析器</span><br><span class=\"line\">\t * 添加了属性编辑器的支持</span><br><span class=\"line\">\t * 添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t * 设置了一些忽略自动装配的接口</span><br><span class=\"line\">\t * 设置了一些允许自动装配的接口，并且进行了赋值操作</span><br><span class=\"line\">\t * 在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">\t\t// Tell the internal bean factory to use the context&apos;s class loader etc.</span><br><span class=\"line\">\t\t//设置类加载器</span><br><span class=\"line\">\t\tbeanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\">\t\t//设置bean表达式解析器</span><br><span class=\"line\">\t\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t//属性编辑器支持</span><br><span class=\"line\">\t\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t\t// Configure the bean factory with context callbacks.</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class=\"line\">\t\t//以下接口，忽略自动装配</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">\t\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值</span><br><span class=\"line\">\t\t// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class=\"line\">\t\t// MessageSource registered (and found for autowiring) as a bean.</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class=\"line\">\t\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口</span><br><span class=\"line\">\t\t// Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class=\"line\">\t\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t\t// Set a temporary ClassLoader for type matching.</span><br><span class=\"line\">\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean</span><br><span class=\"line\">\t\t// 注册环境变量</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>ApplicationContextAwareProcessor<br>ApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor,用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性:</p>\n<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ResourceLoaderAware</li>\n<li>ApplicationEventPublisherAware</li>\n<li>MessageSourceAware</li>\n<li>ApplicationContextAware<br>ApplicationContextAwareProcessor自己会被应用程序上下文自动注册到bean容器,不需要应用开发人员操心<br>后续内容会分析作用</li>\n</ul>\n</li>\n<li><p>ApplicationListenerDetector</p>\n<ul>\n<li><p>1、在Bean初始化完成之后：如果Bean是单例的则并且bean instanceof ApplicationListener。加入到this.applicationListeners中。</p>\n</li>\n<li><p>2、在Bean销毁之前搞事情： 如果Bean是一个ApplicationListener，则会从ApplicationEventMulticaster（事件广播器）中提前删除了<br>后续内容会分析作用</p>\n</li>\n</ul>\n</li>\n<li>LoadTimeWeaverAwareProcessor<br>增加对 AspectJ 的支持<br>后续说到aop会详细说<h4 id=\"postProcessBeanFactory-beanFactory\"><a href=\"#postProcessBeanFactory-beanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory(beanFactory);\"></a>postProcessBeanFactory(beanFactory);</h4>空方法<h4 id=\"invokeBeanFactoryPostProcessors-beanFactory\"><a href=\"#invokeBeanFactoryPostProcessors-beanFactory\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors(beanFactory);\"></a>invokeBeanFactoryPostProcessors(beanFactory);</h4>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">\t\t//spring允许我们手动添加BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);</span><br><span class=\"line\">\t\t//getBeanFactoryPostProcessors() 在外部可以手动添加一个后置处理器，而不是交给Spring去扫描</span><br><span class=\"line\">\t\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class=\"line\">\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class=\"line\">\t\tif (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法\"><a href=\"#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法\" class=\"headerlink\" title=\"PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法\"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法</h5><p>先介绍两个接口：</p>\n<ul>\n<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>\n<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>\n</ul>\n<p>过程：</p>\n<ul>\n<li><p>beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</p>\n<ul>\n<li>1 定义了一个Set（processedBeans），装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。</li>\n<li><p>2 定义了两个List，</p>\n<ul>\n<li>一个是regularPostProcessors，用来装载BeanFactoryPostProcessor</li>\n</ul>\n<ul>\n<li>一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。</li>\n</ul>\n</li>\n<li><p>3 循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。</p>\n</li>\n<li><p>4 定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。</p>\n</li>\n<li><p>5 getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。</p>\n</li>\n<li><p>6 循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，</p>\n<ul>\n<li>判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了(当然现在还没有处理，但是马上就要处理了)</li>\n</ul>\n</li>\n<li>7 进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>\n<li>8 把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>\n<li>9 可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。</li>\n<li>10 清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。</li>\n<li>11 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。</li>\n<li>12 处理排序。</li>\n<li>13 合并Processors，合并的理由和上面是一样的。</li>\n<li>14 执行我们自定义的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>\n<li>15 清空临时变量。</li>\n<li>16 在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>\n<li>17 regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的postProcessBeanFactory方法</li>\n<li>18 regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</li>\n<li>19 查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//beanFactory=DefaultListableBeanFactory</span><br><span class=\"line\">//beanFactoryPostProcessors 没有添加 所以size=0</span><br><span class=\"line\">public static void invokeBeanFactoryPostProcessors(</span><br><span class=\"line\">\t\t\tConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class=\"line\">\t\tSet&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class=\"line\">       //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</span><br><span class=\"line\">\t\tif (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class=\"line\">\t\t\t//regularPostProcessors 用来存放BeanFactoryPostProcessor，</span><br><span class=\"line\">\t\t\tList&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t\t//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor,BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据</span><br><span class=\"line\">\t\t\t因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的</span><br><span class=\"line\">\t\t\t只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class=\"line\">\t\t\t/* 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t\t 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t\t是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class=\"line\">\t\t\t\t\tBeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class=\"line\">\t\t\t\t\t\t\t(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class=\"line\">\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class=\"line\">\t\t\t\t\tregistryProcessors.add(registryProcessor);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\t\tregularPostProcessors.add(postProcessor);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">\t\t\t// uninitialized to let the bean factory post-processors apply to them!</span><br><span class=\"line\">\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class=\"line\">\t\t\t// PriorityOrdered, Ordered, and the rest.</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t/* 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\tBeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class=\"line\">\t\t\t 对象是：ConfigurationClassPostProcessor</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tString[] postProcessorNames =</span><br><span class=\"line\">\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">\t\t\t\t\t/*</span><br><span class=\"line\">\t\t\t\t\t获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors</span><br><span class=\"line\">\t\t\t\t\tConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口</span><br><span class=\"line\">\t\t\t\t\tBeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口</span><br><span class=\"line\">\t\t\t\t\tConfigurationClassPostProcessor是极其重要的类</span><br><span class=\"line\">\t\t\t\t\t里面执行了扫描Bean，Import，ImportResouce等各种操作</span><br><span class=\"line\">\t\t\t\t\t用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑</span><br><span class=\"line\">\t\t\t\t\t */</span><br><span class=\"line\">\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\t//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了</span><br><span class=\"line\">\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//处理排序</span><br><span class=\"line\">\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t/* 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span><br><span class=\"line\">\t\t\t一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法</span><br><span class=\"line\">\t\t\t而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法</span><br><span class=\"line\">\t\t\t所以这里需要把处理器放入一个集合中，后续统一执行父类的方法</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t/*可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法</span><br><span class=\"line\">\t\t\tSpring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理</span><br><span class=\"line\">\t\t\t如果不想用这个组件，直接把注册组件的那一步去掉就可以</span><br><span class=\"line\">\t\t\t */</span><br><span class=\"line\">\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t//因为currentRegistryProcessors是一个临时变量，所以需要清除</span><br><span class=\"line\">\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class=\"line\">\t\t\t// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span><br><span class=\"line\">\t\t\t// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span><br><span class=\"line\">\t\t\t// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理</span><br><span class=\"line\">\t\t\t// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span><br><span class=\"line\">\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\tif (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//处理排序</span><br><span class=\"line\">\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t//合并Processors</span><br><span class=\"line\">\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t//执行我们自定义的BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t//清空临时变量</span><br><span class=\"line\">\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span><br><span class=\"line\">\t\t\t// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class=\"line\">\t\t\tboolean reiterate = true;</span><br><span class=\"line\">\t\t\twhile (reiterate) &#123;</span><br><span class=\"line\">\t\t\t\treiterate = false;</span><br><span class=\"line\">\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class=\"line\">\t\t\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (!processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">\t\t\t\t\t\tprocessedBeans.add(ppName);</span><br><span class=\"line\">\t\t\t\t\t\treiterate = true;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">\t\t\t\tcurrentRegistryProcessors.clear();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class=\"line\">\t\t\t//registryProcessors集合装载BeanDefinitionRegistryPostProcessor</span><br><span class=\"line\">\t\t\t//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class=\"line\">\t\t\t//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span><br><span class=\"line\">\t\t\t//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\telse &#123;</span><br><span class=\"line\">\t\t\t// Invoke factory processors registered with the context instance.</span><br><span class=\"line\">\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">\t\t// uninitialized to let the bean factory post-processors apply to them!</span><br><span class=\"line\">\t\t//找到BeanFactoryPostProcessor实现类的BeanName数组</span><br><span class=\"line\">\t\tString[] postProcessorNames =</span><br><span class=\"line\">\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class=\"line\">\t\t// Ordered, and the rest.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tList&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tList&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t//循环BeanName数组</span><br><span class=\"line\">\t\tfor (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">\t\t\t//如果这个Bean被执行过了，跳过</span><br><span class=\"line\">\t\t\tif (processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">\t\t\t\t// skip - already processed in first phase above</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors</span><br><span class=\"line\">\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//如果实现了Ordered接口，加入到orderedPostProcessorNames</span><br><span class=\"line\">\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">\t\t\t\torderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\t//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames</span><br><span class=\"line\">\t\t\t\tnonOrderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class=\"line\">\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\">\t\t//执行priorityOrderedPostProcessors</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//执行实现了Ordered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class=\"line\">\t\tfor (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class=\"line\">\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor</span><br><span class=\"line\">\t\t// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class=\"line\">\t\tList&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class=\"line\">\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class=\"line\">\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// Clear cached merged bean definitions since the post-processors might have</span><br><span class=\"line\">\t\t// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class=\"line\">\t\tbeanFactory.clearMetadataCache();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"#ConfigurationClassPostProcessor\">ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</a></p>\n<h4 id=\"registerBeanPostProcessors-beanFactory\"><a href=\"#registerBeanPostProcessors-beanFactory\" class=\"headerlink\" title=\"registerBeanPostProcessors(beanFactory);\"></a>registerBeanPostProcessors(beanFactory);</h4><h4 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource();\"></a>initMessageSource();</h4><h4 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster();\"></a>initApplicationEventMulticaster();</h4><h4 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh();\"></a>onRefresh();</h4><h4 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners();\"></a>registerListeners();</h4><h4 id=\"finishBeanFactoryInitialization-beanFactory\"><a href=\"#finishBeanFactoryInitialization-beanFactory\" class=\"headerlink\" title=\"finishBeanFactoryInitialization(beanFactory);\"></a>finishBeanFactoryInitialization(beanFactory);</h4><h4 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh();\"></a>finishRefresh();</h4><h2 id=\"循环依赖\"><a href=\"#循环依赖\" class=\"headerlink\" title=\"循环依赖\"></a>循环依赖</h2>"},{"title":"SpringSession源码","author":"wen","date":"2019-11-21T08:34:00.000Z","_content":"[可参考spring 引入 session代码](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)\n\n再详细阅读源码之前先来看张图，介绍下spring-session中的核心模块以及之间的交互。\n![springSesion模块](SpringSession源码/2.png)\n# spring-session分为以下核心模块：\n\n* SessionRepositoryFilter：Servlet规范中Filter的实现，用来切换HttpSession至Spring Session，包装HttpServletRequest和HttpServletResponse\n* HttpServerletRequest/HttpServletResponse/HttpSessionWrapper包装器：包装原有的HttpServletRequest、HttpServletResponse和Spring Session，实现切换Session和透明继承HttpSession的关键之所在\n* Session：Spring Session模块\n* SessionRepository：管理Spring Session的模块\n* HttpSessionStrategy：映射HttpRequst和HttpResponse到Session的策略\n## 1. SessionRepositoryFilter\nSessionRepositoryFilter是一个Filter过滤器，符合Servlet的规范定义，用来修改包装请求和响应。这里负责包装切换HttpSession至Spring Session的请求和响应。\nSpringHttpSessionConfiguration 类定义SessionRepositoryFilter Bean,而在spring项目DelegatingFilterProxy代理装配SessionRepositoryFilter[可参考spring 引入 session代码](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)，\n而spring boot项目为何自动装配SessionRepositoryFilter 待补充)\n```\n@Override\nprotected void doFilterInternal(HttpServletRequest request,\n        HttpServletResponse response, FilterChain filterChain)\n                throws ServletException, IOException {\n    // 设置SessionRepository至Request的属性中\n    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);\n    // 包装原始HttpServletRequest至SessionRepositoryRequestWrapper\n    SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(\n            request, response, this.servletContext);\n    // 包装原始HttpServletResponse响应至SessionRepositoryResponseWrapper\n    SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(\n            wrappedRequest, response);\n    // 设置当前请求的HttpSessionStrategy策略\n    HttpServletRequest strategyRequest = this.httpSessionStrategy\n            .wrapRequest(wrappedRequest, wrappedResponse);\n    // 设置当前响应的HttpSessionStrategy策略\n    HttpServletResponse strategyResponse = this.httpSessionStrategy\n            .wrapResponse(wrappedRequest, wrappedResponse);\n    try {\n        filterChain.doFilter(strategyRequest, strategyResponse);\n    }\n    finally {\n        // 提交session\n        wrappedRequest.commitSession();\n    }\n}\n```\n以上是SessionRepositoryFilter的核心操作，每个HttpRequest进入，都会被该Filter包装成切换Session的请求很响应对象。\n\n## SessionRepositoryRequestWrapper\n对于developers获取HttpSession的api\n```\nHttpServletRequest request = ...;\nHttpSession session = request.getSession(true);\n```\n在spring session中request的实际类型SessionRepositoryRequestWrapper。调用SessionRepositoryRequestWrapper的getSession方法会触发创建spring session，而非web容器的HttpSession。\n\nSessionRepositoryRequestWrapper用来包装原始的HttpServletRequest实现HttpSession切换至Spring Session。是透明Spring Session透明集成HttpSession的关键。\n```\nprivate final class SessionRepositoryRequestWrapper\n            extends HttpServletRequestWrapper {\n\n    private final String CURRENT_SESSION_ATTR = HttpServletRequestWrapper.class\n                .getName();\n\n    // 当前请求sessionId有效\n    private Boolean requestedSessionIdValid;\n    // 当前请求sessionId无效\n    private boolean requestedSessionInvalidated;\n    private final HttpServletResponse response;\n    private final ServletContext servletContext;\n\n    private SessionRepositoryRequestWrapper(HttpServletRequest request,\n            HttpServletResponse response, ServletContext servletContext) {\n        // 调用HttpServletRequestWrapper构造方法，实现包装\n        super(request);\n        this.response = response;\n        this.servletContext = servletContext;\n    }\n}\n```\nSessionRepositoryRequestWrapper继承Servlet规范中定义的包装器HttpServletRequestWrapper。HttpServletRequestWrapper是Servlet规范api提供的用于扩展HttpServletRequest的扩张点——即装饰器模式，可以通过重写一些api达到功能点的增强和自定义。\n\nHttpServletRequestWrapper中持有一个HttpServletRequest对象，然后实现HttpServletRequest接口的所有方法，所有方法实现中都是调用持有的HttpServletRequest对象的相应的方法。继承HttpServletRequestWrapper 可以对其重写。SessionRepositoryRequestWrapper继承HttpServletRequestWrapper，在构造方法中将原有的HttpServletRequest通过调用super完成对HttpServletRequestWrapper中持有的HttpServletRequest初始化赋值，然后重写和session相关的方法。这样就保证SessionRepositoryRequestWrapper的其他方法调用都是使用原有的HttpServletRequest的数据，只有session相关的是重写的逻辑。\n\n这里的设计是否很精妙！一切都多亏与Servlet规范设计的的巧妙啊！\n```\n@Override\npublic HttpSessionWrapper getSession() {\n    return getSession(true);\n}\n```\n重写HttpServletRequest的getSession()方法，调用有参数getSession(arg)方法，默认为true，表示当前reques没有session时创建session。继续看下有参数getSession(arg)的重写逻辑.\n```\n@Override\npublic HttpSessionWrapper getSession(boolean create) {\n    // 从当前请求的attribute中获取session，如果有直接返回\n    HttpSessionWrapper currentSession = getCurrentSession();\n    if (currentSession != null) {\n        return currentSession;\n    }\n\n    // 获取当前request的sessionId，这里使用了HttpSessionStrategy\n    // 决定怎样将Request映射至Session，默认使用Cookie策略，即从cookies中解析sessionId\n    String requestedSessionId = getRequestedSessionId();\n    // 请求的如果sessionId存在且当前request的attribute中的没有session失效属性\n    // 则根据sessionId获取spring session\n    if (requestedSessionId != null\n            && getAttribute(INVALID_SESSION_ID_ATTR) == null) {\n        S session = getSession(requestedSessionId);\n        // 如果spring session不为空，则将spring session包装成HttpSession并\n        // 设置到当前Request的attribute中，防止同一个request getsession时频繁的到存储器\n        //中获取session，提高性能\n        if (session != null) {\n            this.requestedSessionIdValid = true;\n            currentSession = new HttpSessionWrapper(session, getServletContext());\n            currentSession.setNew(false);\n            setCurrentSession(currentSession);\n            return currentSession;\n        }\n        // 如果根据sessionId，没有获取到session，则设置当前request属性，此sessionId无效\n        // 同一个请求中获取session，直接返回无效\n        else {\n            // This is an invalid session id. No need to ask again if\n            // request.getSession is invoked for the duration of this request\n            if (SESSION_LOGGER.isDebugEnabled()) {\n                SESSION_LOGGER.debug(\n                        \"No session found by id: Caching result for getSession(false) for this HttpServletRequest.\");\n            }\n            setAttribute(INVALID_SESSION_ID_ATTR, \"true\");\n        }\n    }\n    // 判断是否创建session\n    if (!create) {\n        return null;\n    }\n    if (SESSION_LOGGER.isDebugEnabled()) {\n        SESSION_LOGGER.debug(\n                \"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for \"\n                        + SESSION_LOGGER_NAME,\n                new RuntimeException(\n                        \"For debugging purposes only (not an error)\"));\n    }\n    // 根据sessionRepository创建spring session\n    S session = SessionRepositoryFilter.this.sessionRepository.createSession();\n    // 设置session的最新访问时间\n    session.setLastAccessedTime(System.currentTimeMillis());\n    // 包装成HttpSession透明化集成\n    currentSession = new HttpSessionWrapper(session, getServletContext());\n    // 设置session至Requset的attribute中，提高同一个request访问session的性能\n    setCurrentSession(currentSession);\n    return currentSession;\n}\n```\n\n再来看下spring session的持久化。上述SessionRepositoryFilter在包装HttpServletRequest后，执行FilterChain中使用finally保证请求的Session始终session会被提交，此提交操作中将sesionId设置到response的head中并将session持久化至存储器中。\n\n持久化只持久spring session，并不是将spring session包装后的HttpSession持久化，因为HttpSession不过是包装器，持久化没有意义。\n\n再来看下包装的响应SessionRepositoryResponseWrapper。\n## SessionRepositoryResponseWrapper\n```\n/**\n * Allows ensuring that the session is saved if the response is committed.\n *\n * @author Rob Winch\n * @since 1.0\n */\nprivate final class SessionRepositoryResponseWrapper\n        extends OnCommittedResponseWrapper {\n    private final SessionRepositoryRequestWrapper request;\n    /**\n     * Create a new {@link SessionRepositoryResponseWrapper}.\n     * @param request the request to be wrapped\n     * @param response the response to be wrapped\n     */\n    SessionRepositoryResponseWrapper(SessionRepositoryRequestWrapper request,\n            HttpServletResponse response) {\n        super(response);\n        if (request == null) {\n            throw new IllegalArgumentException(\"request cannot be null\");\n        }\n        this.request = request;\n    }\n    @Override\n    protected void onResponseCommitted() {\n        this.request.commitSession();\n    }\n}\n```\n上面的注释已经非常详细，这里不再赘述。这里只讲述为什么需要包装原始的响应。从注释上可以看出包装响应时为了：确保如果响应被提交session能够被保存。\n\n这里我有点疑惑：在上述的SessionRepositoryFilter.doFilterInternal方法中不是已经request.commitSession()了吗，FilterChain执行完或者异常后都会执行Finally中的request.commitSession。为什么这里仍然需要包装响应，为了确保session能够保存，包装器中的onResponseCommitted方法可以看出也是做了一次request.commitSession()\n\n原因：一旦response执行flushBuffer方法，迫使Response中在Buffer中任何数据都会被返回至client端。这个方法自动提交响应中的status code和head。那么如果不包装请求，监听flushBuffer事件在提交response前，将session写入response和持久化session，将导致作者说的无法追踪session。（来源网上）\n\nSessionRepositoryResponseWrapper继承父类OnCommittedResponseWrapper，其中flushBuffer方法如下：\n```\n/**\n * Makes sure {@link OnCommittedResponseWrapper#onResponseCommitted()} is invoked\n * before calling the superclass <code>flushBuffer()</code>.\n * @throws IOException if an input or output exception occurred\n */\n@Override\npublic void flushBuffer() throws IOException {\n    doOnResponseCommitted();\n    super.flushBuffer();\n}\n\n\n/**\n * Calls <code>onResponseCommmitted()</code> with the current contents as long as\n * {@link #disableOnResponseCommitted()} was not invoked.\n */\nprivate void doOnResponseCommitted() {\n    if (!this.disableOnCommitted) {\n        onResponseCommitted();\n        disableOnResponseCommitted();\n    }\n}\n```\n重写HttpServletResponse方法，监听response commit，当发生response commit时，可以在commit之前写session至response中并持久化session\n\n再看SessionRepository之前，先来看下spring session中的session接口。\n## Session接口\nspring-session和tomcat中的Session的实现模式上有很大不同，tomcat中直接对HttpSession接口进行实现，而spring-session中则抽象出单独的Session层接口，让后再使用适配器模式将Session适配层Servlet规范中的HttpSession。spring-sesion中关于session的实现和适配整个UML类图如下：\n\n![springSesion模块](SpringSession源码/3.png)\n\nSession是spring-session对session的抽象，主要是为了鉴定用户，为Http请求和响应提供上下文过程，该Session可以被HttpSession、WebSocket Session，非WebSession等使用。定义了Session的基本行为：\n* getId：获取sessionId\n* setAttribute：设置session属性\n* getAttribte：获取session属性\n\nExipringSession：提供Session额外的过期特性。定义了以下关于过期的行为：\n* setLastAccessedTime：设置最近Session会话过程中最近的访问时间\n* getLastAccessedTime：获取最近的访问时间\n* setMaxInactiveIntervalInSeconds：设置Session的最大闲置时间\n* getMaxInactiveIntervalInSeconds：获取最大闲置时间\n* isExpired：判断Session是否过期\n\nMapSession：基于java.util.Map的ExpiringSession的实现\n\nRedisSession：基于MapSession和Redis的ExpiringSession实现，提供Session的持久化能力\n\n先来看下MapSession的代码源码片段\n```\npublic final class MapSession implements ExpiringSession, Serializable {\n    /**\n     * Default {@link #setMaxInactiveIntervalInSeconds(int)} (30 minutes).\n     */\n    public static final int DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS = 1800;\n\n    private String id;\n    private Map<String, Object> sessionAttrs = new HashMap<String, Object>();\n    private long creationTime = System.currentTimeMillis();\n    private long lastAccessedTime = this.creationTime;\n\n    /**\n     * Defaults to 30 minutes.\n     */\n    private int maxInactiveInterval = DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS;\n```\nMapSession中持有HashMap类型的变量sessionAtts用于存储Session设置属性，比如调用的setAttribute方法的k-v就存储在该HashMap中。这个和tomcat内部实现HttpSession的方式类似，tomcat中使用了ConcurrentHashMap存储。\n\n其中lastAccessedTime用于记录最近的一次访问时间，maxInactiveInterval用于记录Session的最大闲置时间（过期时间-针对没有Request活跃的情况下的最大时间，即相对于最近一次访问后的最大闲置时间）。\n```\npublic void setAttribute(String attributeName, Object attributeValue) {\n    if (attributeValue == null) {\n        removeAttribute(attributeName);\n    }\n    else {\n        this.sessionAttrs.put(attributeName, attributeValue);\n    }\n}\n```\nsetAttribute方法极其简单，null时就移除attributeName，否则put存储。\n\n重点熟悉RedisSession如何实现Session的行为：setAttribute、persistence等。\n```\n/**\n * A custom implementation of {@link Session} that uses a {@link MapSession} as the\n * basis for its mapping. It keeps track of any attributes that have changed. When\n * {@link org.springframework.session.data.redis.RedisOperationsSessionRepository.RedisSession#saveDelta()}\n * is invoked all the attributes that have been changed will be persisted.\n *\n * @author Rob Winch\n * @since 1.0\n */\nfinal class RedisSession implements ExpiringSession {\n    private final MapSession cached;\n    private Long originalLastAccessTime;\n    private Map<String, Object> delta = new HashMap<String, Object>();\n    private boolean isNew;\n    private String originalPrincipalName;\n```\n首先看javadocs，对于阅读源码，学会看javadocs非常重要！\n\n基于MapSession的基本映射实现的Session，能够追踪发生变化的所有属性，当调用saveDelta方法后，变化的属性将被持久化！\n\n在RedisSession中有两个非常重要的成员属性：\n\n* cached：实际上是一个MapSession实例，用于做本地缓存，每次在getAttribute时无需从Redis中获取，主要为了improve性能\n* delta：用于跟踪变化数据，做持久化\n再来看下RedisSession中最为重要的行为saveDelta——持久化Session至Redis中：\n```\n/**\n * Saves any attributes that have been changed and updates the expiration of this\n * session.\n */\nprivate void saveDelta() {\n    // 如果delta为空，则Session中没有任何数据需要存储\n    if (this.delta.isEmpty()) {\n        return;\n    }\n    String sessionId = getId();\n    // 使用spring data redis将delta中的数据保存至Redis中\n    getSessionBoundHashOperations(sessionId).putAll(this.delta);\n    String principalSessionKey = getSessionAttrNameKey(\n            FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME);\n    String securityPrincipalSessionKey = getSessionAttrNameKey(\n            SPRING_SECURITY_CONTEXT);\n    if (this.delta.containsKey(principalSessionKey)\n            || this.delta.containsKey(securityPrincipalSessionKey)) {\n        if (this.originalPrincipalName != null) {\n            String originalPrincipalRedisKey = getPrincipalKey(\n                    this.originalPrincipalName);\n            RedisOperationsSessionRepository.this.sessionRedisOperations\n                    .boundSetOps(originalPrincipalRedisKey).remove(sessionId);\n        }\n        String principal = PRINCIPAL_NAME_RESOLVER.resolvePrincipal(this);\n        this.originalPrincipalName = principal;\n        if (principal != null) {\n            String principalRedisKey = getPrincipalKey(principal);\n            RedisOperationsSessionRepository.this.sessionRedisOperations\n                    .boundSetOps(principalRedisKey).add(sessionId);\n        }\n    }   \n    // 清空delta，代表没有任何需要持久化的数据。同时保证\n    //SessionRepositoryFilter和SessionRepositoryResponseWrapper的onResponseCommitted\n    //只会持久化一次Session至Redis中，解决前面提到的疑问\n    this.delta = new HashMap<String, Object>(this.delta.size());  \n    // 更新过期时间，滚动至下一个过期时间间隔的时刻\n    Long originalExpiration = this.originalLastAccessTime == null ? null\n            : this.originalLastAccessTime + TimeUnit.SECONDS\n                    .toMillis(getMaxInactiveIntervalInSeconds());\n    RedisOperationsSessionRepository.this.expirationPolicy\n            .onExpirationUpdated(originalExpiration, this);\n}\n```\n从javadoc中可以看出，saveDelta用于存储Session的属性：\n\n* 保存Session中的属性数据至Redis中\n* 清空delta中数据，防止重复提交Session中的数据\n* 更新过期时间至下一个过期时间间隔的时刻\n\n再看下RedisSession中的其他行为\n```\n// 设置session的存活时间，即最大过期时间。先保存至本地缓存，然后再保存至delta\npublic void setMaxInactiveIntervalInSeconds(int interval) {\n    this.cached.setMaxInactiveIntervalInSeconds(interval);\n    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());\n    flushImmediateIfNecessary();\n}\n\n// 直接从本地缓存获取过期时间\npublic int getMaxInactiveIntervalInSeconds() {\n    return this.cached.getMaxInactiveIntervalInSeconds();\n}\n\n// 直接从本地缓存中获取Session中的属性\n@SuppressWarnings(\"unchecked\")\npublic Object getAttribute(String attributeName) {\n    return this.cached.getAttribute(attributeName);\n}\n\n// 保存Session属性至本地缓存和delta中\npublic void setAttribute(String attributeName, Object attributeValue) {\n    this.cached.setAttribute(attributeName, attributeValue);\n    this.delta.put(getSessionAttrNameKey(attributeName), attributeValue);\n    flushImmediateIfNecessary();\n}\n```\n\n除了MapSession和RedisSession还有JdbcSession、MongoExpiringSession，感兴趣的读者可以自行阅读。\n\n下面看SessionRepository的逻辑。SessionRepository是spring session中用于管理spring session的核心组件。\n## SessionRepository\n\njavadoc中描述SessionRepository为管理spring-session的接口实例。抽象出：\n```\nS createSession();\nvoid save(S session);\nS getSession(String id);\nvoid delete(String id);\n```\n\n创建、保存、获取、删除Session的接口行为。根据Session的不同，分为很多种Session操作仓库。\n![springSesion模块](SpringSession源码/4.png)\n\n这里重点介绍下RedisOperationsSessionRepository。在详细介绍其之前，了解下RedisOperationsSessionRepository的数据存储细节。\n\n当创建一个RedisSession，然后存储在Redis中时，RedisSession的存储细节如下：\n\nspring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:expirations:1439245080000\n\nRedis会为每个RedisSession存储三个k-v。\n\n* 第一个k-v用来存储Session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等。这个k的过期时间为Session的最大过期时间 + 5分钟。如果默认的最大过期时间为30分钟，则这个k的过期时间为35分钟\n* 第二个k-v用来表示Session在Redis中的过期，这个k-v不存储任何有用数据，只是表示Session过期而设置。这个k在Redis中的过期时间即为Session的过期时间间隔\n* 第三个k-v存储这个Session的id，是一个Set类型的Redis数据结构。这个k中的最后的1439245080000值是一个时间戳，根据这个Session过期时刻滚动至下一分钟而计算得出。\n简单描述下，为什么RedisSession的存储用到了三个Key，而非一个Redis过期Key。\n对于Session的实现，需要支持HttpSessionEvent，即Session创建、过期、销毁等事件。当应用用监听器设置监听相应事件，Session发生上述行为时，监听器能够做出相应的处理。\nRedis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。\n\n但是Redis中带有过期的key有两种方式：\n\n* 当访问时发现其过期\n* Redis后台逐步查找过期键\n当访问时发现其过期，会产生过期事件，但是无法保证key的过期时间抵达后立即生成过期事件。\nspring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：\n\nspring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:expirations:1439245080000\n\nspring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。\n\n接下来再看下RedisOperationsSessionRepository中的具体实现原理\n### createSession方法：\n```\npublic RedisSession createSession() {\n    // new一个RedisSession实例\n    RedisSession redisSession = new RedisSession();\n    // 如果设置的最大过期时间不为空，则设置RedisSession的过期时间\n    if (this.defaultMaxInactiveInterval != null) {\n        redisSession.setMaxInactiveIntervalInSeconds(this.defaultMaxInactiveInterval);\n    }\n    return redisSession;\n}\n\n```\n再来看下RedisSession的构造方法：\n```\n/**\n * Creates a new instance ensuring to mark all of the new attributes to be\n * persisted in the next save operation.\n */\nRedisSession() {\n    // 设置本地缓存为MapSession\n    this(new MapSession());\n    // 设置Session的基本属性\n    this.delta.put(CREATION_TIME_ATTR, getCreationTime());\n    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());\n    this.delta.put(LAST_ACCESSED_ATTR, getLastAccessedTime());\n    // 标记Session的是否为新创建\n    this.isNew = true;\n    // 持久化\n    flushImmediateIfNecessary();\n}\n\n```\n### save方法：\n```\npublic void save(RedisSession session) {\n    // 调用RedisSession的saveDelta持久化Session\n    session.saveDelta();\n    // 如果Session为新创建，则发布一个Session创建的事件\n    if (session.isNew()) {\n        String sessionCreatedKey = getSessionCreatedChannel(session.getId());\n        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);\n        session.setNew(false);\n    }\n}\n\n```\n### getSession方法：\n```\n// 根据SessionId获取Session，这里的false代表的参数\n// 指：如果Session已经过期，是否仍然获取返回\npublic RedisSession getSession(String id) {\n    return getSession(id, false);\n}\n```\n在有些情况下，Session过期，仍然需要能够获取到Session。这里先来看下getSession(String id, boolean allowExpired)：\n```\n\nprivate RedisSession getSession(String id, boolean allowExpired) {\n    // 根据SessionId，从Redis获取到持久化的Session信息\n    Map<Object, Object> entries = getSessionBoundHashOperations(id).entries();\n    // 如果Redis中没有，则返回null\n    if (entries.isEmpty()) {\n        return null;\n    }\n    // 根据Session信息，加载创建一个MapSession对象\n    MapSession loaded = loadSession(id, entries);\n    //  判断是否允许过期获取和Session是否过期\n    if (!allowExpired && loaded.isExpired()) {\n        return null;\n    }\n    // 根据MapSession new一个信息的RedisSession，此时isNew为false\n    RedisSession result = new RedisSession(loaded);\n    // 设置最新的访问时间\n    result.originalLastAccessTime = loaded.getLastAccessedTime();\n    return result;\n}\n```\n这里需要注意的是loaded.isExpired()和loadSession。loaded.isExpired判断Session是否过期，如果过期返回null：\n```\npublic boolean isExpired() {\n    // 根据当前时间判断是否过期\n    return isExpired(System.currentTimeMillis());\n}\nboolean isExpired(long now) {\n    // 如果maxInactiveInterval小于0，表示Session永不过期\n    if (this.maxInactiveInterval < 0) {\n        return false;\n    }\n    // 最大过期时间单位转换为毫秒\n    // 当前时间减去Session的最大有效期间隔以获取理论上有效的上一次访问时间\n    // 然后在与实际的上一次访问时间进行比较\n    // 如果大于，表示理论上的时间已经在实际的访问时间之后，那么表示Session已经过期\n    return now - TimeUnit.SECONDS\n            .toMillis(this.maxInactiveInterval) >= this.lastAccessedTime;\n}\n```\nloadSession中，将Redis中存储的Session信息转换为MapSession对象，以便从Session中获取属性时能够从内存直接获取提高性能：\n```\nprivate MapSession loadSession(String id, Map<Object, Object> entries) {\n    MapSession loaded = new MapSession(id);\n    for (Map.Entry<Object, Object> entry : entries.entrySet()) {\n        String key = (String) entry.getKey();\n        if (CREATION_TIME_ATTR.equals(key)) {\n            loaded.setCreationTime((Long) entry.getValue());\n        }\n        else if (MAX_INACTIVE_ATTR.equals(key)) {\n            loaded.setMaxInactiveIntervalInSeconds((Integer) entry.getValue());\n        }\n        else if (LAST_ACCESSED_ATTR.equals(key)) {\n            loaded.setLastAccessedTime((Long) entry.getValue());\n        }\n        else if (key.startsWith(SESSION_ATTR_PREFIX)) {\n            loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),\n                    entry.getValue());\n        }\n    }\n    return loaded;\n}\n```\n至此，可以看出spring-session中request.getSession(false)的过期实现原理。\n\n### delete方法：\n```\npublic void delete(String sessionId) {\n    // 获取Session\n    RedisSession session = getSession(sessionId, true);\n    if (session == null) {\n        return;\n    }\n    cleanupPrincipalIndex(session);\n    // 从过期集合中移除sessionId\n    this.expirationPolicy.onDelete(session);\n    String expireKey = getExpiredKey(session.getId());\n    // 删除session的过期键\n    this.sessionRedisOperations.delete(expireKey);\n    // 设置session过期\n    session.setMaxInactiveIntervalInSeconds(0);\n    save(session);\n}\n```\n至此RedisOperationsSessionRepository的核心原理就介绍完毕。但是RedisOperationsSessionRepository中还包括关于Session事件的处理和清理Session的定时任务。这部分内容在后述的SessionEvent部分介绍。\n\n##  HttpSessionStrategy\n从javadoc中可以看出，HttpSessionStrategy是建立Request/Response和Session之间的映射关系的策略。\n该策略接口中定义一套策略行为：\n```\n// 根据请求获取SessionId，即建立请求至Session的映射关系\nString getRequestedSessionId(HttpServletRequest request);\n// 对于新创建的Session，通知客户端\nvoid onNewSession(Session session, HttpServletRequest request,\n            HttpServletResponse response);\n// 对于session无效，通知客户端\nvoid onInvalidateSession(HttpServletRequest request, HttpServletResponse response);\n```\n如下UML类图：\n![springSesion模块](SpringSession源码/5.png)\n\n这里主要介绍CookieHttpSessionStrategy，这个也是默认的策略，可以查看spring-session中类SpringHttpSessionConfiguration，在注册SessionRepositoryFilter Bean时默认采用CookieHttpSessionStrategy：\n```\n@Bean\npublic <S extends ExpiringSession> SessionRepositoryFilter<? extends ExpiringSession> springSessionRepositoryFilter(\n        SessionRepository<S> sessionRepository) {\n    SessionRepositoryFilter<S> sessionRepositoryFilter = new SessionRepositoryFilter<S>(\n            sessionRepository);\n    sessionRepositoryFilter.setServletContext(this.servletContext);\n    if (this.httpSessionStrategy instanceof MultiHttpSessionStrategy) {\n        sessionRepositoryFilter.setHttpSessionStrategy(\n                (MultiHttpSessionStrategy) this.httpSessionStrategy);\n    }\n    else {\n        sessionRepositoryFilter.setHttpSessionStrategy(this.httpSessionStrategy);\n    }\n    return sessionRepositoryFilter;\n}\n```\n下面来分析CookieHttpSessionStrategy的原理。该策略使用Cookie来映射Request/Response至Session。即request/requset的head中cookie存储SessionId，当请求至web服务器，可以解析请求head中的cookie，然后获取sessionId，根据sessionId获取spring-session。当创建新的session或者session过期，将相应的sessionId写入response的set-cookie或者从respose中移除sessionId。\n### getRequestedSessionId方法\n```\npublic String getRequestedSessionId(HttpServletRequest request) {\n    // 获取当前请求的sessionId：session别名和sessionId映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取当前请求的Session别名\n    String sessionAlias = getCurrentSessionAlias(request);\n    // 获取相应别名的sessionId\n    return sessionIds.get(sessionAlias);\n}\n```\n接下来看下具体获取SessionIds的具体过程：\n```\npublic String getRequestedSessionId(HttpServletRequest request) {\n    // 获取当前请求的sessionId：session别名和sessionId映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取当前请求的Session别名\n    String sessionAlias = getCurrentSessionAlias(request);\n    // 获取相应别名的sessionId\n    return sessionIds.get(sessionAlias);\n}\n\n\npublic Map<String, String> getSessionIds(HttpServletRequest request) {\n    // 解析request中的cookie值\n    List<String> cookieValues = this.cookieSerializer.readCookieValues(request);\n    // 获取sessionId\n    String sessionCookieValue = cookieValues.isEmpty() ? \"\"\n            : cookieValues.iterator().next();\n    Map<String, String> result = new LinkedHashMap<String, String>();\n    // 根据分词器对sessionId进行分割，因为spring-session支持多session。默认情况只有一个session\n    StringTokenizer tokens = new StringTokenizer(sessionCookieValue, this.deserializationDelimiter);\n    // 如果只有一个session，则设置默认别名为0\n    if (tokens.countTokens() == 1) {\n        result.put(DEFAULT_ALIAS, tokens.nextToken());\n        return result;\n    }\n    // 如果有多个session，则建立别名和sessionId的映射\n    while (tokens.hasMoreTokens()) {\n        String alias = tokens.nextToken();\n        if (!tokens.hasMoreTokens()) {\n            break;\n        }\n        String id = tokens.nextToken();\n        result.put(alias, id);\n    }\n    return result;\n}\n\n\npublic List<String> readCookieValues(HttpServletRequest request) {\n    // 获取request的cookie\n    Cookie[] cookies = request.getCookies();\n    List<String> matchingCookieValues = new ArrayList<String>();\n    if (cookies != null) {\n        for (Cookie cookie : cookies) {\n            // 如果是以SESSION开头，则表示是SessionId，毕竟cookie不只有sessionId，还有可能存储其他内容\n            if (this.cookieName.equals(cookie.getName())) {\n                // 决策是否需要base64 decode\n                String sessionId = this.useBase64Encoding\n                        ? base64Decode(cookie.getValue()) : cookie.getValue();\n                if (sessionId == null) {\n                    continue;\n                }\n                if (this.jvmRoute != null && sessionId.endsWith(this.jvmRoute)) {\n                    sessionId = sessionId.substring(0,\n                            sessionId.length() - this.jvmRoute.length());\n                }\n                // 存入list中\n                matchingCookieValues.add(sessionId);\n            }\n        }\n    }\n    return matchingCookieValues;\n}\n```\n再来看下获取当前request对应的Session的别名方法getCurrentSessionAlias\n```\npublic String getCurrentSessionAlias(HttpServletRequest request) {\n    // 如果session参数为空，则返回默认session别名\n    if (this.sessionParam == null) {\n        return DEFAULT_ALIAS;\n    }\n    // 从request中获取session别名，如果为空则返回默认别名\n    String u = request.getParameter(this.sessionParam);\n    if (u == null) {\n        return DEFAULT_ALIAS;\n    }\n    if (!ALIAS_PATTERN.matcher(u).matches()) {\n        return DEFAULT_ALIAS;\n    }\n    return u;\n}\n```\nspring-session为了支持多session，才弄出多个session别名。当时一般应用场景都是一个session，都是默认的session别名0。\n\n上述获取sessionId和别名映射关系中，也是默认别名0。这里返回别名0，所以返回当前请求对应的sessionId。\n\n### onNewSession方法\n\n```\npublic void onNewSession(Session session, HttpServletRequest request,\n        HttpServletResponse response) {\n    // 从当前request中获取已经写入Cookie的sessionId集合\n    Set<String> sessionIdsWritten = getSessionIdsWritten(request);\n    // 判断是否包含，如果包含，表示该sessionId已经写入过cookie中，则直接返回\n    if (sessionIdsWritten.contains(session.getId())) {\n        return;\n    }\n    // 如果没有写入，则加入集合，后续再写入\n    sessionIdsWritten.add(session.getId());\n    Map<String, String> sessionIds = getSessionIds(request);\n    String sessionAlias = getCurrentSessionAlias(request);\n    sessionIds.put(sessionAlias, session.getId());\n    // 获取cookieValue\n    String cookieValue = createSessionCookieValue(sessionIds);\n    //将cookieValue写入Cookie中\n    this.cookieSerializer\n            .writeCookieValue(new CookieValue(request, response, cookieValue));\n}\n```\nsessionIdsWritten主要是用来记录已经写入Cookie的SessionId，防止SessionId重复写入Cookie中。\n\n### onInvalidateSession方法\n\n```\npublic void onInvalidateSession(HttpServletRequest request,\n        HttpServletResponse response) {\n    // 从当前request中获取sessionId和别名映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取别名\n    String requestedAlias = getCurrentSessionAlias(request);\n    // 移除sessionId\n    sessionIds.remove(requestedAlias);\n    String cookieValue = createSessionCookieValue(sessionIds);\n    // 写入移除后的sessionId\n    this.cookieSerializer\n            .writeCookieValue(new CookieValue(request, response, cookieValue));\n}\n```\n继续看下具体的写入writeCookieValue原理：\n```\npublic void writeCookieValue(CookieValue cookieValue) {\n    // 获取request/respose和cookie值\n    HttpServletRequest request = cookieValue.getRequest();\n    HttpServletResponse response = cookieValue.getResponse();\n    String requestedCookieValue = cookieValue.getCookieValue();\n    String actualCookieValue = this.jvmRoute == null ? requestedCookieValue\n            : requestedCookieValue + this.jvmRoute;\n    // 构造servlet规范中的Cookie对象，注意这里cookieName为：SESSION，表示为Session，\n    // 上述的从Cookie中读取SessionId，也是使用该cookieName\n    Cookie sessionCookie = new Cookie(this.cookieName, this.useBase64Encoding\n            ? base64Encode(actualCookieValue) : actualCookieValue);\n    // 设置cookie的属性：secure、path、domain、httpOnly\n    sessionCookie.setSecure(isSecureCookie(request));\n    sessionCookie.setPath(getCookiePath(request));\n    String domainName = getDomainName(request);\n    if (domainName != null) {\n        sessionCookie.setDomain(domainName);\n    }\n    if (this.useHttpOnlyCookie) {\n        sessionCookie.setHttpOnly(true);\n    }\n    // 如果cookie值为空，则失效\n    if (\"\".equals(requestedCookieValue)) {\n        sessionCookie.setMaxAge(0);\n    }\n    else {\n        sessionCookie.setMaxAge(this.cookieMaxAge);\n    }\n    // 写入cookie到response中\n    response.addCookie(sessionCookie);\n}\n```\n\n至此，CookieHttpSessionStrategy介绍结束。\n\n由于篇幅过长，关于spring-session event和RedisOperationSessionRepository清理session并且产生过期事件的部分后续文章介绍。\n\n# 总结\nspring-session提供集群环境下HttpSession的透明集成。spring-session的优势在于开箱即用，具有较强的设计模式。且支持多种持久化方式，其中RedisSession较为成熟，与spring-data-redis整合，可谓威力无穷。","source":"_posts/SpringSession源码.md","raw":"title: SpringSession源码\nauthor: wen\ntags:\n  - springsession\n  - session\ncategories:\n  - spring\n  - spring boot\ndate: 2019-11-21 16:34:00\n---\n[可参考spring 引入 session代码](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)\n\n再详细阅读源码之前先来看张图，介绍下spring-session中的核心模块以及之间的交互。\n![springSesion模块](SpringSession源码/2.png)\n# spring-session分为以下核心模块：\n\n* SessionRepositoryFilter：Servlet规范中Filter的实现，用来切换HttpSession至Spring Session，包装HttpServletRequest和HttpServletResponse\n* HttpServerletRequest/HttpServletResponse/HttpSessionWrapper包装器：包装原有的HttpServletRequest、HttpServletResponse和Spring Session，实现切换Session和透明继承HttpSession的关键之所在\n* Session：Spring Session模块\n* SessionRepository：管理Spring Session的模块\n* HttpSessionStrategy：映射HttpRequst和HttpResponse到Session的策略\n## 1. SessionRepositoryFilter\nSessionRepositoryFilter是一个Filter过滤器，符合Servlet的规范定义，用来修改包装请求和响应。这里负责包装切换HttpSession至Spring Session的请求和响应。\nSpringHttpSessionConfiguration 类定义SessionRepositoryFilter Bean,而在spring项目DelegatingFilterProxy代理装配SessionRepositoryFilter[可参考spring 引入 session代码](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)，\n而spring boot项目为何自动装配SessionRepositoryFilter 待补充)\n```\n@Override\nprotected void doFilterInternal(HttpServletRequest request,\n        HttpServletResponse response, FilterChain filterChain)\n                throws ServletException, IOException {\n    // 设置SessionRepository至Request的属性中\n    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);\n    // 包装原始HttpServletRequest至SessionRepositoryRequestWrapper\n    SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(\n            request, response, this.servletContext);\n    // 包装原始HttpServletResponse响应至SessionRepositoryResponseWrapper\n    SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(\n            wrappedRequest, response);\n    // 设置当前请求的HttpSessionStrategy策略\n    HttpServletRequest strategyRequest = this.httpSessionStrategy\n            .wrapRequest(wrappedRequest, wrappedResponse);\n    // 设置当前响应的HttpSessionStrategy策略\n    HttpServletResponse strategyResponse = this.httpSessionStrategy\n            .wrapResponse(wrappedRequest, wrappedResponse);\n    try {\n        filterChain.doFilter(strategyRequest, strategyResponse);\n    }\n    finally {\n        // 提交session\n        wrappedRequest.commitSession();\n    }\n}\n```\n以上是SessionRepositoryFilter的核心操作，每个HttpRequest进入，都会被该Filter包装成切换Session的请求很响应对象。\n\n## SessionRepositoryRequestWrapper\n对于developers获取HttpSession的api\n```\nHttpServletRequest request = ...;\nHttpSession session = request.getSession(true);\n```\n在spring session中request的实际类型SessionRepositoryRequestWrapper。调用SessionRepositoryRequestWrapper的getSession方法会触发创建spring session，而非web容器的HttpSession。\n\nSessionRepositoryRequestWrapper用来包装原始的HttpServletRequest实现HttpSession切换至Spring Session。是透明Spring Session透明集成HttpSession的关键。\n```\nprivate final class SessionRepositoryRequestWrapper\n            extends HttpServletRequestWrapper {\n\n    private final String CURRENT_SESSION_ATTR = HttpServletRequestWrapper.class\n                .getName();\n\n    // 当前请求sessionId有效\n    private Boolean requestedSessionIdValid;\n    // 当前请求sessionId无效\n    private boolean requestedSessionInvalidated;\n    private final HttpServletResponse response;\n    private final ServletContext servletContext;\n\n    private SessionRepositoryRequestWrapper(HttpServletRequest request,\n            HttpServletResponse response, ServletContext servletContext) {\n        // 调用HttpServletRequestWrapper构造方法，实现包装\n        super(request);\n        this.response = response;\n        this.servletContext = servletContext;\n    }\n}\n```\nSessionRepositoryRequestWrapper继承Servlet规范中定义的包装器HttpServletRequestWrapper。HttpServletRequestWrapper是Servlet规范api提供的用于扩展HttpServletRequest的扩张点——即装饰器模式，可以通过重写一些api达到功能点的增强和自定义。\n\nHttpServletRequestWrapper中持有一个HttpServletRequest对象，然后实现HttpServletRequest接口的所有方法，所有方法实现中都是调用持有的HttpServletRequest对象的相应的方法。继承HttpServletRequestWrapper 可以对其重写。SessionRepositoryRequestWrapper继承HttpServletRequestWrapper，在构造方法中将原有的HttpServletRequest通过调用super完成对HttpServletRequestWrapper中持有的HttpServletRequest初始化赋值，然后重写和session相关的方法。这样就保证SessionRepositoryRequestWrapper的其他方法调用都是使用原有的HttpServletRequest的数据，只有session相关的是重写的逻辑。\n\n这里的设计是否很精妙！一切都多亏与Servlet规范设计的的巧妙啊！\n```\n@Override\npublic HttpSessionWrapper getSession() {\n    return getSession(true);\n}\n```\n重写HttpServletRequest的getSession()方法，调用有参数getSession(arg)方法，默认为true，表示当前reques没有session时创建session。继续看下有参数getSession(arg)的重写逻辑.\n```\n@Override\npublic HttpSessionWrapper getSession(boolean create) {\n    // 从当前请求的attribute中获取session，如果有直接返回\n    HttpSessionWrapper currentSession = getCurrentSession();\n    if (currentSession != null) {\n        return currentSession;\n    }\n\n    // 获取当前request的sessionId，这里使用了HttpSessionStrategy\n    // 决定怎样将Request映射至Session，默认使用Cookie策略，即从cookies中解析sessionId\n    String requestedSessionId = getRequestedSessionId();\n    // 请求的如果sessionId存在且当前request的attribute中的没有session失效属性\n    // 则根据sessionId获取spring session\n    if (requestedSessionId != null\n            && getAttribute(INVALID_SESSION_ID_ATTR) == null) {\n        S session = getSession(requestedSessionId);\n        // 如果spring session不为空，则将spring session包装成HttpSession并\n        // 设置到当前Request的attribute中，防止同一个request getsession时频繁的到存储器\n        //中获取session，提高性能\n        if (session != null) {\n            this.requestedSessionIdValid = true;\n            currentSession = new HttpSessionWrapper(session, getServletContext());\n            currentSession.setNew(false);\n            setCurrentSession(currentSession);\n            return currentSession;\n        }\n        // 如果根据sessionId，没有获取到session，则设置当前request属性，此sessionId无效\n        // 同一个请求中获取session，直接返回无效\n        else {\n            // This is an invalid session id. No need to ask again if\n            // request.getSession is invoked for the duration of this request\n            if (SESSION_LOGGER.isDebugEnabled()) {\n                SESSION_LOGGER.debug(\n                        \"No session found by id: Caching result for getSession(false) for this HttpServletRequest.\");\n            }\n            setAttribute(INVALID_SESSION_ID_ATTR, \"true\");\n        }\n    }\n    // 判断是否创建session\n    if (!create) {\n        return null;\n    }\n    if (SESSION_LOGGER.isDebugEnabled()) {\n        SESSION_LOGGER.debug(\n                \"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for \"\n                        + SESSION_LOGGER_NAME,\n                new RuntimeException(\n                        \"For debugging purposes only (not an error)\"));\n    }\n    // 根据sessionRepository创建spring session\n    S session = SessionRepositoryFilter.this.sessionRepository.createSession();\n    // 设置session的最新访问时间\n    session.setLastAccessedTime(System.currentTimeMillis());\n    // 包装成HttpSession透明化集成\n    currentSession = new HttpSessionWrapper(session, getServletContext());\n    // 设置session至Requset的attribute中，提高同一个request访问session的性能\n    setCurrentSession(currentSession);\n    return currentSession;\n}\n```\n\n再来看下spring session的持久化。上述SessionRepositoryFilter在包装HttpServletRequest后，执行FilterChain中使用finally保证请求的Session始终session会被提交，此提交操作中将sesionId设置到response的head中并将session持久化至存储器中。\n\n持久化只持久spring session，并不是将spring session包装后的HttpSession持久化，因为HttpSession不过是包装器，持久化没有意义。\n\n再来看下包装的响应SessionRepositoryResponseWrapper。\n## SessionRepositoryResponseWrapper\n```\n/**\n * Allows ensuring that the session is saved if the response is committed.\n *\n * @author Rob Winch\n * @since 1.0\n */\nprivate final class SessionRepositoryResponseWrapper\n        extends OnCommittedResponseWrapper {\n    private final SessionRepositoryRequestWrapper request;\n    /**\n     * Create a new {@link SessionRepositoryResponseWrapper}.\n     * @param request the request to be wrapped\n     * @param response the response to be wrapped\n     */\n    SessionRepositoryResponseWrapper(SessionRepositoryRequestWrapper request,\n            HttpServletResponse response) {\n        super(response);\n        if (request == null) {\n            throw new IllegalArgumentException(\"request cannot be null\");\n        }\n        this.request = request;\n    }\n    @Override\n    protected void onResponseCommitted() {\n        this.request.commitSession();\n    }\n}\n```\n上面的注释已经非常详细，这里不再赘述。这里只讲述为什么需要包装原始的响应。从注释上可以看出包装响应时为了：确保如果响应被提交session能够被保存。\n\n这里我有点疑惑：在上述的SessionRepositoryFilter.doFilterInternal方法中不是已经request.commitSession()了吗，FilterChain执行完或者异常后都会执行Finally中的request.commitSession。为什么这里仍然需要包装响应，为了确保session能够保存，包装器中的onResponseCommitted方法可以看出也是做了一次request.commitSession()\n\n原因：一旦response执行flushBuffer方法，迫使Response中在Buffer中任何数据都会被返回至client端。这个方法自动提交响应中的status code和head。那么如果不包装请求，监听flushBuffer事件在提交response前，将session写入response和持久化session，将导致作者说的无法追踪session。（来源网上）\n\nSessionRepositoryResponseWrapper继承父类OnCommittedResponseWrapper，其中flushBuffer方法如下：\n```\n/**\n * Makes sure {@link OnCommittedResponseWrapper#onResponseCommitted()} is invoked\n * before calling the superclass <code>flushBuffer()</code>.\n * @throws IOException if an input or output exception occurred\n */\n@Override\npublic void flushBuffer() throws IOException {\n    doOnResponseCommitted();\n    super.flushBuffer();\n}\n\n\n/**\n * Calls <code>onResponseCommmitted()</code> with the current contents as long as\n * {@link #disableOnResponseCommitted()} was not invoked.\n */\nprivate void doOnResponseCommitted() {\n    if (!this.disableOnCommitted) {\n        onResponseCommitted();\n        disableOnResponseCommitted();\n    }\n}\n```\n重写HttpServletResponse方法，监听response commit，当发生response commit时，可以在commit之前写session至response中并持久化session\n\n再看SessionRepository之前，先来看下spring session中的session接口。\n## Session接口\nspring-session和tomcat中的Session的实现模式上有很大不同，tomcat中直接对HttpSession接口进行实现，而spring-session中则抽象出单独的Session层接口，让后再使用适配器模式将Session适配层Servlet规范中的HttpSession。spring-sesion中关于session的实现和适配整个UML类图如下：\n\n![springSesion模块](SpringSession源码/3.png)\n\nSession是spring-session对session的抽象，主要是为了鉴定用户，为Http请求和响应提供上下文过程，该Session可以被HttpSession、WebSocket Session，非WebSession等使用。定义了Session的基本行为：\n* getId：获取sessionId\n* setAttribute：设置session属性\n* getAttribte：获取session属性\n\nExipringSession：提供Session额外的过期特性。定义了以下关于过期的行为：\n* setLastAccessedTime：设置最近Session会话过程中最近的访问时间\n* getLastAccessedTime：获取最近的访问时间\n* setMaxInactiveIntervalInSeconds：设置Session的最大闲置时间\n* getMaxInactiveIntervalInSeconds：获取最大闲置时间\n* isExpired：判断Session是否过期\n\nMapSession：基于java.util.Map的ExpiringSession的实现\n\nRedisSession：基于MapSession和Redis的ExpiringSession实现，提供Session的持久化能力\n\n先来看下MapSession的代码源码片段\n```\npublic final class MapSession implements ExpiringSession, Serializable {\n    /**\n     * Default {@link #setMaxInactiveIntervalInSeconds(int)} (30 minutes).\n     */\n    public static final int DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS = 1800;\n\n    private String id;\n    private Map<String, Object> sessionAttrs = new HashMap<String, Object>();\n    private long creationTime = System.currentTimeMillis();\n    private long lastAccessedTime = this.creationTime;\n\n    /**\n     * Defaults to 30 minutes.\n     */\n    private int maxInactiveInterval = DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS;\n```\nMapSession中持有HashMap类型的变量sessionAtts用于存储Session设置属性，比如调用的setAttribute方法的k-v就存储在该HashMap中。这个和tomcat内部实现HttpSession的方式类似，tomcat中使用了ConcurrentHashMap存储。\n\n其中lastAccessedTime用于记录最近的一次访问时间，maxInactiveInterval用于记录Session的最大闲置时间（过期时间-针对没有Request活跃的情况下的最大时间，即相对于最近一次访问后的最大闲置时间）。\n```\npublic void setAttribute(String attributeName, Object attributeValue) {\n    if (attributeValue == null) {\n        removeAttribute(attributeName);\n    }\n    else {\n        this.sessionAttrs.put(attributeName, attributeValue);\n    }\n}\n```\nsetAttribute方法极其简单，null时就移除attributeName，否则put存储。\n\n重点熟悉RedisSession如何实现Session的行为：setAttribute、persistence等。\n```\n/**\n * A custom implementation of {@link Session} that uses a {@link MapSession} as the\n * basis for its mapping. It keeps track of any attributes that have changed. When\n * {@link org.springframework.session.data.redis.RedisOperationsSessionRepository.RedisSession#saveDelta()}\n * is invoked all the attributes that have been changed will be persisted.\n *\n * @author Rob Winch\n * @since 1.0\n */\nfinal class RedisSession implements ExpiringSession {\n    private final MapSession cached;\n    private Long originalLastAccessTime;\n    private Map<String, Object> delta = new HashMap<String, Object>();\n    private boolean isNew;\n    private String originalPrincipalName;\n```\n首先看javadocs，对于阅读源码，学会看javadocs非常重要！\n\n基于MapSession的基本映射实现的Session，能够追踪发生变化的所有属性，当调用saveDelta方法后，变化的属性将被持久化！\n\n在RedisSession中有两个非常重要的成员属性：\n\n* cached：实际上是一个MapSession实例，用于做本地缓存，每次在getAttribute时无需从Redis中获取，主要为了improve性能\n* delta：用于跟踪变化数据，做持久化\n再来看下RedisSession中最为重要的行为saveDelta——持久化Session至Redis中：\n```\n/**\n * Saves any attributes that have been changed and updates the expiration of this\n * session.\n */\nprivate void saveDelta() {\n    // 如果delta为空，则Session中没有任何数据需要存储\n    if (this.delta.isEmpty()) {\n        return;\n    }\n    String sessionId = getId();\n    // 使用spring data redis将delta中的数据保存至Redis中\n    getSessionBoundHashOperations(sessionId).putAll(this.delta);\n    String principalSessionKey = getSessionAttrNameKey(\n            FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME);\n    String securityPrincipalSessionKey = getSessionAttrNameKey(\n            SPRING_SECURITY_CONTEXT);\n    if (this.delta.containsKey(principalSessionKey)\n            || this.delta.containsKey(securityPrincipalSessionKey)) {\n        if (this.originalPrincipalName != null) {\n            String originalPrincipalRedisKey = getPrincipalKey(\n                    this.originalPrincipalName);\n            RedisOperationsSessionRepository.this.sessionRedisOperations\n                    .boundSetOps(originalPrincipalRedisKey).remove(sessionId);\n        }\n        String principal = PRINCIPAL_NAME_RESOLVER.resolvePrincipal(this);\n        this.originalPrincipalName = principal;\n        if (principal != null) {\n            String principalRedisKey = getPrincipalKey(principal);\n            RedisOperationsSessionRepository.this.sessionRedisOperations\n                    .boundSetOps(principalRedisKey).add(sessionId);\n        }\n    }   \n    // 清空delta，代表没有任何需要持久化的数据。同时保证\n    //SessionRepositoryFilter和SessionRepositoryResponseWrapper的onResponseCommitted\n    //只会持久化一次Session至Redis中，解决前面提到的疑问\n    this.delta = new HashMap<String, Object>(this.delta.size());  \n    // 更新过期时间，滚动至下一个过期时间间隔的时刻\n    Long originalExpiration = this.originalLastAccessTime == null ? null\n            : this.originalLastAccessTime + TimeUnit.SECONDS\n                    .toMillis(getMaxInactiveIntervalInSeconds());\n    RedisOperationsSessionRepository.this.expirationPolicy\n            .onExpirationUpdated(originalExpiration, this);\n}\n```\n从javadoc中可以看出，saveDelta用于存储Session的属性：\n\n* 保存Session中的属性数据至Redis中\n* 清空delta中数据，防止重复提交Session中的数据\n* 更新过期时间至下一个过期时间间隔的时刻\n\n再看下RedisSession中的其他行为\n```\n// 设置session的存活时间，即最大过期时间。先保存至本地缓存，然后再保存至delta\npublic void setMaxInactiveIntervalInSeconds(int interval) {\n    this.cached.setMaxInactiveIntervalInSeconds(interval);\n    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());\n    flushImmediateIfNecessary();\n}\n\n// 直接从本地缓存获取过期时间\npublic int getMaxInactiveIntervalInSeconds() {\n    return this.cached.getMaxInactiveIntervalInSeconds();\n}\n\n// 直接从本地缓存中获取Session中的属性\n@SuppressWarnings(\"unchecked\")\npublic Object getAttribute(String attributeName) {\n    return this.cached.getAttribute(attributeName);\n}\n\n// 保存Session属性至本地缓存和delta中\npublic void setAttribute(String attributeName, Object attributeValue) {\n    this.cached.setAttribute(attributeName, attributeValue);\n    this.delta.put(getSessionAttrNameKey(attributeName), attributeValue);\n    flushImmediateIfNecessary();\n}\n```\n\n除了MapSession和RedisSession还有JdbcSession、MongoExpiringSession，感兴趣的读者可以自行阅读。\n\n下面看SessionRepository的逻辑。SessionRepository是spring session中用于管理spring session的核心组件。\n## SessionRepository\n\njavadoc中描述SessionRepository为管理spring-session的接口实例。抽象出：\n```\nS createSession();\nvoid save(S session);\nS getSession(String id);\nvoid delete(String id);\n```\n\n创建、保存、获取、删除Session的接口行为。根据Session的不同，分为很多种Session操作仓库。\n![springSesion模块](SpringSession源码/4.png)\n\n这里重点介绍下RedisOperationsSessionRepository。在详细介绍其之前，了解下RedisOperationsSessionRepository的数据存储细节。\n\n当创建一个RedisSession，然后存储在Redis中时，RedisSession的存储细节如下：\n\nspring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:expirations:1439245080000\n\nRedis会为每个RedisSession存储三个k-v。\n\n* 第一个k-v用来存储Session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等。这个k的过期时间为Session的最大过期时间 + 5分钟。如果默认的最大过期时间为30分钟，则这个k的过期时间为35分钟\n* 第二个k-v用来表示Session在Redis中的过期，这个k-v不存储任何有用数据，只是表示Session过期而设置。这个k在Redis中的过期时间即为Session的过期时间间隔\n* 第三个k-v存储这个Session的id，是一个Set类型的Redis数据结构。这个k中的最后的1439245080000值是一个时间戳，根据这个Session过期时刻滚动至下一分钟而计算得出。\n简单描述下，为什么RedisSession的存储用到了三个Key，而非一个Redis过期Key。\n对于Session的实现，需要支持HttpSessionEvent，即Session创建、过期、销毁等事件。当应用用监听器设置监听相应事件，Session发生上述行为时，监听器能够做出相应的处理。\nRedis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。\n\n但是Redis中带有过期的key有两种方式：\n\n* 当访问时发现其过期\n* Redis后台逐步查找过期键\n当访问时发现其过期，会产生过期事件，但是无法保证key的过期时间抵达后立即生成过期事件。\nspring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：\n\nspring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe\nspring:session:expirations:1439245080000\n\nspring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。\n\n接下来再看下RedisOperationsSessionRepository中的具体实现原理\n### createSession方法：\n```\npublic RedisSession createSession() {\n    // new一个RedisSession实例\n    RedisSession redisSession = new RedisSession();\n    // 如果设置的最大过期时间不为空，则设置RedisSession的过期时间\n    if (this.defaultMaxInactiveInterval != null) {\n        redisSession.setMaxInactiveIntervalInSeconds(this.defaultMaxInactiveInterval);\n    }\n    return redisSession;\n}\n\n```\n再来看下RedisSession的构造方法：\n```\n/**\n * Creates a new instance ensuring to mark all of the new attributes to be\n * persisted in the next save operation.\n */\nRedisSession() {\n    // 设置本地缓存为MapSession\n    this(new MapSession());\n    // 设置Session的基本属性\n    this.delta.put(CREATION_TIME_ATTR, getCreationTime());\n    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());\n    this.delta.put(LAST_ACCESSED_ATTR, getLastAccessedTime());\n    // 标记Session的是否为新创建\n    this.isNew = true;\n    // 持久化\n    flushImmediateIfNecessary();\n}\n\n```\n### save方法：\n```\npublic void save(RedisSession session) {\n    // 调用RedisSession的saveDelta持久化Session\n    session.saveDelta();\n    // 如果Session为新创建，则发布一个Session创建的事件\n    if (session.isNew()) {\n        String sessionCreatedKey = getSessionCreatedChannel(session.getId());\n        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);\n        session.setNew(false);\n    }\n}\n\n```\n### getSession方法：\n```\n// 根据SessionId获取Session，这里的false代表的参数\n// 指：如果Session已经过期，是否仍然获取返回\npublic RedisSession getSession(String id) {\n    return getSession(id, false);\n}\n```\n在有些情况下，Session过期，仍然需要能够获取到Session。这里先来看下getSession(String id, boolean allowExpired)：\n```\n\nprivate RedisSession getSession(String id, boolean allowExpired) {\n    // 根据SessionId，从Redis获取到持久化的Session信息\n    Map<Object, Object> entries = getSessionBoundHashOperations(id).entries();\n    // 如果Redis中没有，则返回null\n    if (entries.isEmpty()) {\n        return null;\n    }\n    // 根据Session信息，加载创建一个MapSession对象\n    MapSession loaded = loadSession(id, entries);\n    //  判断是否允许过期获取和Session是否过期\n    if (!allowExpired && loaded.isExpired()) {\n        return null;\n    }\n    // 根据MapSession new一个信息的RedisSession，此时isNew为false\n    RedisSession result = new RedisSession(loaded);\n    // 设置最新的访问时间\n    result.originalLastAccessTime = loaded.getLastAccessedTime();\n    return result;\n}\n```\n这里需要注意的是loaded.isExpired()和loadSession。loaded.isExpired判断Session是否过期，如果过期返回null：\n```\npublic boolean isExpired() {\n    // 根据当前时间判断是否过期\n    return isExpired(System.currentTimeMillis());\n}\nboolean isExpired(long now) {\n    // 如果maxInactiveInterval小于0，表示Session永不过期\n    if (this.maxInactiveInterval < 0) {\n        return false;\n    }\n    // 最大过期时间单位转换为毫秒\n    // 当前时间减去Session的最大有效期间隔以获取理论上有效的上一次访问时间\n    // 然后在与实际的上一次访问时间进行比较\n    // 如果大于，表示理论上的时间已经在实际的访问时间之后，那么表示Session已经过期\n    return now - TimeUnit.SECONDS\n            .toMillis(this.maxInactiveInterval) >= this.lastAccessedTime;\n}\n```\nloadSession中，将Redis中存储的Session信息转换为MapSession对象，以便从Session中获取属性时能够从内存直接获取提高性能：\n```\nprivate MapSession loadSession(String id, Map<Object, Object> entries) {\n    MapSession loaded = new MapSession(id);\n    for (Map.Entry<Object, Object> entry : entries.entrySet()) {\n        String key = (String) entry.getKey();\n        if (CREATION_TIME_ATTR.equals(key)) {\n            loaded.setCreationTime((Long) entry.getValue());\n        }\n        else if (MAX_INACTIVE_ATTR.equals(key)) {\n            loaded.setMaxInactiveIntervalInSeconds((Integer) entry.getValue());\n        }\n        else if (LAST_ACCESSED_ATTR.equals(key)) {\n            loaded.setLastAccessedTime((Long) entry.getValue());\n        }\n        else if (key.startsWith(SESSION_ATTR_PREFIX)) {\n            loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),\n                    entry.getValue());\n        }\n    }\n    return loaded;\n}\n```\n至此，可以看出spring-session中request.getSession(false)的过期实现原理。\n\n### delete方法：\n```\npublic void delete(String sessionId) {\n    // 获取Session\n    RedisSession session = getSession(sessionId, true);\n    if (session == null) {\n        return;\n    }\n    cleanupPrincipalIndex(session);\n    // 从过期集合中移除sessionId\n    this.expirationPolicy.onDelete(session);\n    String expireKey = getExpiredKey(session.getId());\n    // 删除session的过期键\n    this.sessionRedisOperations.delete(expireKey);\n    // 设置session过期\n    session.setMaxInactiveIntervalInSeconds(0);\n    save(session);\n}\n```\n至此RedisOperationsSessionRepository的核心原理就介绍完毕。但是RedisOperationsSessionRepository中还包括关于Session事件的处理和清理Session的定时任务。这部分内容在后述的SessionEvent部分介绍。\n\n##  HttpSessionStrategy\n从javadoc中可以看出，HttpSessionStrategy是建立Request/Response和Session之间的映射关系的策略。\n该策略接口中定义一套策略行为：\n```\n// 根据请求获取SessionId，即建立请求至Session的映射关系\nString getRequestedSessionId(HttpServletRequest request);\n// 对于新创建的Session，通知客户端\nvoid onNewSession(Session session, HttpServletRequest request,\n            HttpServletResponse response);\n// 对于session无效，通知客户端\nvoid onInvalidateSession(HttpServletRequest request, HttpServletResponse response);\n```\n如下UML类图：\n![springSesion模块](SpringSession源码/5.png)\n\n这里主要介绍CookieHttpSessionStrategy，这个也是默认的策略，可以查看spring-session中类SpringHttpSessionConfiguration，在注册SessionRepositoryFilter Bean时默认采用CookieHttpSessionStrategy：\n```\n@Bean\npublic <S extends ExpiringSession> SessionRepositoryFilter<? extends ExpiringSession> springSessionRepositoryFilter(\n        SessionRepository<S> sessionRepository) {\n    SessionRepositoryFilter<S> sessionRepositoryFilter = new SessionRepositoryFilter<S>(\n            sessionRepository);\n    sessionRepositoryFilter.setServletContext(this.servletContext);\n    if (this.httpSessionStrategy instanceof MultiHttpSessionStrategy) {\n        sessionRepositoryFilter.setHttpSessionStrategy(\n                (MultiHttpSessionStrategy) this.httpSessionStrategy);\n    }\n    else {\n        sessionRepositoryFilter.setHttpSessionStrategy(this.httpSessionStrategy);\n    }\n    return sessionRepositoryFilter;\n}\n```\n下面来分析CookieHttpSessionStrategy的原理。该策略使用Cookie来映射Request/Response至Session。即request/requset的head中cookie存储SessionId，当请求至web服务器，可以解析请求head中的cookie，然后获取sessionId，根据sessionId获取spring-session。当创建新的session或者session过期，将相应的sessionId写入response的set-cookie或者从respose中移除sessionId。\n### getRequestedSessionId方法\n```\npublic String getRequestedSessionId(HttpServletRequest request) {\n    // 获取当前请求的sessionId：session别名和sessionId映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取当前请求的Session别名\n    String sessionAlias = getCurrentSessionAlias(request);\n    // 获取相应别名的sessionId\n    return sessionIds.get(sessionAlias);\n}\n```\n接下来看下具体获取SessionIds的具体过程：\n```\npublic String getRequestedSessionId(HttpServletRequest request) {\n    // 获取当前请求的sessionId：session别名和sessionId映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取当前请求的Session别名\n    String sessionAlias = getCurrentSessionAlias(request);\n    // 获取相应别名的sessionId\n    return sessionIds.get(sessionAlias);\n}\n\n\npublic Map<String, String> getSessionIds(HttpServletRequest request) {\n    // 解析request中的cookie值\n    List<String> cookieValues = this.cookieSerializer.readCookieValues(request);\n    // 获取sessionId\n    String sessionCookieValue = cookieValues.isEmpty() ? \"\"\n            : cookieValues.iterator().next();\n    Map<String, String> result = new LinkedHashMap<String, String>();\n    // 根据分词器对sessionId进行分割，因为spring-session支持多session。默认情况只有一个session\n    StringTokenizer tokens = new StringTokenizer(sessionCookieValue, this.deserializationDelimiter);\n    // 如果只有一个session，则设置默认别名为0\n    if (tokens.countTokens() == 1) {\n        result.put(DEFAULT_ALIAS, tokens.nextToken());\n        return result;\n    }\n    // 如果有多个session，则建立别名和sessionId的映射\n    while (tokens.hasMoreTokens()) {\n        String alias = tokens.nextToken();\n        if (!tokens.hasMoreTokens()) {\n            break;\n        }\n        String id = tokens.nextToken();\n        result.put(alias, id);\n    }\n    return result;\n}\n\n\npublic List<String> readCookieValues(HttpServletRequest request) {\n    // 获取request的cookie\n    Cookie[] cookies = request.getCookies();\n    List<String> matchingCookieValues = new ArrayList<String>();\n    if (cookies != null) {\n        for (Cookie cookie : cookies) {\n            // 如果是以SESSION开头，则表示是SessionId，毕竟cookie不只有sessionId，还有可能存储其他内容\n            if (this.cookieName.equals(cookie.getName())) {\n                // 决策是否需要base64 decode\n                String sessionId = this.useBase64Encoding\n                        ? base64Decode(cookie.getValue()) : cookie.getValue();\n                if (sessionId == null) {\n                    continue;\n                }\n                if (this.jvmRoute != null && sessionId.endsWith(this.jvmRoute)) {\n                    sessionId = sessionId.substring(0,\n                            sessionId.length() - this.jvmRoute.length());\n                }\n                // 存入list中\n                matchingCookieValues.add(sessionId);\n            }\n        }\n    }\n    return matchingCookieValues;\n}\n```\n再来看下获取当前request对应的Session的别名方法getCurrentSessionAlias\n```\npublic String getCurrentSessionAlias(HttpServletRequest request) {\n    // 如果session参数为空，则返回默认session别名\n    if (this.sessionParam == null) {\n        return DEFAULT_ALIAS;\n    }\n    // 从request中获取session别名，如果为空则返回默认别名\n    String u = request.getParameter(this.sessionParam);\n    if (u == null) {\n        return DEFAULT_ALIAS;\n    }\n    if (!ALIAS_PATTERN.matcher(u).matches()) {\n        return DEFAULT_ALIAS;\n    }\n    return u;\n}\n```\nspring-session为了支持多session，才弄出多个session别名。当时一般应用场景都是一个session，都是默认的session别名0。\n\n上述获取sessionId和别名映射关系中，也是默认别名0。这里返回别名0，所以返回当前请求对应的sessionId。\n\n### onNewSession方法\n\n```\npublic void onNewSession(Session session, HttpServletRequest request,\n        HttpServletResponse response) {\n    // 从当前request中获取已经写入Cookie的sessionId集合\n    Set<String> sessionIdsWritten = getSessionIdsWritten(request);\n    // 判断是否包含，如果包含，表示该sessionId已经写入过cookie中，则直接返回\n    if (sessionIdsWritten.contains(session.getId())) {\n        return;\n    }\n    // 如果没有写入，则加入集合，后续再写入\n    sessionIdsWritten.add(session.getId());\n    Map<String, String> sessionIds = getSessionIds(request);\n    String sessionAlias = getCurrentSessionAlias(request);\n    sessionIds.put(sessionAlias, session.getId());\n    // 获取cookieValue\n    String cookieValue = createSessionCookieValue(sessionIds);\n    //将cookieValue写入Cookie中\n    this.cookieSerializer\n            .writeCookieValue(new CookieValue(request, response, cookieValue));\n}\n```\nsessionIdsWritten主要是用来记录已经写入Cookie的SessionId，防止SessionId重复写入Cookie中。\n\n### onInvalidateSession方法\n\n```\npublic void onInvalidateSession(HttpServletRequest request,\n        HttpServletResponse response) {\n    // 从当前request中获取sessionId和别名映射\n    Map<String, String> sessionIds = getSessionIds(request);\n    // 获取别名\n    String requestedAlias = getCurrentSessionAlias(request);\n    // 移除sessionId\n    sessionIds.remove(requestedAlias);\n    String cookieValue = createSessionCookieValue(sessionIds);\n    // 写入移除后的sessionId\n    this.cookieSerializer\n            .writeCookieValue(new CookieValue(request, response, cookieValue));\n}\n```\n继续看下具体的写入writeCookieValue原理：\n```\npublic void writeCookieValue(CookieValue cookieValue) {\n    // 获取request/respose和cookie值\n    HttpServletRequest request = cookieValue.getRequest();\n    HttpServletResponse response = cookieValue.getResponse();\n    String requestedCookieValue = cookieValue.getCookieValue();\n    String actualCookieValue = this.jvmRoute == null ? requestedCookieValue\n            : requestedCookieValue + this.jvmRoute;\n    // 构造servlet规范中的Cookie对象，注意这里cookieName为：SESSION，表示为Session，\n    // 上述的从Cookie中读取SessionId，也是使用该cookieName\n    Cookie sessionCookie = new Cookie(this.cookieName, this.useBase64Encoding\n            ? base64Encode(actualCookieValue) : actualCookieValue);\n    // 设置cookie的属性：secure、path、domain、httpOnly\n    sessionCookie.setSecure(isSecureCookie(request));\n    sessionCookie.setPath(getCookiePath(request));\n    String domainName = getDomainName(request);\n    if (domainName != null) {\n        sessionCookie.setDomain(domainName);\n    }\n    if (this.useHttpOnlyCookie) {\n        sessionCookie.setHttpOnly(true);\n    }\n    // 如果cookie值为空，则失效\n    if (\"\".equals(requestedCookieValue)) {\n        sessionCookie.setMaxAge(0);\n    }\n    else {\n        sessionCookie.setMaxAge(this.cookieMaxAge);\n    }\n    // 写入cookie到response中\n    response.addCookie(sessionCookie);\n}\n```\n\n至此，CookieHttpSessionStrategy介绍结束。\n\n由于篇幅过长，关于spring-session event和RedisOperationSessionRepository清理session并且产生过期事件的部分后续文章介绍。\n\n# 总结\nspring-session提供集群环境下HttpSession的透明集成。spring-session的优势在于开箱即用，具有较强的设计模式。且支持多种持久化方式，其中RedisSession较为成熟，与spring-data-redis整合，可谓威力无穷。","slug":"SpringSession源码","published":1,"updated":"2020-02-17T15:08:47.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce379000cn6zq491ohu9j","content":"<p><a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">可参考spring 引入 session代码</a></p>\n<p>再详细阅读源码之前先来看张图，介绍下spring-session中的核心模块以及之间的交互。<br><img src=\"/2019/11/21/SpringSession源码/2.png\" alt=\"springSesion模块\"></p>\n<h1 id=\"spring-session分为以下核心模块：\"><a href=\"#spring-session分为以下核心模块：\" class=\"headerlink\" title=\"spring-session分为以下核心模块：\"></a>spring-session分为以下核心模块：</h1><ul>\n<li>SessionRepositoryFilter：Servlet规范中Filter的实现，用来切换HttpSession至Spring Session，包装HttpServletRequest和HttpServletResponse</li>\n<li>HttpServerletRequest/HttpServletResponse/HttpSessionWrapper包装器：包装原有的HttpServletRequest、HttpServletResponse和Spring Session，实现切换Session和透明继承HttpSession的关键之所在</li>\n<li>Session：Spring Session模块</li>\n<li>SessionRepository：管理Spring Session的模块</li>\n<li>HttpSessionStrategy：映射HttpRequst和HttpResponse到Session的策略<h2 id=\"1-SessionRepositoryFilter\"><a href=\"#1-SessionRepositoryFilter\" class=\"headerlink\" title=\"1. SessionRepositoryFilter\"></a>1. SessionRepositoryFilter</h2>SessionRepositoryFilter是一个Filter过滤器，符合Servlet的规范定义，用来修改包装请求和响应。这里负责包装切换HttpSession至Spring Session的请求和响应。<br>SpringHttpSessionConfiguration 类定义SessionRepositoryFilter Bean,而在spring项目DelegatingFilterProxy代理装配SessionRepositoryFilter<a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">可参考spring 引入 session代码</a>，<br>而spring boot项目为何自动装配SessionRepositoryFilter 待补充)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void doFilterInternal(HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response, FilterChain filterChain)</span><br><span class=\"line\">                throws ServletException, IOException &#123;</span><br><span class=\"line\">    // 设置SessionRepository至Request的属性中</span><br><span class=\"line\">    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);</span><br><span class=\"line\">    // 包装原始HttpServletRequest至SessionRepositoryRequestWrapper</span><br><span class=\"line\">    SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(</span><br><span class=\"line\">            request, response, this.servletContext);</span><br><span class=\"line\">    // 包装原始HttpServletResponse响应至SessionRepositoryResponseWrapper</span><br><span class=\"line\">    SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(</span><br><span class=\"line\">            wrappedRequest, response);</span><br><span class=\"line\">    // 设置当前请求的HttpSessionStrategy策略</span><br><span class=\"line\">    HttpServletRequest strategyRequest = this.httpSessionStrategy</span><br><span class=\"line\">            .wrapRequest(wrappedRequest, wrappedResponse);</span><br><span class=\"line\">    // 设置当前响应的HttpSessionStrategy策略</span><br><span class=\"line\">    HttpServletResponse strategyResponse = this.httpSessionStrategy</span><br><span class=\"line\">            .wrapResponse(wrappedRequest, wrappedResponse);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        filterChain.doFilter(strategyRequest, strategyResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finally &#123;</span><br><span class=\"line\">        // 提交session</span><br><span class=\"line\">        wrappedRequest.commitSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上是SessionRepositoryFilter的核心操作，每个HttpRequest进入，都会被该Filter包装成切换Session的请求很响应对象。</p>\n<h2 id=\"SessionRepositoryRequestWrapper\"><a href=\"#SessionRepositoryRequestWrapper\" class=\"headerlink\" title=\"SessionRepositoryRequestWrapper\"></a>SessionRepositoryRequestWrapper</h2><p>对于developers获取HttpSession的api<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest request = ...;</span><br><span class=\"line\">HttpSession session = request.getSession(true);</span><br></pre></td></tr></table></figure></p>\n<p>在spring session中request的实际类型SessionRepositoryRequestWrapper。调用SessionRepositoryRequestWrapper的getSession方法会触发创建spring session，而非web容器的HttpSession。</p>\n<p>SessionRepositoryRequestWrapper用来包装原始的HttpServletRequest实现HttpSession切换至Spring Session。是透明Spring Session透明集成HttpSession的关键。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class SessionRepositoryRequestWrapper</span><br><span class=\"line\">            extends HttpServletRequestWrapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final String CURRENT_SESSION_ATTR = HttpServletRequestWrapper.class</span><br><span class=\"line\">                .getName();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当前请求sessionId有效</span><br><span class=\"line\">    private Boolean requestedSessionIdValid;</span><br><span class=\"line\">    // 当前请求sessionId无效</span><br><span class=\"line\">    private boolean requestedSessionInvalidated;</span><br><span class=\"line\">    private final HttpServletResponse response;</span><br><span class=\"line\">    private final ServletContext servletContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SessionRepositoryRequestWrapper(HttpServletRequest request,</span><br><span class=\"line\">            HttpServletResponse response, ServletContext servletContext) &#123;</span><br><span class=\"line\">        // 调用HttpServletRequestWrapper构造方法，实现包装</span><br><span class=\"line\">        super(request);</span><br><span class=\"line\">        this.response = response;</span><br><span class=\"line\">        this.servletContext = servletContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SessionRepositoryRequestWrapper继承Servlet规范中定义的包装器HttpServletRequestWrapper。HttpServletRequestWrapper是Servlet规范api提供的用于扩展HttpServletRequest的扩张点——即装饰器模式，可以通过重写一些api达到功能点的增强和自定义。</p>\n<p>HttpServletRequestWrapper中持有一个HttpServletRequest对象，然后实现HttpServletRequest接口的所有方法，所有方法实现中都是调用持有的HttpServletRequest对象的相应的方法。继承HttpServletRequestWrapper 可以对其重写。SessionRepositoryRequestWrapper继承HttpServletRequestWrapper，在构造方法中将原有的HttpServletRequest通过调用super完成对HttpServletRequestWrapper中持有的HttpServletRequest初始化赋值，然后重写和session相关的方法。这样就保证SessionRepositoryRequestWrapper的其他方法调用都是使用原有的HttpServletRequest的数据，只有session相关的是重写的逻辑。</p>\n<p>这里的设计是否很精妙！一切都多亏与Servlet规范设计的的巧妙啊！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public HttpSessionWrapper getSession() &#123;</span><br><span class=\"line\">    return getSession(true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重写HttpServletRequest的getSession()方法，调用有参数getSession(arg)方法，默认为true，表示当前reques没有session时创建session。继续看下有参数getSession(arg)的重写逻辑.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public HttpSessionWrapper getSession(boolean create) &#123;</span><br><span class=\"line\">    // 从当前请求的attribute中获取session，如果有直接返回</span><br><span class=\"line\">    HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class=\"line\">    if (currentSession != null) &#123;</span><br><span class=\"line\">        return currentSession;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前request的sessionId，这里使用了HttpSessionStrategy</span><br><span class=\"line\">    // 决定怎样将Request映射至Session，默认使用Cookie策略，即从cookies中解析sessionId</span><br><span class=\"line\">    String requestedSessionId = getRequestedSessionId();</span><br><span class=\"line\">    // 请求的如果sessionId存在且当前request的attribute中的没有session失效属性</span><br><span class=\"line\">    // 则根据sessionId获取spring session</span><br><span class=\"line\">    if (requestedSessionId != null</span><br><span class=\"line\">            &amp;&amp; getAttribute(INVALID_SESSION_ID_ATTR) == null) &#123;</span><br><span class=\"line\">        S session = getSession(requestedSessionId);</span><br><span class=\"line\">        // 如果spring session不为空，则将spring session包装成HttpSession并</span><br><span class=\"line\">        // 设置到当前Request的attribute中，防止同一个request getsession时频繁的到存储器</span><br><span class=\"line\">        //中获取session，提高性能</span><br><span class=\"line\">        if (session != null) &#123;</span><br><span class=\"line\">            this.requestedSessionIdValid = true;</span><br><span class=\"line\">            currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class=\"line\">            currentSession.setNew(false);</span><br><span class=\"line\">            setCurrentSession(currentSession);</span><br><span class=\"line\">            return currentSession;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果根据sessionId，没有获取到session，则设置当前request属性，此sessionId无效</span><br><span class=\"line\">        // 同一个请求中获取session，直接返回无效</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            // This is an invalid session id. No need to ask again if</span><br><span class=\"line\">            // request.getSession is invoked for the duration of this request</span><br><span class=\"line\">            if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                SESSION_LOGGER.debug(</span><br><span class=\"line\">                        &quot;No session found by id: Caching result for getSession(false) for this HttpServletRequest.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setAttribute(INVALID_SESSION_ID_ATTR, &quot;true&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断是否创建session</span><br><span class=\"line\">    if (!create) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">        SESSION_LOGGER.debug(</span><br><span class=\"line\">                &quot;A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for &quot;</span><br><span class=\"line\">                        + SESSION_LOGGER_NAME,</span><br><span class=\"line\">                new RuntimeException(</span><br><span class=\"line\">                        &quot;For debugging purposes only (not an error)&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据sessionRepository创建spring session</span><br><span class=\"line\">    S session = SessionRepositoryFilter.this.sessionRepository.createSession();</span><br><span class=\"line\">    // 设置session的最新访问时间</span><br><span class=\"line\">    session.setLastAccessedTime(System.currentTimeMillis());</span><br><span class=\"line\">    // 包装成HttpSession透明化集成</span><br><span class=\"line\">    currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class=\"line\">    // 设置session至Requset的attribute中，提高同一个request访问session的性能</span><br><span class=\"line\">    setCurrentSession(currentSession);</span><br><span class=\"line\">    return currentSession;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看下spring session的持久化。上述SessionRepositoryFilter在包装HttpServletRequest后，执行FilterChain中使用finally保证请求的Session始终session会被提交，此提交操作中将sesionId设置到response的head中并将session持久化至存储器中。</p>\n<p>持久化只持久spring session，并不是将spring session包装后的HttpSession持久化，因为HttpSession不过是包装器，持久化没有意义。</p>\n<p>再来看下包装的响应SessionRepositoryResponseWrapper。</p>\n<h2 id=\"SessionRepositoryResponseWrapper\"><a href=\"#SessionRepositoryResponseWrapper\" class=\"headerlink\" title=\"SessionRepositoryResponseWrapper\"></a>SessionRepositoryResponseWrapper</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows ensuring that the session is saved if the response is committed.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final class SessionRepositoryResponseWrapper</span><br><span class=\"line\">        extends OnCommittedResponseWrapper &#123;</span><br><span class=\"line\">    private final SessionRepositoryRequestWrapper request;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create a new &#123;@link SessionRepositoryResponseWrapper&#125;.</span><br><span class=\"line\">     * @param request the request to be wrapped</span><br><span class=\"line\">     * @param response the response to be wrapped</span><br><span class=\"line\">     */</span><br><span class=\"line\">    SessionRepositoryResponseWrapper(SessionRepositoryRequestWrapper request,</span><br><span class=\"line\">            HttpServletResponse response) &#123;</span><br><span class=\"line\">        super(response);</span><br><span class=\"line\">        if (request == null) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;request cannot be null&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.request = request;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResponseCommitted() &#123;</span><br><span class=\"line\">        this.request.commitSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释已经非常详细，这里不再赘述。这里只讲述为什么需要包装原始的响应。从注释上可以看出包装响应时为了：确保如果响应被提交session能够被保存。</p>\n<p>这里我有点疑惑：在上述的SessionRepositoryFilter.doFilterInternal方法中不是已经request.commitSession()了吗，FilterChain执行完或者异常后都会执行Finally中的request.commitSession。为什么这里仍然需要包装响应，为了确保session能够保存，包装器中的onResponseCommitted方法可以看出也是做了一次request.commitSession()</p>\n<p>原因：一旦response执行flushBuffer方法，迫使Response中在Buffer中任何数据都会被返回至client端。这个方法自动提交响应中的status code和head。那么如果不包装请求，监听flushBuffer事件在提交response前，将session写入response和持久化session，将导致作者说的无法追踪session。（来源网上）</p>\n<p>SessionRepositoryResponseWrapper继承父类OnCommittedResponseWrapper，其中flushBuffer方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Makes sure &#123;@link OnCommittedResponseWrapper#onResponseCommitted()&#125; is invoked</span><br><span class=\"line\"> * before calling the superclass &lt;code&gt;flushBuffer()&lt;/code&gt;.</span><br><span class=\"line\"> * @throws IOException if an input or output exception occurred</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void flushBuffer() throws IOException &#123;</span><br><span class=\"line\">    doOnResponseCommitted();</span><br><span class=\"line\">    super.flushBuffer();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Calls &lt;code&gt;onResponseCommmitted()&lt;/code&gt; with the current contents as long as</span><br><span class=\"line\"> * &#123;@link #disableOnResponseCommitted()&#125; was not invoked.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void doOnResponseCommitted() &#123;</span><br><span class=\"line\">    if (!this.disableOnCommitted) &#123;</span><br><span class=\"line\">        onResponseCommitted();</span><br><span class=\"line\">        disableOnResponseCommitted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重写HttpServletResponse方法，监听response commit，当发生response commit时，可以在commit之前写session至response中并持久化session</p>\n<p>再看SessionRepository之前，先来看下spring session中的session接口。</p>\n<h2 id=\"Session接口\"><a href=\"#Session接口\" class=\"headerlink\" title=\"Session接口\"></a>Session接口</h2><p>spring-session和tomcat中的Session的实现模式上有很大不同，tomcat中直接对HttpSession接口进行实现，而spring-session中则抽象出单独的Session层接口，让后再使用适配器模式将Session适配层Servlet规范中的HttpSession。spring-sesion中关于session的实现和适配整个UML类图如下：</p>\n<p><img src=\"/2019/11/21/SpringSession源码/3.png\" alt=\"springSesion模块\"></p>\n<p>Session是spring-session对session的抽象，主要是为了鉴定用户，为Http请求和响应提供上下文过程，该Session可以被HttpSession、WebSocket Session，非WebSession等使用。定义了Session的基本行为：</p>\n<ul>\n<li>getId：获取sessionId</li>\n<li>setAttribute：设置session属性</li>\n<li>getAttribte：获取session属性</li>\n</ul>\n<p>ExipringSession：提供Session额外的过期特性。定义了以下关于过期的行为：</p>\n<ul>\n<li>setLastAccessedTime：设置最近Session会话过程中最近的访问时间</li>\n<li>getLastAccessedTime：获取最近的访问时间</li>\n<li>setMaxInactiveIntervalInSeconds：设置Session的最大闲置时间</li>\n<li>getMaxInactiveIntervalInSeconds：获取最大闲置时间</li>\n<li>isExpired：判断Session是否过期</li>\n</ul>\n<p>MapSession：基于java.util.Map的ExpiringSession的实现</p>\n<p>RedisSession：基于MapSession和Redis的ExpiringSession实现，提供Session的持久化能力</p>\n<p>先来看下MapSession的代码源码片段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class MapSession implements ExpiringSession, Serializable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Default &#123;@link #setMaxInactiveIntervalInSeconds(int)&#125; (30 minutes).</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static final int DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS = 1800;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private Map&lt;String, Object&gt; sessionAttrs = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">    private long creationTime = System.currentTimeMillis();</span><br><span class=\"line\">    private long lastAccessedTime = this.creationTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Defaults to 30 minutes.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int maxInactiveInterval = DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS;</span><br></pre></td></tr></table></figure></p>\n<p>MapSession中持有HashMap类型的变量sessionAtts用于存储Session设置属性，比如调用的setAttribute方法的k-v就存储在该HashMap中。这个和tomcat内部实现HttpSession的方式类似，tomcat中使用了ConcurrentHashMap存储。</p>\n<p>其中lastAccessedTime用于记录最近的一次访问时间，maxInactiveInterval用于记录Session的最大闲置时间（过期时间-针对没有Request活跃的情况下的最大时间，即相对于最近一次访问后的最大闲置时间）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setAttribute(String attributeName, Object attributeValue) &#123;</span><br><span class=\"line\">    if (attributeValue == null) &#123;</span><br><span class=\"line\">        removeAttribute(attributeName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        this.sessionAttrs.put(attributeName, attributeValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>setAttribute方法极其简单，null时就移除attributeName，否则put存储。</p>\n<p>重点熟悉RedisSession如何实现Session的行为：setAttribute、persistence等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * A custom implementation of &#123;@link Session&#125; that uses a &#123;@link MapSession&#125; as the</span><br><span class=\"line\"> * basis for its mapping. It keeps track of any attributes that have changed. When</span><br><span class=\"line\"> * &#123;@link org.springframework.session.data.redis.RedisOperationsSessionRepository.RedisSession#saveDelta()&#125;</span><br><span class=\"line\"> * is invoked all the attributes that have been changed will be persisted.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">final class RedisSession implements ExpiringSession &#123;</span><br><span class=\"line\">    private final MapSession cached;</span><br><span class=\"line\">    private Long originalLastAccessTime;</span><br><span class=\"line\">    private Map&lt;String, Object&gt; delta = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">    private boolean isNew;</span><br><span class=\"line\">    private String originalPrincipalName;</span><br></pre></td></tr></table></figure></p>\n<p>首先看javadocs，对于阅读源码，学会看javadocs非常重要！</p>\n<p>基于MapSession的基本映射实现的Session，能够追踪发生变化的所有属性，当调用saveDelta方法后，变化的属性将被持久化！</p>\n<p>在RedisSession中有两个非常重要的成员属性：</p>\n<ul>\n<li>cached：实际上是一个MapSession实例，用于做本地缓存，每次在getAttribute时无需从Redis中获取，主要为了improve性能</li>\n<li>delta：用于跟踪变化数据，做持久化<br>再来看下RedisSession中最为重要的行为saveDelta——持久化Session至Redis中：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Saves any attributes that have been changed and updates the expiration of this</span><br><span class=\"line\"> * session.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void saveDelta() &#123;</span><br><span class=\"line\">    // 如果delta为空，则Session中没有任何数据需要存储</span><br><span class=\"line\">    if (this.delta.isEmpty()) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String sessionId = getId();</span><br><span class=\"line\">    // 使用spring data redis将delta中的数据保存至Redis中</span><br><span class=\"line\">    getSessionBoundHashOperations(sessionId).putAll(this.delta);</span><br><span class=\"line\">    String principalSessionKey = getSessionAttrNameKey(</span><br><span class=\"line\">            FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME);</span><br><span class=\"line\">    String securityPrincipalSessionKey = getSessionAttrNameKey(</span><br><span class=\"line\">            SPRING_SECURITY_CONTEXT);</span><br><span class=\"line\">    if (this.delta.containsKey(principalSessionKey)</span><br><span class=\"line\">            || this.delta.containsKey(securityPrincipalSessionKey)) &#123;</span><br><span class=\"line\">        if (this.originalPrincipalName != null) &#123;</span><br><span class=\"line\">            String originalPrincipalRedisKey = getPrincipalKey(</span><br><span class=\"line\">                    this.originalPrincipalName);</span><br><span class=\"line\">            RedisOperationsSessionRepository.this.sessionRedisOperations</span><br><span class=\"line\">                    .boundSetOps(originalPrincipalRedisKey).remove(sessionId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String principal = PRINCIPAL_NAME_RESOLVER.resolvePrincipal(this);</span><br><span class=\"line\">        this.originalPrincipalName = principal;</span><br><span class=\"line\">        if (principal != null) &#123;</span><br><span class=\"line\">            String principalRedisKey = getPrincipalKey(principal);</span><br><span class=\"line\">            RedisOperationsSessionRepository.this.sessionRedisOperations</span><br><span class=\"line\">                    .boundSetOps(principalRedisKey).add(sessionId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    // 清空delta，代表没有任何需要持久化的数据。同时保证</span><br><span class=\"line\">    //SessionRepositoryFilter和SessionRepositoryResponseWrapper的onResponseCommitted</span><br><span class=\"line\">    //只会持久化一次Session至Redis中，解决前面提到的疑问</span><br><span class=\"line\">    this.delta = new HashMap&lt;String, Object&gt;(this.delta.size());  </span><br><span class=\"line\">    // 更新过期时间，滚动至下一个过期时间间隔的时刻</span><br><span class=\"line\">    Long originalExpiration = this.originalLastAccessTime == null ? null</span><br><span class=\"line\">            : this.originalLastAccessTime + TimeUnit.SECONDS</span><br><span class=\"line\">                    .toMillis(getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    RedisOperationsSessionRepository.this.expirationPolicy</span><br><span class=\"line\">            .onExpirationUpdated(originalExpiration, this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从javadoc中可以看出，saveDelta用于存储Session的属性：</p>\n<ul>\n<li>保存Session中的属性数据至Redis中</li>\n<li>清空delta中数据，防止重复提交Session中的数据</li>\n<li>更新过期时间至下一个过期时间间隔的时刻</li>\n</ul>\n<p>再看下RedisSession中的其他行为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置session的存活时间，即最大过期时间。先保存至本地缓存，然后再保存至delta</span><br><span class=\"line\">public void setMaxInactiveIntervalInSeconds(int interval) &#123;</span><br><span class=\"line\">    this.cached.setMaxInactiveIntervalInSeconds(interval);</span><br><span class=\"line\">    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接从本地缓存获取过期时间</span><br><span class=\"line\">public int getMaxInactiveIntervalInSeconds() &#123;</span><br><span class=\"line\">    return this.cached.getMaxInactiveIntervalInSeconds();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接从本地缓存中获取Session中的属性</span><br><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public Object getAttribute(String attributeName) &#123;</span><br><span class=\"line\">    return this.cached.getAttribute(attributeName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 保存Session属性至本地缓存和delta中</span><br><span class=\"line\">public void setAttribute(String attributeName, Object attributeValue) &#123;</span><br><span class=\"line\">    this.cached.setAttribute(attributeName, attributeValue);</span><br><span class=\"line\">    this.delta.put(getSessionAttrNameKey(attributeName), attributeValue);</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了MapSession和RedisSession还有JdbcSession、MongoExpiringSession，感兴趣的读者可以自行阅读。</p>\n<p>下面看SessionRepository的逻辑。SessionRepository是spring session中用于管理spring session的核心组件。</p>\n<h2 id=\"SessionRepository\"><a href=\"#SessionRepository\" class=\"headerlink\" title=\"SessionRepository\"></a>SessionRepository</h2><p>javadoc中描述SessionRepository为管理spring-session的接口实例。抽象出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S createSession();</span><br><span class=\"line\">void save(S session);</span><br><span class=\"line\">S getSession(String id);</span><br><span class=\"line\">void delete(String id);</span><br></pre></td></tr></table></figure></p>\n<p>创建、保存、获取、删除Session的接口行为。根据Session的不同，分为很多种Session操作仓库。<br><img src=\"/2019/11/21/SpringSession源码/4.png\" alt=\"springSesion模块\"></p>\n<p>这里重点介绍下RedisOperationsSessionRepository。在详细介绍其之前，了解下RedisOperationsSessionRepository的数据存储细节。</p>\n<p>当创建一个RedisSession，然后存储在Redis中时，RedisSession的存储细节如下：</p>\n<p>spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:expirations:1439245080000</p>\n<p>Redis会为每个RedisSession存储三个k-v。</p>\n<ul>\n<li>第一个k-v用来存储Session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等。这个k的过期时间为Session的最大过期时间 + 5分钟。如果默认的最大过期时间为30分钟，则这个k的过期时间为35分钟</li>\n<li>第二个k-v用来表示Session在Redis中的过期，这个k-v不存储任何有用数据，只是表示Session过期而设置。这个k在Redis中的过期时间即为Session的过期时间间隔</li>\n<li>第三个k-v存储这个Session的id，是一个Set类型的Redis数据结构。这个k中的最后的1439245080000值是一个时间戳，根据这个Session过期时刻滚动至下一分钟而计算得出。<br>简单描述下，为什么RedisSession的存储用到了三个Key，而非一个Redis过期Key。<br>对于Session的实现，需要支持HttpSessionEvent，即Session创建、过期、销毁等事件。当应用用监听器设置监听相应事件，Session发生上述行为时，监听器能够做出相应的处理。<br>Redis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。</li>\n</ul>\n<p>但是Redis中带有过期的key有两种方式：</p>\n<ul>\n<li>当访问时发现其过期</li>\n<li>Redis后台逐步查找过期键<br>当访问时发现其过期，会产生过期事件，但是无法保证key的过期时间抵达后立即生成过期事件。<br>spring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：</li>\n</ul>\n<p>spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:expirations:1439245080000</p>\n<p>spring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。</p>\n<p>接下来再看下RedisOperationsSessionRepository中的具体实现原理</p>\n<h3 id=\"createSession方法：\"><a href=\"#createSession方法：\" class=\"headerlink\" title=\"createSession方法：\"></a>createSession方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RedisSession createSession() &#123;</span><br><span class=\"line\">    // new一个RedisSession实例</span><br><span class=\"line\">    RedisSession redisSession = new RedisSession();</span><br><span class=\"line\">    // 如果设置的最大过期时间不为空，则设置RedisSession的过期时间</span><br><span class=\"line\">    if (this.defaultMaxInactiveInterval != null) &#123;</span><br><span class=\"line\">        redisSession.setMaxInactiveIntervalInSeconds(this.defaultMaxInactiveInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return redisSession;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看下RedisSession的构造方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Creates a new instance ensuring to mark all of the new attributes to be</span><br><span class=\"line\"> * persisted in the next save operation.</span><br><span class=\"line\"> */</span><br><span class=\"line\">RedisSession() &#123;</span><br><span class=\"line\">    // 设置本地缓存为MapSession</span><br><span class=\"line\">    this(new MapSession());</span><br><span class=\"line\">    // 设置Session的基本属性</span><br><span class=\"line\">    this.delta.put(CREATION_TIME_ATTR, getCreationTime());</span><br><span class=\"line\">    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    this.delta.put(LAST_ACCESSED_ATTR, getLastAccessedTime());</span><br><span class=\"line\">    // 标记Session的是否为新创建</span><br><span class=\"line\">    this.isNew = true;</span><br><span class=\"line\">    // 持久化</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"save方法：\"><a href=\"#save方法：\" class=\"headerlink\" title=\"save方法：\"></a>save方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(RedisSession session) &#123;</span><br><span class=\"line\">    // 调用RedisSession的saveDelta持久化Session</span><br><span class=\"line\">    session.saveDelta();</span><br><span class=\"line\">    // 如果Session为新创建，则发布一个Session创建的事件</span><br><span class=\"line\">    if (session.isNew()) &#123;</span><br><span class=\"line\">        String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class=\"line\">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class=\"line\">        session.setNew(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getSession方法：\"><a href=\"#getSession方法：\" class=\"headerlink\" title=\"getSession方法：\"></a>getSession方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据SessionId获取Session，这里的false代表的参数</span><br><span class=\"line\">// 指：如果Session已经过期，是否仍然获取返回</span><br><span class=\"line\">public RedisSession getSession(String id) &#123;</span><br><span class=\"line\">    return getSession(id, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在有些情况下，Session过期，仍然需要能够获取到Session。这里先来看下getSession(String id, boolean allowExpired)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private RedisSession getSession(String id, boolean allowExpired) &#123;</span><br><span class=\"line\">    // 根据SessionId，从Redis获取到持久化的Session信息</span><br><span class=\"line\">    Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class=\"line\">    // 如果Redis中没有，则返回null</span><br><span class=\"line\">    if (entries.isEmpty()) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据Session信息，加载创建一个MapSession对象</span><br><span class=\"line\">    MapSession loaded = loadSession(id, entries);</span><br><span class=\"line\">    //  判断是否允许过期获取和Session是否过期</span><br><span class=\"line\">    if (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据MapSession new一个信息的RedisSession，此时isNew为false</span><br><span class=\"line\">    RedisSession result = new RedisSession(loaded);</span><br><span class=\"line\">    // 设置最新的访问时间</span><br><span class=\"line\">    result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是loaded.isExpired()和loadSession。loaded.isExpired判断Session是否过期，如果过期返回null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isExpired() &#123;</span><br><span class=\"line\">    // 根据当前时间判断是否过期</span><br><span class=\"line\">    return isExpired(System.currentTimeMillis());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">boolean isExpired(long now) &#123;</span><br><span class=\"line\">    // 如果maxInactiveInterval小于0，表示Session永不过期</span><br><span class=\"line\">    if (this.maxInactiveInterval &lt; 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 最大过期时间单位转换为毫秒</span><br><span class=\"line\">    // 当前时间减去Session的最大有效期间隔以获取理论上有效的上一次访问时间</span><br><span class=\"line\">    // 然后在与实际的上一次访问时间进行比较</span><br><span class=\"line\">    // 如果大于，表示理论上的时间已经在实际的访问时间之后，那么表示Session已经过期</span><br><span class=\"line\">    return now - TimeUnit.SECONDS</span><br><span class=\"line\">            .toMillis(this.maxInactiveInterval) &gt;= this.lastAccessedTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>loadSession中，将Redis中存储的Session信息转换为MapSession对象，以便从Session中获取属性时能够从内存直接获取提高性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private MapSession loadSession(String id, Map&lt;Object, Object&gt; entries) &#123;</span><br><span class=\"line\">    MapSession loaded = new MapSession(id);</span><br><span class=\"line\">    for (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class=\"line\">        String key = (String) entry.getKey();</span><br><span class=\"line\">        if (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setCreationTime((Long) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setMaxInactiveIntervalInSeconds((Integer) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setLastAccessedTime((Long) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class=\"line\">            loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class=\"line\">                    entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return loaded;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，可以看出spring-session中request.getSession(false)的过期实现原理。</p>\n<h3 id=\"delete方法：\"><a href=\"#delete方法：\" class=\"headerlink\" title=\"delete方法：\"></a>delete方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void delete(String sessionId) &#123;</span><br><span class=\"line\">    // 获取Session</span><br><span class=\"line\">    RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\">    if (session == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cleanupPrincipalIndex(session);</span><br><span class=\"line\">    // 从过期集合中移除sessionId</span><br><span class=\"line\">    this.expirationPolicy.onDelete(session);</span><br><span class=\"line\">    String expireKey = getExpiredKey(session.getId());</span><br><span class=\"line\">    // 删除session的过期键</span><br><span class=\"line\">    this.sessionRedisOperations.delete(expireKey);</span><br><span class=\"line\">    // 设置session过期</span><br><span class=\"line\">    session.setMaxInactiveIntervalInSeconds(0);</span><br><span class=\"line\">    save(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此RedisOperationsSessionRepository的核心原理就介绍完毕。但是RedisOperationsSessionRepository中还包括关于Session事件的处理和清理Session的定时任务。这部分内容在后述的SessionEvent部分介绍。</p>\n<h2 id=\"HttpSessionStrategy\"><a href=\"#HttpSessionStrategy\" class=\"headerlink\" title=\"HttpSessionStrategy\"></a>HttpSessionStrategy</h2><p>从javadoc中可以看出，HttpSessionStrategy是建立Request/Response和Session之间的映射关系的策略。<br>该策略接口中定义一套策略行为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据请求获取SessionId，即建立请求至Session的映射关系</span><br><span class=\"line\">String getRequestedSessionId(HttpServletRequest request);</span><br><span class=\"line\">// 对于新创建的Session，通知客户端</span><br><span class=\"line\">void onNewSession(Session session, HttpServletRequest request,</span><br><span class=\"line\">            HttpServletResponse response);</span><br><span class=\"line\">// 对于session无效，通知客户端</span><br><span class=\"line\">void onInvalidateSession(HttpServletRequest request, HttpServletResponse response);</span><br></pre></td></tr></table></figure></p>\n<p>如下UML类图：<br><img src=\"/2019/11/21/SpringSession源码/5.png\" alt=\"springSesion模块\"></p>\n<p>这里主要介绍CookieHttpSessionStrategy，这个也是默认的策略，可以查看spring-session中类SpringHttpSessionConfiguration，在注册SessionRepositoryFilter Bean时默认采用CookieHttpSessionStrategy：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public &lt;S extends ExpiringSession&gt; SessionRepositoryFilter&lt;? extends ExpiringSession&gt; springSessionRepositoryFilter(</span><br><span class=\"line\">        SessionRepository&lt;S&gt; sessionRepository) &#123;</span><br><span class=\"line\">    SessionRepositoryFilter&lt;S&gt; sessionRepositoryFilter = new SessionRepositoryFilter&lt;S&gt;(</span><br><span class=\"line\">            sessionRepository);</span><br><span class=\"line\">    sessionRepositoryFilter.setServletContext(this.servletContext);</span><br><span class=\"line\">    if (this.httpSessionStrategy instanceof MultiHttpSessionStrategy) &#123;</span><br><span class=\"line\">        sessionRepositoryFilter.setHttpSessionStrategy(</span><br><span class=\"line\">                (MultiHttpSessionStrategy) this.httpSessionStrategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        sessionRepositoryFilter.setHttpSessionStrategy(this.httpSessionStrategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sessionRepositoryFilter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面来分析CookieHttpSessionStrategy的原理。该策略使用Cookie来映射Request/Response至Session。即request/requset的head中cookie存储SessionId，当请求至web服务器，可以解析请求head中的cookie，然后获取sessionId，根据sessionId获取spring-session。当创建新的session或者session过期，将相应的sessionId写入response的set-cookie或者从respose中移除sessionId。</p>\n<h3 id=\"getRequestedSessionId方法\"><a href=\"#getRequestedSessionId方法\" class=\"headerlink\" title=\"getRequestedSessionId方法\"></a>getRequestedSessionId方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getRequestedSessionId(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取当前请求的sessionId：session别名和sessionId映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取当前请求的Session别名</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 获取相应别名的sessionId</span><br><span class=\"line\">    return sessionIds.get(sessionAlias);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来看下具体获取SessionIds的具体过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getRequestedSessionId(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取当前请求的sessionId：session别名和sessionId映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取当前请求的Session别名</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 获取相应别名的sessionId</span><br><span class=\"line\">    return sessionIds.get(sessionAlias);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public Map&lt;String, String&gt; getSessionIds(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 解析request中的cookie值</span><br><span class=\"line\">    List&lt;String&gt; cookieValues = this.cookieSerializer.readCookieValues(request);</span><br><span class=\"line\">    // 获取sessionId</span><br><span class=\"line\">    String sessionCookieValue = cookieValues.isEmpty() ? &quot;&quot;</span><br><span class=\"line\">            : cookieValues.iterator().next();</span><br><span class=\"line\">    Map&lt;String, String&gt; result = new LinkedHashMap&lt;String, String&gt;();</span><br><span class=\"line\">    // 根据分词器对sessionId进行分割，因为spring-session支持多session。默认情况只有一个session</span><br><span class=\"line\">    StringTokenizer tokens = new StringTokenizer(sessionCookieValue, this.deserializationDelimiter);</span><br><span class=\"line\">    // 如果只有一个session，则设置默认别名为0</span><br><span class=\"line\">    if (tokens.countTokens() == 1) &#123;</span><br><span class=\"line\">        result.put(DEFAULT_ALIAS, tokens.nextToken());</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果有多个session，则建立别名和sessionId的映射</span><br><span class=\"line\">    while (tokens.hasMoreTokens()) &#123;</span><br><span class=\"line\">        String alias = tokens.nextToken();</span><br><span class=\"line\">        if (!tokens.hasMoreTokens()) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String id = tokens.nextToken();</span><br><span class=\"line\">        result.put(alias, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public List&lt;String&gt; readCookieValues(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取request的cookie</span><br><span class=\"line\">    Cookie[] cookies = request.getCookies();</span><br><span class=\"line\">    List&lt;String&gt; matchingCookieValues = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">    if (cookies != null) &#123;</span><br><span class=\"line\">        for (Cookie cookie : cookies) &#123;</span><br><span class=\"line\">            // 如果是以SESSION开头，则表示是SessionId，毕竟cookie不只有sessionId，还有可能存储其他内容</span><br><span class=\"line\">            if (this.cookieName.equals(cookie.getName())) &#123;</span><br><span class=\"line\">                // 决策是否需要base64 decode</span><br><span class=\"line\">                String sessionId = this.useBase64Encoding</span><br><span class=\"line\">                        ? base64Decode(cookie.getValue()) : cookie.getValue();</span><br><span class=\"line\">                if (sessionId == null) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (this.jvmRoute != null &amp;&amp; sessionId.endsWith(this.jvmRoute)) &#123;</span><br><span class=\"line\">                    sessionId = sessionId.substring(0,</span><br><span class=\"line\">                            sessionId.length() - this.jvmRoute.length());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 存入list中</span><br><span class=\"line\">                matchingCookieValues.add(sessionId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return matchingCookieValues;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看下获取当前request对应的Session的别名方法getCurrentSessionAlias<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getCurrentSessionAlias(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 如果session参数为空，则返回默认session别名</span><br><span class=\"line\">    if (this.sessionParam == null) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 从request中获取session别名，如果为空则返回默认别名</span><br><span class=\"line\">    String u = request.getParameter(this.sessionParam);</span><br><span class=\"line\">    if (u == null) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!ALIAS_PATTERN.matcher(u).matches()) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>spring-session为了支持多session，才弄出多个session别名。当时一般应用场景都是一个session，都是默认的session别名0。</p>\n<p>上述获取sessionId和别名映射关系中，也是默认别名0。这里返回别名0，所以返回当前请求对应的sessionId。</p>\n<h3 id=\"onNewSession方法\"><a href=\"#onNewSession方法\" class=\"headerlink\" title=\"onNewSession方法\"></a>onNewSession方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onNewSession(Session session, HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response) &#123;</span><br><span class=\"line\">    // 从当前request中获取已经写入Cookie的sessionId集合</span><br><span class=\"line\">    Set&lt;String&gt; sessionIdsWritten = getSessionIdsWritten(request);</span><br><span class=\"line\">    // 判断是否包含，如果包含，表示该sessionId已经写入过cookie中，则直接返回</span><br><span class=\"line\">    if (sessionIdsWritten.contains(session.getId())) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果没有写入，则加入集合，后续再写入</span><br><span class=\"line\">    sessionIdsWritten.add(session.getId());</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    sessionIds.put(sessionAlias, session.getId());</span><br><span class=\"line\">    // 获取cookieValue</span><br><span class=\"line\">    String cookieValue = createSessionCookieValue(sessionIds);</span><br><span class=\"line\">    //将cookieValue写入Cookie中</span><br><span class=\"line\">    this.cookieSerializer</span><br><span class=\"line\">            .writeCookieValue(new CookieValue(request, response, cookieValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sessionIdsWritten主要是用来记录已经写入Cookie的SessionId，防止SessionId重复写入Cookie中。</p>\n<h3 id=\"onInvalidateSession方法\"><a href=\"#onInvalidateSession方法\" class=\"headerlink\" title=\"onInvalidateSession方法\"></a>onInvalidateSession方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onInvalidateSession(HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response) &#123;</span><br><span class=\"line\">    // 从当前request中获取sessionId和别名映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取别名</span><br><span class=\"line\">    String requestedAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 移除sessionId</span><br><span class=\"line\">    sessionIds.remove(requestedAlias);</span><br><span class=\"line\">    String cookieValue = createSessionCookieValue(sessionIds);</span><br><span class=\"line\">    // 写入移除后的sessionId</span><br><span class=\"line\">    this.cookieSerializer</span><br><span class=\"line\">            .writeCookieValue(new CookieValue(request, response, cookieValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看下具体的写入writeCookieValue原理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void writeCookieValue(CookieValue cookieValue) &#123;</span><br><span class=\"line\">    // 获取request/respose和cookie值</span><br><span class=\"line\">    HttpServletRequest request = cookieValue.getRequest();</span><br><span class=\"line\">    HttpServletResponse response = cookieValue.getResponse();</span><br><span class=\"line\">    String requestedCookieValue = cookieValue.getCookieValue();</span><br><span class=\"line\">    String actualCookieValue = this.jvmRoute == null ? requestedCookieValue</span><br><span class=\"line\">            : requestedCookieValue + this.jvmRoute;</span><br><span class=\"line\">    // 构造servlet规范中的Cookie对象，注意这里cookieName为：SESSION，表示为Session，</span><br><span class=\"line\">    // 上述的从Cookie中读取SessionId，也是使用该cookieName</span><br><span class=\"line\">    Cookie sessionCookie = new Cookie(this.cookieName, this.useBase64Encoding</span><br><span class=\"line\">            ? base64Encode(actualCookieValue) : actualCookieValue);</span><br><span class=\"line\">    // 设置cookie的属性：secure、path、domain、httpOnly</span><br><span class=\"line\">    sessionCookie.setSecure(isSecureCookie(request));</span><br><span class=\"line\">    sessionCookie.setPath(getCookiePath(request));</span><br><span class=\"line\">    String domainName = getDomainName(request);</span><br><span class=\"line\">    if (domainName != null) &#123;</span><br><span class=\"line\">        sessionCookie.setDomain(domainName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.useHttpOnlyCookie) &#123;</span><br><span class=\"line\">        sessionCookie.setHttpOnly(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果cookie值为空，则失效</span><br><span class=\"line\">    if (&quot;&quot;.equals(requestedCookieValue)) &#123;</span><br><span class=\"line\">        sessionCookie.setMaxAge(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        sessionCookie.setMaxAge(this.cookieMaxAge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 写入cookie到response中</span><br><span class=\"line\">    response.addCookie(sessionCookie);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，CookieHttpSessionStrategy介绍结束。</p>\n<p>由于篇幅过长，关于spring-session event和RedisOperationSessionRepository清理session并且产生过期事件的部分后续文章介绍。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>spring-session提供集群环境下HttpSession的透明集成。spring-session的优势在于开箱即用，具有较强的设计模式。且支持多种持久化方式，其中RedisSession较为成熟，与spring-data-redis整合，可谓威力无穷。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">可参考spring 引入 session代码</a></p>\n<p>再详细阅读源码之前先来看张图，介绍下spring-session中的核心模块以及之间的交互。<br><img src=\"/2019/11/21/SpringSession源码/2.png\" alt=\"springSesion模块\"></p>\n<h1 id=\"spring-session分为以下核心模块：\"><a href=\"#spring-session分为以下核心模块：\" class=\"headerlink\" title=\"spring-session分为以下核心模块：\"></a>spring-session分为以下核心模块：</h1><ul>\n<li>SessionRepositoryFilter：Servlet规范中Filter的实现，用来切换HttpSession至Spring Session，包装HttpServletRequest和HttpServletResponse</li>\n<li>HttpServerletRequest/HttpServletResponse/HttpSessionWrapper包装器：包装原有的HttpServletRequest、HttpServletResponse和Spring Session，实现切换Session和透明继承HttpSession的关键之所在</li>\n<li>Session：Spring Session模块</li>\n<li>SessionRepository：管理Spring Session的模块</li>\n<li>HttpSessionStrategy：映射HttpRequst和HttpResponse到Session的策略<h2 id=\"1-SessionRepositoryFilter\"><a href=\"#1-SessionRepositoryFilter\" class=\"headerlink\" title=\"1. SessionRepositoryFilter\"></a>1. SessionRepositoryFilter</h2>SessionRepositoryFilter是一个Filter过滤器，符合Servlet的规范定义，用来修改包装请求和响应。这里负责包装切换HttpSession至Spring Session的请求和响应。<br>SpringHttpSessionConfiguration 类定义SessionRepositoryFilter Bean,而在spring项目DelegatingFilterProxy代理装配SessionRepositoryFilter<a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">可参考spring 引入 session代码</a>，<br>而spring boot项目为何自动装配SessionRepositoryFilter 待补充)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void doFilterInternal(HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response, FilterChain filterChain)</span><br><span class=\"line\">                throws ServletException, IOException &#123;</span><br><span class=\"line\">    // 设置SessionRepository至Request的属性中</span><br><span class=\"line\">    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);</span><br><span class=\"line\">    // 包装原始HttpServletRequest至SessionRepositoryRequestWrapper</span><br><span class=\"line\">    SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(</span><br><span class=\"line\">            request, response, this.servletContext);</span><br><span class=\"line\">    // 包装原始HttpServletResponse响应至SessionRepositoryResponseWrapper</span><br><span class=\"line\">    SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(</span><br><span class=\"line\">            wrappedRequest, response);</span><br><span class=\"line\">    // 设置当前请求的HttpSessionStrategy策略</span><br><span class=\"line\">    HttpServletRequest strategyRequest = this.httpSessionStrategy</span><br><span class=\"line\">            .wrapRequest(wrappedRequest, wrappedResponse);</span><br><span class=\"line\">    // 设置当前响应的HttpSessionStrategy策略</span><br><span class=\"line\">    HttpServletResponse strategyResponse = this.httpSessionStrategy</span><br><span class=\"line\">            .wrapResponse(wrappedRequest, wrappedResponse);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        filterChain.doFilter(strategyRequest, strategyResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finally &#123;</span><br><span class=\"line\">        // 提交session</span><br><span class=\"line\">        wrappedRequest.commitSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上是SessionRepositoryFilter的核心操作，每个HttpRequest进入，都会被该Filter包装成切换Session的请求很响应对象。</p>\n<h2 id=\"SessionRepositoryRequestWrapper\"><a href=\"#SessionRepositoryRequestWrapper\" class=\"headerlink\" title=\"SessionRepositoryRequestWrapper\"></a>SessionRepositoryRequestWrapper</h2><p>对于developers获取HttpSession的api<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest request = ...;</span><br><span class=\"line\">HttpSession session = request.getSession(true);</span><br></pre></td></tr></table></figure></p>\n<p>在spring session中request的实际类型SessionRepositoryRequestWrapper。调用SessionRepositoryRequestWrapper的getSession方法会触发创建spring session，而非web容器的HttpSession。</p>\n<p>SessionRepositoryRequestWrapper用来包装原始的HttpServletRequest实现HttpSession切换至Spring Session。是透明Spring Session透明集成HttpSession的关键。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class SessionRepositoryRequestWrapper</span><br><span class=\"line\">            extends HttpServletRequestWrapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final String CURRENT_SESSION_ATTR = HttpServletRequestWrapper.class</span><br><span class=\"line\">                .getName();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当前请求sessionId有效</span><br><span class=\"line\">    private Boolean requestedSessionIdValid;</span><br><span class=\"line\">    // 当前请求sessionId无效</span><br><span class=\"line\">    private boolean requestedSessionInvalidated;</span><br><span class=\"line\">    private final HttpServletResponse response;</span><br><span class=\"line\">    private final ServletContext servletContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SessionRepositoryRequestWrapper(HttpServletRequest request,</span><br><span class=\"line\">            HttpServletResponse response, ServletContext servletContext) &#123;</span><br><span class=\"line\">        // 调用HttpServletRequestWrapper构造方法，实现包装</span><br><span class=\"line\">        super(request);</span><br><span class=\"line\">        this.response = response;</span><br><span class=\"line\">        this.servletContext = servletContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SessionRepositoryRequestWrapper继承Servlet规范中定义的包装器HttpServletRequestWrapper。HttpServletRequestWrapper是Servlet规范api提供的用于扩展HttpServletRequest的扩张点——即装饰器模式，可以通过重写一些api达到功能点的增强和自定义。</p>\n<p>HttpServletRequestWrapper中持有一个HttpServletRequest对象，然后实现HttpServletRequest接口的所有方法，所有方法实现中都是调用持有的HttpServletRequest对象的相应的方法。继承HttpServletRequestWrapper 可以对其重写。SessionRepositoryRequestWrapper继承HttpServletRequestWrapper，在构造方法中将原有的HttpServletRequest通过调用super完成对HttpServletRequestWrapper中持有的HttpServletRequest初始化赋值，然后重写和session相关的方法。这样就保证SessionRepositoryRequestWrapper的其他方法调用都是使用原有的HttpServletRequest的数据，只有session相关的是重写的逻辑。</p>\n<p>这里的设计是否很精妙！一切都多亏与Servlet规范设计的的巧妙啊！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public HttpSessionWrapper getSession() &#123;</span><br><span class=\"line\">    return getSession(true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重写HttpServletRequest的getSession()方法，调用有参数getSession(arg)方法，默认为true，表示当前reques没有session时创建session。继续看下有参数getSession(arg)的重写逻辑.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public HttpSessionWrapper getSession(boolean create) &#123;</span><br><span class=\"line\">    // 从当前请求的attribute中获取session，如果有直接返回</span><br><span class=\"line\">    HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class=\"line\">    if (currentSession != null) &#123;</span><br><span class=\"line\">        return currentSession;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前request的sessionId，这里使用了HttpSessionStrategy</span><br><span class=\"line\">    // 决定怎样将Request映射至Session，默认使用Cookie策略，即从cookies中解析sessionId</span><br><span class=\"line\">    String requestedSessionId = getRequestedSessionId();</span><br><span class=\"line\">    // 请求的如果sessionId存在且当前request的attribute中的没有session失效属性</span><br><span class=\"line\">    // 则根据sessionId获取spring session</span><br><span class=\"line\">    if (requestedSessionId != null</span><br><span class=\"line\">            &amp;&amp; getAttribute(INVALID_SESSION_ID_ATTR) == null) &#123;</span><br><span class=\"line\">        S session = getSession(requestedSessionId);</span><br><span class=\"line\">        // 如果spring session不为空，则将spring session包装成HttpSession并</span><br><span class=\"line\">        // 设置到当前Request的attribute中，防止同一个request getsession时频繁的到存储器</span><br><span class=\"line\">        //中获取session，提高性能</span><br><span class=\"line\">        if (session != null) &#123;</span><br><span class=\"line\">            this.requestedSessionIdValid = true;</span><br><span class=\"line\">            currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class=\"line\">            currentSession.setNew(false);</span><br><span class=\"line\">            setCurrentSession(currentSession);</span><br><span class=\"line\">            return currentSession;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果根据sessionId，没有获取到session，则设置当前request属性，此sessionId无效</span><br><span class=\"line\">        // 同一个请求中获取session，直接返回无效</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            // This is an invalid session id. No need to ask again if</span><br><span class=\"line\">            // request.getSession is invoked for the duration of this request</span><br><span class=\"line\">            if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                SESSION_LOGGER.debug(</span><br><span class=\"line\">                        &quot;No session found by id: Caching result for getSession(false) for this HttpServletRequest.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setAttribute(INVALID_SESSION_ID_ATTR, &quot;true&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断是否创建session</span><br><span class=\"line\">    if (!create) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">        SESSION_LOGGER.debug(</span><br><span class=\"line\">                &quot;A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for &quot;</span><br><span class=\"line\">                        + SESSION_LOGGER_NAME,</span><br><span class=\"line\">                new RuntimeException(</span><br><span class=\"line\">                        &quot;For debugging purposes only (not an error)&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据sessionRepository创建spring session</span><br><span class=\"line\">    S session = SessionRepositoryFilter.this.sessionRepository.createSession();</span><br><span class=\"line\">    // 设置session的最新访问时间</span><br><span class=\"line\">    session.setLastAccessedTime(System.currentTimeMillis());</span><br><span class=\"line\">    // 包装成HttpSession透明化集成</span><br><span class=\"line\">    currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class=\"line\">    // 设置session至Requset的attribute中，提高同一个request访问session的性能</span><br><span class=\"line\">    setCurrentSession(currentSession);</span><br><span class=\"line\">    return currentSession;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看下spring session的持久化。上述SessionRepositoryFilter在包装HttpServletRequest后，执行FilterChain中使用finally保证请求的Session始终session会被提交，此提交操作中将sesionId设置到response的head中并将session持久化至存储器中。</p>\n<p>持久化只持久spring session，并不是将spring session包装后的HttpSession持久化，因为HttpSession不过是包装器，持久化没有意义。</p>\n<p>再来看下包装的响应SessionRepositoryResponseWrapper。</p>\n<h2 id=\"SessionRepositoryResponseWrapper\"><a href=\"#SessionRepositoryResponseWrapper\" class=\"headerlink\" title=\"SessionRepositoryResponseWrapper\"></a>SessionRepositoryResponseWrapper</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows ensuring that the session is saved if the response is committed.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final class SessionRepositoryResponseWrapper</span><br><span class=\"line\">        extends OnCommittedResponseWrapper &#123;</span><br><span class=\"line\">    private final SessionRepositoryRequestWrapper request;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create a new &#123;@link SessionRepositoryResponseWrapper&#125;.</span><br><span class=\"line\">     * @param request the request to be wrapped</span><br><span class=\"line\">     * @param response the response to be wrapped</span><br><span class=\"line\">     */</span><br><span class=\"line\">    SessionRepositoryResponseWrapper(SessionRepositoryRequestWrapper request,</span><br><span class=\"line\">            HttpServletResponse response) &#123;</span><br><span class=\"line\">        super(response);</span><br><span class=\"line\">        if (request == null) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;request cannot be null&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.request = request;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResponseCommitted() &#123;</span><br><span class=\"line\">        this.request.commitSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释已经非常详细，这里不再赘述。这里只讲述为什么需要包装原始的响应。从注释上可以看出包装响应时为了：确保如果响应被提交session能够被保存。</p>\n<p>这里我有点疑惑：在上述的SessionRepositoryFilter.doFilterInternal方法中不是已经request.commitSession()了吗，FilterChain执行完或者异常后都会执行Finally中的request.commitSession。为什么这里仍然需要包装响应，为了确保session能够保存，包装器中的onResponseCommitted方法可以看出也是做了一次request.commitSession()</p>\n<p>原因：一旦response执行flushBuffer方法，迫使Response中在Buffer中任何数据都会被返回至client端。这个方法自动提交响应中的status code和head。那么如果不包装请求，监听flushBuffer事件在提交response前，将session写入response和持久化session，将导致作者说的无法追踪session。（来源网上）</p>\n<p>SessionRepositoryResponseWrapper继承父类OnCommittedResponseWrapper，其中flushBuffer方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Makes sure &#123;@link OnCommittedResponseWrapper#onResponseCommitted()&#125; is invoked</span><br><span class=\"line\"> * before calling the superclass &lt;code&gt;flushBuffer()&lt;/code&gt;.</span><br><span class=\"line\"> * @throws IOException if an input or output exception occurred</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void flushBuffer() throws IOException &#123;</span><br><span class=\"line\">    doOnResponseCommitted();</span><br><span class=\"line\">    super.flushBuffer();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Calls &lt;code&gt;onResponseCommmitted()&lt;/code&gt; with the current contents as long as</span><br><span class=\"line\"> * &#123;@link #disableOnResponseCommitted()&#125; was not invoked.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void doOnResponseCommitted() &#123;</span><br><span class=\"line\">    if (!this.disableOnCommitted) &#123;</span><br><span class=\"line\">        onResponseCommitted();</span><br><span class=\"line\">        disableOnResponseCommitted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重写HttpServletResponse方法，监听response commit，当发生response commit时，可以在commit之前写session至response中并持久化session</p>\n<p>再看SessionRepository之前，先来看下spring session中的session接口。</p>\n<h2 id=\"Session接口\"><a href=\"#Session接口\" class=\"headerlink\" title=\"Session接口\"></a>Session接口</h2><p>spring-session和tomcat中的Session的实现模式上有很大不同，tomcat中直接对HttpSession接口进行实现，而spring-session中则抽象出单独的Session层接口，让后再使用适配器模式将Session适配层Servlet规范中的HttpSession。spring-sesion中关于session的实现和适配整个UML类图如下：</p>\n<p><img src=\"/2019/11/21/SpringSession源码/3.png\" alt=\"springSesion模块\"></p>\n<p>Session是spring-session对session的抽象，主要是为了鉴定用户，为Http请求和响应提供上下文过程，该Session可以被HttpSession、WebSocket Session，非WebSession等使用。定义了Session的基本行为：</p>\n<ul>\n<li>getId：获取sessionId</li>\n<li>setAttribute：设置session属性</li>\n<li>getAttribte：获取session属性</li>\n</ul>\n<p>ExipringSession：提供Session额外的过期特性。定义了以下关于过期的行为：</p>\n<ul>\n<li>setLastAccessedTime：设置最近Session会话过程中最近的访问时间</li>\n<li>getLastAccessedTime：获取最近的访问时间</li>\n<li>setMaxInactiveIntervalInSeconds：设置Session的最大闲置时间</li>\n<li>getMaxInactiveIntervalInSeconds：获取最大闲置时间</li>\n<li>isExpired：判断Session是否过期</li>\n</ul>\n<p>MapSession：基于java.util.Map的ExpiringSession的实现</p>\n<p>RedisSession：基于MapSession和Redis的ExpiringSession实现，提供Session的持久化能力</p>\n<p>先来看下MapSession的代码源码片段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class MapSession implements ExpiringSession, Serializable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Default &#123;@link #setMaxInactiveIntervalInSeconds(int)&#125; (30 minutes).</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static final int DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS = 1800;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private Map&lt;String, Object&gt; sessionAttrs = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">    private long creationTime = System.currentTimeMillis();</span><br><span class=\"line\">    private long lastAccessedTime = this.creationTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Defaults to 30 minutes.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int maxInactiveInterval = DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS;</span><br></pre></td></tr></table></figure></p>\n<p>MapSession中持有HashMap类型的变量sessionAtts用于存储Session设置属性，比如调用的setAttribute方法的k-v就存储在该HashMap中。这个和tomcat内部实现HttpSession的方式类似，tomcat中使用了ConcurrentHashMap存储。</p>\n<p>其中lastAccessedTime用于记录最近的一次访问时间，maxInactiveInterval用于记录Session的最大闲置时间（过期时间-针对没有Request活跃的情况下的最大时间，即相对于最近一次访问后的最大闲置时间）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setAttribute(String attributeName, Object attributeValue) &#123;</span><br><span class=\"line\">    if (attributeValue == null) &#123;</span><br><span class=\"line\">        removeAttribute(attributeName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        this.sessionAttrs.put(attributeName, attributeValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>setAttribute方法极其简单，null时就移除attributeName，否则put存储。</p>\n<p>重点熟悉RedisSession如何实现Session的行为：setAttribute、persistence等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * A custom implementation of &#123;@link Session&#125; that uses a &#123;@link MapSession&#125; as the</span><br><span class=\"line\"> * basis for its mapping. It keeps track of any attributes that have changed. When</span><br><span class=\"line\"> * &#123;@link org.springframework.session.data.redis.RedisOperationsSessionRepository.RedisSession#saveDelta()&#125;</span><br><span class=\"line\"> * is invoked all the attributes that have been changed will be persisted.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">final class RedisSession implements ExpiringSession &#123;</span><br><span class=\"line\">    private final MapSession cached;</span><br><span class=\"line\">    private Long originalLastAccessTime;</span><br><span class=\"line\">    private Map&lt;String, Object&gt; delta = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">    private boolean isNew;</span><br><span class=\"line\">    private String originalPrincipalName;</span><br></pre></td></tr></table></figure></p>\n<p>首先看javadocs，对于阅读源码，学会看javadocs非常重要！</p>\n<p>基于MapSession的基本映射实现的Session，能够追踪发生变化的所有属性，当调用saveDelta方法后，变化的属性将被持久化！</p>\n<p>在RedisSession中有两个非常重要的成员属性：</p>\n<ul>\n<li>cached：实际上是一个MapSession实例，用于做本地缓存，每次在getAttribute时无需从Redis中获取，主要为了improve性能</li>\n<li>delta：用于跟踪变化数据，做持久化<br>再来看下RedisSession中最为重要的行为saveDelta——持久化Session至Redis中：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Saves any attributes that have been changed and updates the expiration of this</span><br><span class=\"line\"> * session.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void saveDelta() &#123;</span><br><span class=\"line\">    // 如果delta为空，则Session中没有任何数据需要存储</span><br><span class=\"line\">    if (this.delta.isEmpty()) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String sessionId = getId();</span><br><span class=\"line\">    // 使用spring data redis将delta中的数据保存至Redis中</span><br><span class=\"line\">    getSessionBoundHashOperations(sessionId).putAll(this.delta);</span><br><span class=\"line\">    String principalSessionKey = getSessionAttrNameKey(</span><br><span class=\"line\">            FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME);</span><br><span class=\"line\">    String securityPrincipalSessionKey = getSessionAttrNameKey(</span><br><span class=\"line\">            SPRING_SECURITY_CONTEXT);</span><br><span class=\"line\">    if (this.delta.containsKey(principalSessionKey)</span><br><span class=\"line\">            || this.delta.containsKey(securityPrincipalSessionKey)) &#123;</span><br><span class=\"line\">        if (this.originalPrincipalName != null) &#123;</span><br><span class=\"line\">            String originalPrincipalRedisKey = getPrincipalKey(</span><br><span class=\"line\">                    this.originalPrincipalName);</span><br><span class=\"line\">            RedisOperationsSessionRepository.this.sessionRedisOperations</span><br><span class=\"line\">                    .boundSetOps(originalPrincipalRedisKey).remove(sessionId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String principal = PRINCIPAL_NAME_RESOLVER.resolvePrincipal(this);</span><br><span class=\"line\">        this.originalPrincipalName = principal;</span><br><span class=\"line\">        if (principal != null) &#123;</span><br><span class=\"line\">            String principalRedisKey = getPrincipalKey(principal);</span><br><span class=\"line\">            RedisOperationsSessionRepository.this.sessionRedisOperations</span><br><span class=\"line\">                    .boundSetOps(principalRedisKey).add(sessionId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    // 清空delta，代表没有任何需要持久化的数据。同时保证</span><br><span class=\"line\">    //SessionRepositoryFilter和SessionRepositoryResponseWrapper的onResponseCommitted</span><br><span class=\"line\">    //只会持久化一次Session至Redis中，解决前面提到的疑问</span><br><span class=\"line\">    this.delta = new HashMap&lt;String, Object&gt;(this.delta.size());  </span><br><span class=\"line\">    // 更新过期时间，滚动至下一个过期时间间隔的时刻</span><br><span class=\"line\">    Long originalExpiration = this.originalLastAccessTime == null ? null</span><br><span class=\"line\">            : this.originalLastAccessTime + TimeUnit.SECONDS</span><br><span class=\"line\">                    .toMillis(getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    RedisOperationsSessionRepository.this.expirationPolicy</span><br><span class=\"line\">            .onExpirationUpdated(originalExpiration, this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从javadoc中可以看出，saveDelta用于存储Session的属性：</p>\n<ul>\n<li>保存Session中的属性数据至Redis中</li>\n<li>清空delta中数据，防止重复提交Session中的数据</li>\n<li>更新过期时间至下一个过期时间间隔的时刻</li>\n</ul>\n<p>再看下RedisSession中的其他行为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置session的存活时间，即最大过期时间。先保存至本地缓存，然后再保存至delta</span><br><span class=\"line\">public void setMaxInactiveIntervalInSeconds(int interval) &#123;</span><br><span class=\"line\">    this.cached.setMaxInactiveIntervalInSeconds(interval);</span><br><span class=\"line\">    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接从本地缓存获取过期时间</span><br><span class=\"line\">public int getMaxInactiveIntervalInSeconds() &#123;</span><br><span class=\"line\">    return this.cached.getMaxInactiveIntervalInSeconds();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接从本地缓存中获取Session中的属性</span><br><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public Object getAttribute(String attributeName) &#123;</span><br><span class=\"line\">    return this.cached.getAttribute(attributeName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 保存Session属性至本地缓存和delta中</span><br><span class=\"line\">public void setAttribute(String attributeName, Object attributeValue) &#123;</span><br><span class=\"line\">    this.cached.setAttribute(attributeName, attributeValue);</span><br><span class=\"line\">    this.delta.put(getSessionAttrNameKey(attributeName), attributeValue);</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了MapSession和RedisSession还有JdbcSession、MongoExpiringSession，感兴趣的读者可以自行阅读。</p>\n<p>下面看SessionRepository的逻辑。SessionRepository是spring session中用于管理spring session的核心组件。</p>\n<h2 id=\"SessionRepository\"><a href=\"#SessionRepository\" class=\"headerlink\" title=\"SessionRepository\"></a>SessionRepository</h2><p>javadoc中描述SessionRepository为管理spring-session的接口实例。抽象出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S createSession();</span><br><span class=\"line\">void save(S session);</span><br><span class=\"line\">S getSession(String id);</span><br><span class=\"line\">void delete(String id);</span><br></pre></td></tr></table></figure></p>\n<p>创建、保存、获取、删除Session的接口行为。根据Session的不同，分为很多种Session操作仓库。<br><img src=\"/2019/11/21/SpringSession源码/4.png\" alt=\"springSesion模块\"></p>\n<p>这里重点介绍下RedisOperationsSessionRepository。在详细介绍其之前，了解下RedisOperationsSessionRepository的数据存储细节。</p>\n<p>当创建一个RedisSession，然后存储在Redis中时，RedisSession的存储细节如下：</p>\n<p>spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:expirations:1439245080000</p>\n<p>Redis会为每个RedisSession存储三个k-v。</p>\n<ul>\n<li>第一个k-v用来存储Session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等。这个k的过期时间为Session的最大过期时间 + 5分钟。如果默认的最大过期时间为30分钟，则这个k的过期时间为35分钟</li>\n<li>第二个k-v用来表示Session在Redis中的过期，这个k-v不存储任何有用数据，只是表示Session过期而设置。这个k在Redis中的过期时间即为Session的过期时间间隔</li>\n<li>第三个k-v存储这个Session的id，是一个Set类型的Redis数据结构。这个k中的最后的1439245080000值是一个时间戳，根据这个Session过期时刻滚动至下一分钟而计算得出。<br>简单描述下，为什么RedisSession的存储用到了三个Key，而非一个Redis过期Key。<br>对于Session的实现，需要支持HttpSessionEvent，即Session创建、过期、销毁等事件。当应用用监听器设置监听相应事件，Session发生上述行为时，监听器能够做出相应的处理。<br>Redis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。</li>\n</ul>\n<p>但是Redis中带有过期的key有两种方式：</p>\n<ul>\n<li>当访问时发现其过期</li>\n<li>Redis后台逐步查找过期键<br>当访问时发现其过期，会产生过期事件，但是无法保证key的过期时间抵达后立即生成过期事件。<br>spring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：</li>\n</ul>\n<p>spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe<br>spring:session:expirations:1439245080000</p>\n<p>spring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。</p>\n<p>接下来再看下RedisOperationsSessionRepository中的具体实现原理</p>\n<h3 id=\"createSession方法：\"><a href=\"#createSession方法：\" class=\"headerlink\" title=\"createSession方法：\"></a>createSession方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RedisSession createSession() &#123;</span><br><span class=\"line\">    // new一个RedisSession实例</span><br><span class=\"line\">    RedisSession redisSession = new RedisSession();</span><br><span class=\"line\">    // 如果设置的最大过期时间不为空，则设置RedisSession的过期时间</span><br><span class=\"line\">    if (this.defaultMaxInactiveInterval != null) &#123;</span><br><span class=\"line\">        redisSession.setMaxInactiveIntervalInSeconds(this.defaultMaxInactiveInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return redisSession;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看下RedisSession的构造方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Creates a new instance ensuring to mark all of the new attributes to be</span><br><span class=\"line\"> * persisted in the next save operation.</span><br><span class=\"line\"> */</span><br><span class=\"line\">RedisSession() &#123;</span><br><span class=\"line\">    // 设置本地缓存为MapSession</span><br><span class=\"line\">    this(new MapSession());</span><br><span class=\"line\">    // 设置Session的基本属性</span><br><span class=\"line\">    this.delta.put(CREATION_TIME_ATTR, getCreationTime());</span><br><span class=\"line\">    this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());</span><br><span class=\"line\">    this.delta.put(LAST_ACCESSED_ATTR, getLastAccessedTime());</span><br><span class=\"line\">    // 标记Session的是否为新创建</span><br><span class=\"line\">    this.isNew = true;</span><br><span class=\"line\">    // 持久化</span><br><span class=\"line\">    flushImmediateIfNecessary();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"save方法：\"><a href=\"#save方法：\" class=\"headerlink\" title=\"save方法：\"></a>save方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void save(RedisSession session) &#123;</span><br><span class=\"line\">    // 调用RedisSession的saveDelta持久化Session</span><br><span class=\"line\">    session.saveDelta();</span><br><span class=\"line\">    // 如果Session为新创建，则发布一个Session创建的事件</span><br><span class=\"line\">    if (session.isNew()) &#123;</span><br><span class=\"line\">        String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class=\"line\">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class=\"line\">        session.setNew(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getSession方法：\"><a href=\"#getSession方法：\" class=\"headerlink\" title=\"getSession方法：\"></a>getSession方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据SessionId获取Session，这里的false代表的参数</span><br><span class=\"line\">// 指：如果Session已经过期，是否仍然获取返回</span><br><span class=\"line\">public RedisSession getSession(String id) &#123;</span><br><span class=\"line\">    return getSession(id, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在有些情况下，Session过期，仍然需要能够获取到Session。这里先来看下getSession(String id, boolean allowExpired)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private RedisSession getSession(String id, boolean allowExpired) &#123;</span><br><span class=\"line\">    // 根据SessionId，从Redis获取到持久化的Session信息</span><br><span class=\"line\">    Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class=\"line\">    // 如果Redis中没有，则返回null</span><br><span class=\"line\">    if (entries.isEmpty()) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据Session信息，加载创建一个MapSession对象</span><br><span class=\"line\">    MapSession loaded = loadSession(id, entries);</span><br><span class=\"line\">    //  判断是否允许过期获取和Session是否过期</span><br><span class=\"line\">    if (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据MapSession new一个信息的RedisSession，此时isNew为false</span><br><span class=\"line\">    RedisSession result = new RedisSession(loaded);</span><br><span class=\"line\">    // 设置最新的访问时间</span><br><span class=\"line\">    result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是loaded.isExpired()和loadSession。loaded.isExpired判断Session是否过期，如果过期返回null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isExpired() &#123;</span><br><span class=\"line\">    // 根据当前时间判断是否过期</span><br><span class=\"line\">    return isExpired(System.currentTimeMillis());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">boolean isExpired(long now) &#123;</span><br><span class=\"line\">    // 如果maxInactiveInterval小于0，表示Session永不过期</span><br><span class=\"line\">    if (this.maxInactiveInterval &lt; 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 最大过期时间单位转换为毫秒</span><br><span class=\"line\">    // 当前时间减去Session的最大有效期间隔以获取理论上有效的上一次访问时间</span><br><span class=\"line\">    // 然后在与实际的上一次访问时间进行比较</span><br><span class=\"line\">    // 如果大于，表示理论上的时间已经在实际的访问时间之后，那么表示Session已经过期</span><br><span class=\"line\">    return now - TimeUnit.SECONDS</span><br><span class=\"line\">            .toMillis(this.maxInactiveInterval) &gt;= this.lastAccessedTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>loadSession中，将Redis中存储的Session信息转换为MapSession对象，以便从Session中获取属性时能够从内存直接获取提高性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private MapSession loadSession(String id, Map&lt;Object, Object&gt; entries) &#123;</span><br><span class=\"line\">    MapSession loaded = new MapSession(id);</span><br><span class=\"line\">    for (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class=\"line\">        String key = (String) entry.getKey();</span><br><span class=\"line\">        if (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setCreationTime((Long) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setMaxInactiveIntervalInSeconds((Integer) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class=\"line\">            loaded.setLastAccessedTime((Long) entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class=\"line\">            loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class=\"line\">                    entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return loaded;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，可以看出spring-session中request.getSession(false)的过期实现原理。</p>\n<h3 id=\"delete方法：\"><a href=\"#delete方法：\" class=\"headerlink\" title=\"delete方法：\"></a>delete方法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void delete(String sessionId) &#123;</span><br><span class=\"line\">    // 获取Session</span><br><span class=\"line\">    RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\">    if (session == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cleanupPrincipalIndex(session);</span><br><span class=\"line\">    // 从过期集合中移除sessionId</span><br><span class=\"line\">    this.expirationPolicy.onDelete(session);</span><br><span class=\"line\">    String expireKey = getExpiredKey(session.getId());</span><br><span class=\"line\">    // 删除session的过期键</span><br><span class=\"line\">    this.sessionRedisOperations.delete(expireKey);</span><br><span class=\"line\">    // 设置session过期</span><br><span class=\"line\">    session.setMaxInactiveIntervalInSeconds(0);</span><br><span class=\"line\">    save(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此RedisOperationsSessionRepository的核心原理就介绍完毕。但是RedisOperationsSessionRepository中还包括关于Session事件的处理和清理Session的定时任务。这部分内容在后述的SessionEvent部分介绍。</p>\n<h2 id=\"HttpSessionStrategy\"><a href=\"#HttpSessionStrategy\" class=\"headerlink\" title=\"HttpSessionStrategy\"></a>HttpSessionStrategy</h2><p>从javadoc中可以看出，HttpSessionStrategy是建立Request/Response和Session之间的映射关系的策略。<br>该策略接口中定义一套策略行为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据请求获取SessionId，即建立请求至Session的映射关系</span><br><span class=\"line\">String getRequestedSessionId(HttpServletRequest request);</span><br><span class=\"line\">// 对于新创建的Session，通知客户端</span><br><span class=\"line\">void onNewSession(Session session, HttpServletRequest request,</span><br><span class=\"line\">            HttpServletResponse response);</span><br><span class=\"line\">// 对于session无效，通知客户端</span><br><span class=\"line\">void onInvalidateSession(HttpServletRequest request, HttpServletResponse response);</span><br></pre></td></tr></table></figure></p>\n<p>如下UML类图：<br><img src=\"/2019/11/21/SpringSession源码/5.png\" alt=\"springSesion模块\"></p>\n<p>这里主要介绍CookieHttpSessionStrategy，这个也是默认的策略，可以查看spring-session中类SpringHttpSessionConfiguration，在注册SessionRepositoryFilter Bean时默认采用CookieHttpSessionStrategy：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public &lt;S extends ExpiringSession&gt; SessionRepositoryFilter&lt;? extends ExpiringSession&gt; springSessionRepositoryFilter(</span><br><span class=\"line\">        SessionRepository&lt;S&gt; sessionRepository) &#123;</span><br><span class=\"line\">    SessionRepositoryFilter&lt;S&gt; sessionRepositoryFilter = new SessionRepositoryFilter&lt;S&gt;(</span><br><span class=\"line\">            sessionRepository);</span><br><span class=\"line\">    sessionRepositoryFilter.setServletContext(this.servletContext);</span><br><span class=\"line\">    if (this.httpSessionStrategy instanceof MultiHttpSessionStrategy) &#123;</span><br><span class=\"line\">        sessionRepositoryFilter.setHttpSessionStrategy(</span><br><span class=\"line\">                (MultiHttpSessionStrategy) this.httpSessionStrategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        sessionRepositoryFilter.setHttpSessionStrategy(this.httpSessionStrategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sessionRepositoryFilter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面来分析CookieHttpSessionStrategy的原理。该策略使用Cookie来映射Request/Response至Session。即request/requset的head中cookie存储SessionId，当请求至web服务器，可以解析请求head中的cookie，然后获取sessionId，根据sessionId获取spring-session。当创建新的session或者session过期，将相应的sessionId写入response的set-cookie或者从respose中移除sessionId。</p>\n<h3 id=\"getRequestedSessionId方法\"><a href=\"#getRequestedSessionId方法\" class=\"headerlink\" title=\"getRequestedSessionId方法\"></a>getRequestedSessionId方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getRequestedSessionId(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取当前请求的sessionId：session别名和sessionId映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取当前请求的Session别名</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 获取相应别名的sessionId</span><br><span class=\"line\">    return sessionIds.get(sessionAlias);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来看下具体获取SessionIds的具体过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getRequestedSessionId(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取当前请求的sessionId：session别名和sessionId映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取当前请求的Session别名</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 获取相应别名的sessionId</span><br><span class=\"line\">    return sessionIds.get(sessionAlias);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public Map&lt;String, String&gt; getSessionIds(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 解析request中的cookie值</span><br><span class=\"line\">    List&lt;String&gt; cookieValues = this.cookieSerializer.readCookieValues(request);</span><br><span class=\"line\">    // 获取sessionId</span><br><span class=\"line\">    String sessionCookieValue = cookieValues.isEmpty() ? &quot;&quot;</span><br><span class=\"line\">            : cookieValues.iterator().next();</span><br><span class=\"line\">    Map&lt;String, String&gt; result = new LinkedHashMap&lt;String, String&gt;();</span><br><span class=\"line\">    // 根据分词器对sessionId进行分割，因为spring-session支持多session。默认情况只有一个session</span><br><span class=\"line\">    StringTokenizer tokens = new StringTokenizer(sessionCookieValue, this.deserializationDelimiter);</span><br><span class=\"line\">    // 如果只有一个session，则设置默认别名为0</span><br><span class=\"line\">    if (tokens.countTokens() == 1) &#123;</span><br><span class=\"line\">        result.put(DEFAULT_ALIAS, tokens.nextToken());</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果有多个session，则建立别名和sessionId的映射</span><br><span class=\"line\">    while (tokens.hasMoreTokens()) &#123;</span><br><span class=\"line\">        String alias = tokens.nextToken();</span><br><span class=\"line\">        if (!tokens.hasMoreTokens()) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String id = tokens.nextToken();</span><br><span class=\"line\">        result.put(alias, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public List&lt;String&gt; readCookieValues(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 获取request的cookie</span><br><span class=\"line\">    Cookie[] cookies = request.getCookies();</span><br><span class=\"line\">    List&lt;String&gt; matchingCookieValues = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">    if (cookies != null) &#123;</span><br><span class=\"line\">        for (Cookie cookie : cookies) &#123;</span><br><span class=\"line\">            // 如果是以SESSION开头，则表示是SessionId，毕竟cookie不只有sessionId，还有可能存储其他内容</span><br><span class=\"line\">            if (this.cookieName.equals(cookie.getName())) &#123;</span><br><span class=\"line\">                // 决策是否需要base64 decode</span><br><span class=\"line\">                String sessionId = this.useBase64Encoding</span><br><span class=\"line\">                        ? base64Decode(cookie.getValue()) : cookie.getValue();</span><br><span class=\"line\">                if (sessionId == null) &#123;</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (this.jvmRoute != null &amp;&amp; sessionId.endsWith(this.jvmRoute)) &#123;</span><br><span class=\"line\">                    sessionId = sessionId.substring(0,</span><br><span class=\"line\">                            sessionId.length() - this.jvmRoute.length());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 存入list中</span><br><span class=\"line\">                matchingCookieValues.add(sessionId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return matchingCookieValues;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看下获取当前request对应的Session的别名方法getCurrentSessionAlias<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getCurrentSessionAlias(HttpServletRequest request) &#123;</span><br><span class=\"line\">    // 如果session参数为空，则返回默认session别名</span><br><span class=\"line\">    if (this.sessionParam == null) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 从request中获取session别名，如果为空则返回默认别名</span><br><span class=\"line\">    String u = request.getParameter(this.sessionParam);</span><br><span class=\"line\">    if (u == null) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!ALIAS_PATTERN.matcher(u).matches()) &#123;</span><br><span class=\"line\">        return DEFAULT_ALIAS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>spring-session为了支持多session，才弄出多个session别名。当时一般应用场景都是一个session，都是默认的session别名0。</p>\n<p>上述获取sessionId和别名映射关系中，也是默认别名0。这里返回别名0，所以返回当前请求对应的sessionId。</p>\n<h3 id=\"onNewSession方法\"><a href=\"#onNewSession方法\" class=\"headerlink\" title=\"onNewSession方法\"></a>onNewSession方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onNewSession(Session session, HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response) &#123;</span><br><span class=\"line\">    // 从当前request中获取已经写入Cookie的sessionId集合</span><br><span class=\"line\">    Set&lt;String&gt; sessionIdsWritten = getSessionIdsWritten(request);</span><br><span class=\"line\">    // 判断是否包含，如果包含，表示该sessionId已经写入过cookie中，则直接返回</span><br><span class=\"line\">    if (sessionIdsWritten.contains(session.getId())) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果没有写入，则加入集合，后续再写入</span><br><span class=\"line\">    sessionIdsWritten.add(session.getId());</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    String sessionAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    sessionIds.put(sessionAlias, session.getId());</span><br><span class=\"line\">    // 获取cookieValue</span><br><span class=\"line\">    String cookieValue = createSessionCookieValue(sessionIds);</span><br><span class=\"line\">    //将cookieValue写入Cookie中</span><br><span class=\"line\">    this.cookieSerializer</span><br><span class=\"line\">            .writeCookieValue(new CookieValue(request, response, cookieValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sessionIdsWritten主要是用来记录已经写入Cookie的SessionId，防止SessionId重复写入Cookie中。</p>\n<h3 id=\"onInvalidateSession方法\"><a href=\"#onInvalidateSession方法\" class=\"headerlink\" title=\"onInvalidateSession方法\"></a>onInvalidateSession方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onInvalidateSession(HttpServletRequest request,</span><br><span class=\"line\">        HttpServletResponse response) &#123;</span><br><span class=\"line\">    // 从当前request中获取sessionId和别名映射</span><br><span class=\"line\">    Map&lt;String, String&gt; sessionIds = getSessionIds(request);</span><br><span class=\"line\">    // 获取别名</span><br><span class=\"line\">    String requestedAlias = getCurrentSessionAlias(request);</span><br><span class=\"line\">    // 移除sessionId</span><br><span class=\"line\">    sessionIds.remove(requestedAlias);</span><br><span class=\"line\">    String cookieValue = createSessionCookieValue(sessionIds);</span><br><span class=\"line\">    // 写入移除后的sessionId</span><br><span class=\"line\">    this.cookieSerializer</span><br><span class=\"line\">            .writeCookieValue(new CookieValue(request, response, cookieValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看下具体的写入writeCookieValue原理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void writeCookieValue(CookieValue cookieValue) &#123;</span><br><span class=\"line\">    // 获取request/respose和cookie值</span><br><span class=\"line\">    HttpServletRequest request = cookieValue.getRequest();</span><br><span class=\"line\">    HttpServletResponse response = cookieValue.getResponse();</span><br><span class=\"line\">    String requestedCookieValue = cookieValue.getCookieValue();</span><br><span class=\"line\">    String actualCookieValue = this.jvmRoute == null ? requestedCookieValue</span><br><span class=\"line\">            : requestedCookieValue + this.jvmRoute;</span><br><span class=\"line\">    // 构造servlet规范中的Cookie对象，注意这里cookieName为：SESSION，表示为Session，</span><br><span class=\"line\">    // 上述的从Cookie中读取SessionId，也是使用该cookieName</span><br><span class=\"line\">    Cookie sessionCookie = new Cookie(this.cookieName, this.useBase64Encoding</span><br><span class=\"line\">            ? base64Encode(actualCookieValue) : actualCookieValue);</span><br><span class=\"line\">    // 设置cookie的属性：secure、path、domain、httpOnly</span><br><span class=\"line\">    sessionCookie.setSecure(isSecureCookie(request));</span><br><span class=\"line\">    sessionCookie.setPath(getCookiePath(request));</span><br><span class=\"line\">    String domainName = getDomainName(request);</span><br><span class=\"line\">    if (domainName != null) &#123;</span><br><span class=\"line\">        sessionCookie.setDomain(domainName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.useHttpOnlyCookie) &#123;</span><br><span class=\"line\">        sessionCookie.setHttpOnly(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果cookie值为空，则失效</span><br><span class=\"line\">    if (&quot;&quot;.equals(requestedCookieValue)) &#123;</span><br><span class=\"line\">        sessionCookie.setMaxAge(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        sessionCookie.setMaxAge(this.cookieMaxAge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 写入cookie到response中</span><br><span class=\"line\">    response.addCookie(sessionCookie);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，CookieHttpSessionStrategy介绍结束。</p>\n<p>由于篇幅过长，关于spring-session event和RedisOperationSessionRepository清理session并且产生过期事件的部分后续文章介绍。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>spring-session提供集群环境下HttpSession的透明集成。spring-session的优势在于开箱即用，具有较强的设计模式。且支持多种持久化方式，其中RedisSession较为成熟，与spring-data-redis整合，可谓威力无穷。</p>\n"},{"title":"十二 jenkins 配置maven打包git代码","author":"wen","date":"2018-05-11T15:36:00.000Z","_content":"一 [jenkins-配置git证书](/2018/05/11/-jenkins-配置git证书/)\n二 [安装jenkins](/2018/05/08/安装jenkins/)\n三 [jenkins 配置java和Maven环境](/2018/05/11/enkinx-配置任务/)\n\n![logo](-jenkins-配置maven打包git代码/总图.png)\n# 一配置任务\n1.1点击 创建一个新任务\n![logo](-jenkins-配置maven打包git代码/1.png)\n1.2 输入名称  选择自由风格的软件项目\n![logo](-jenkins-配置maven打包git代码/2.png)\n1.3新增文本参数\n1.3.1参数docker.image.prefix: 私有库域名\n![logo](-jenkins-配置maven打包git代码/3.png)\n1.3.2参数docker.registry：私有库地址\n![logo](-jenkins-配置maven打包git代码/4.png)\n1.3.3参数docker.servcerId：刚才maven配置 私有库用户名和密码\n![logo](-jenkins-配置maven打包git代码/5.png)\n1.3.4参数version \n![logo](-jenkins-配置maven打包git代码/6.png)\n1.4配置 git库\n![logo](-jenkins-配置maven打包git代码/7.png)\n1.5构建步骤添加 执行Shell脚本\n![logo](-jenkins-配置maven打包git代码/8.png)\n```\n脚本命令：\necho $WORKSPACE\necho $MAVEN_HOME\ncd $WORKSPACE/Eureka\n$MAVEN_HOME/bin/mvn clean package docker:build -DpushImage -Ddocker.image.prefix=$docker_image_prefix -Ddocker.registry=$docker_registry -Ddocker.servcerId=$docker_servcerId -Dtag.version=$version\n```\n保存\n\n# 二 配置jenkins用户可以执行docker 命令\nliunx用户 使用jenkins 用户启动jenkins\n```\nvi /etc/systemd/system/multi-user.target.wants/docker.service\n ExecStart=/usr/bin/dockerd  -G jenkins\n\n```\n -G表示 jenkins用户可以执行docker 命令\n ![logo](-jenkins-配置maven打包git代码/9.png)\n \n 重新加载配置\n ```\n  systemctl daemon-reload\n  ```\n  重新启动docker\n  ```\n systemctl restart docker\n ```\n\n# 三执行任务 \n3.1 点击 Build with Parameters\n![logo](-jenkins-配置maven打包git代码/10.png)\n3.2 点击开始创建\n![logo](-jenkins-配置maven打包git代码/11.png)\n3.3查看脚本执行情况\n![logo](-jenkins-配置maven打包git代码/12.png)\n3.4成功后查看私有仓库目录\n![logo](-jenkins-配置maven打包git代码/132.png)","source":"_posts/-jenkins-配置maven打包git代码.md","raw":"title: 十二 jenkins 配置maven打包git代码\nauthor: wen\ntags:\n  - git\n  - maven\n  - docker\n  - jenkins\ncategories:\n  - jenkins\ndate: 2018-05-11 23:36:00\n---\n一 [jenkins-配置git证书](/2018/05/11/-jenkins-配置git证书/)\n二 [安装jenkins](/2018/05/08/安装jenkins/)\n三 [jenkins 配置java和Maven环境](/2018/05/11/enkinx-配置任务/)\n\n![logo](-jenkins-配置maven打包git代码/总图.png)\n# 一配置任务\n1.1点击 创建一个新任务\n![logo](-jenkins-配置maven打包git代码/1.png)\n1.2 输入名称  选择自由风格的软件项目\n![logo](-jenkins-配置maven打包git代码/2.png)\n1.3新增文本参数\n1.3.1参数docker.image.prefix: 私有库域名\n![logo](-jenkins-配置maven打包git代码/3.png)\n1.3.2参数docker.registry：私有库地址\n![logo](-jenkins-配置maven打包git代码/4.png)\n1.3.3参数docker.servcerId：刚才maven配置 私有库用户名和密码\n![logo](-jenkins-配置maven打包git代码/5.png)\n1.3.4参数version \n![logo](-jenkins-配置maven打包git代码/6.png)\n1.4配置 git库\n![logo](-jenkins-配置maven打包git代码/7.png)\n1.5构建步骤添加 执行Shell脚本\n![logo](-jenkins-配置maven打包git代码/8.png)\n```\n脚本命令：\necho $WORKSPACE\necho $MAVEN_HOME\ncd $WORKSPACE/Eureka\n$MAVEN_HOME/bin/mvn clean package docker:build -DpushImage -Ddocker.image.prefix=$docker_image_prefix -Ddocker.registry=$docker_registry -Ddocker.servcerId=$docker_servcerId -Dtag.version=$version\n```\n保存\n\n# 二 配置jenkins用户可以执行docker 命令\nliunx用户 使用jenkins 用户启动jenkins\n```\nvi /etc/systemd/system/multi-user.target.wants/docker.service\n ExecStart=/usr/bin/dockerd  -G jenkins\n\n```\n -G表示 jenkins用户可以执行docker 命令\n ![logo](-jenkins-配置maven打包git代码/9.png)\n \n 重新加载配置\n ```\n  systemctl daemon-reload\n  ```\n  重新启动docker\n  ```\n systemctl restart docker\n ```\n\n# 三执行任务 \n3.1 点击 Build with Parameters\n![logo](-jenkins-配置maven打包git代码/10.png)\n3.2 点击开始创建\n![logo](-jenkins-配置maven打包git代码/11.png)\n3.3查看脚本执行情况\n![logo](-jenkins-配置maven打包git代码/12.png)\n3.4成功后查看私有仓库目录\n![logo](-jenkins-配置maven打包git代码/132.png)","slug":"-jenkins-配置maven打包git代码","published":1,"updated":"2019-05-05T02:41:23.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37c000fn6zqjtf91vpd","content":"<p>一 <a href=\"/2018/05/11/-jenkins-配置git证书/\">jenkins-配置git证书</a><br>二 <a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a><br>三 <a href=\"/2018/05/11/enkinx-配置任务/\">jenkins 配置java和Maven环境</a></p>\n<p><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/总图.png\" alt=\"logo\"></p>\n<h1 id=\"一配置任务\"><a href=\"#一配置任务\" class=\"headerlink\" title=\"一配置任务\"></a>一配置任务</h1><p>1.1点击 创建一个新任务<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/1.png\" alt=\"logo\"><br>1.2 输入名称  选择自由风格的软件项目<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/2.png\" alt=\"logo\"><br>1.3新增文本参数<br>1.3.1参数docker.image.prefix: 私有库域名<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/3.png\" alt=\"logo\"><br>1.3.2参数docker.registry：私有库地址<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/4.png\" alt=\"logo\"><br>1.3.3参数docker.servcerId：刚才maven配置 私有库用户名和密码<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/5.png\" alt=\"logo\"><br>1.3.4参数version<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/6.png\" alt=\"logo\"><br>1.4配置 git库<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/7.png\" alt=\"logo\"><br>1.5构建步骤添加 执行Shell脚本<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/8.png\" alt=\"logo\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脚本命令：</span><br><span class=\"line\">echo $WORKSPACE</span><br><span class=\"line\">echo $MAVEN_HOME</span><br><span class=\"line\">cd $WORKSPACE/Eureka</span><br><span class=\"line\">$MAVEN_HOME/bin/mvn clean package docker:build -DpushImage -Ddocker.image.prefix=$docker_image_prefix -Ddocker.registry=$docker_registry -Ddocker.servcerId=$docker_servcerId -Dtag.version=$version</span><br></pre></td></tr></table></figure></p>\n<p>保存</p>\n<h1 id=\"二-配置jenkins用户可以执行docker-命令\"><a href=\"#二-配置jenkins用户可以执行docker-命令\" class=\"headerlink\" title=\"二 配置jenkins用户可以执行docker 命令\"></a>二 配置jenkins用户可以执行docker 命令</h1><p>liunx用户 使用jenkins 用户启动jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/multi-user.target.wants/docker.service</span><br><span class=\"line\"> ExecStart=/usr/bin/dockerd  -G jenkins</span><br></pre></td></tr></table></figure></p>\n<p> -G表示 jenkins用户可以执行docker 命令<br> <img src=\"/2018/05/11/-jenkins-配置maven打包git代码/9.png\" alt=\"logo\"></p>\n<p> 重新加载配置<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br></pre></td></tr></table></figure></p>\n<p>  重新启动docker<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三执行任务\"><a href=\"#三执行任务\" class=\"headerlink\" title=\"三执行任务\"></a>三执行任务</h1><p>3.1 点击 Build with Parameters<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/10.png\" alt=\"logo\"><br>3.2 点击开始创建<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/11.png\" alt=\"logo\"><br>3.3查看脚本执行情况<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/12.png\" alt=\"logo\"><br>3.4成功后查看私有仓库目录<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/132.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一 <a href=\"/2018/05/11/-jenkins-配置git证书/\">jenkins-配置git证书</a><br>二 <a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a><br>三 <a href=\"/2018/05/11/enkinx-配置任务/\">jenkins 配置java和Maven环境</a></p>\n<p><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/总图.png\" alt=\"logo\"></p>\n<h1 id=\"一配置任务\"><a href=\"#一配置任务\" class=\"headerlink\" title=\"一配置任务\"></a>一配置任务</h1><p>1.1点击 创建一个新任务<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/1.png\" alt=\"logo\"><br>1.2 输入名称  选择自由风格的软件项目<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/2.png\" alt=\"logo\"><br>1.3新增文本参数<br>1.3.1参数docker.image.prefix: 私有库域名<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/3.png\" alt=\"logo\"><br>1.3.2参数docker.registry：私有库地址<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/4.png\" alt=\"logo\"><br>1.3.3参数docker.servcerId：刚才maven配置 私有库用户名和密码<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/5.png\" alt=\"logo\"><br>1.3.4参数version<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/6.png\" alt=\"logo\"><br>1.4配置 git库<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/7.png\" alt=\"logo\"><br>1.5构建步骤添加 执行Shell脚本<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/8.png\" alt=\"logo\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脚本命令：</span><br><span class=\"line\">echo $WORKSPACE</span><br><span class=\"line\">echo $MAVEN_HOME</span><br><span class=\"line\">cd $WORKSPACE/Eureka</span><br><span class=\"line\">$MAVEN_HOME/bin/mvn clean package docker:build -DpushImage -Ddocker.image.prefix=$docker_image_prefix -Ddocker.registry=$docker_registry -Ddocker.servcerId=$docker_servcerId -Dtag.version=$version</span><br></pre></td></tr></table></figure></p>\n<p>保存</p>\n<h1 id=\"二-配置jenkins用户可以执行docker-命令\"><a href=\"#二-配置jenkins用户可以执行docker-命令\" class=\"headerlink\" title=\"二 配置jenkins用户可以执行docker 命令\"></a>二 配置jenkins用户可以执行docker 命令</h1><p>liunx用户 使用jenkins 用户启动jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/multi-user.target.wants/docker.service</span><br><span class=\"line\"> ExecStart=/usr/bin/dockerd  -G jenkins</span><br></pre></td></tr></table></figure></p>\n<p> -G表示 jenkins用户可以执行docker 命令<br> <img src=\"/2018/05/11/-jenkins-配置maven打包git代码/9.png\" alt=\"logo\"></p>\n<p> 重新加载配置<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br></pre></td></tr></table></figure></p>\n<p>  重新启动docker<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三执行任务\"><a href=\"#三执行任务\" class=\"headerlink\" title=\"三执行任务\"></a>三执行任务</h1><p>3.1 点击 Build with Parameters<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/10.png\" alt=\"logo\"><br>3.2 点击开始创建<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/11.png\" alt=\"logo\"><br>3.3查看脚本执行情况<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/12.png\" alt=\"logo\"><br>3.4成功后查看私有仓库目录<br><img src=\"/2018/05/11/-jenkins-配置maven打包git代码/132.png\" alt=\"logo\"></p>\n"},{"title":"底层代码构造sql忽略NUll条件","author":"wen","date":"2019-05-06T03:00:00.000Z","_content":"代码没有判断查询的值null，导致把全部数据load内存里，这样系统崩溃\n\n代码：com.test.common.jpa.repository.JpaRepoUtil\n```\n\n\tprivate static StringBuilder generateQlForQueryByProperties(Map<String, Object> propertiesMap,\n\t\t\tStringBuilder ql, Map<Integer, Object> params, FindByPropertiesType findType) {\n\t\tint index = 0;\n\t\t\n\t\tif (propertiesMap != null && !propertiesMap.isEmpty()) {\n\t\t\tboolean doDeleteAnd = false, doDeletewWere = true;\n\t\t\tql.append(\" where \");\n\t        for (Entry<String,Object> entry: propertiesMap.entrySet()) {\n\t        \tObject value = entry.getValue();\n                //忽略null 的值\n\t        \tif (value != null) {\n\t        \t\tif (doDeletewWere) \n\t        \t\t\tdoDeletewWere = false;\n\t        \t\t\n\t        \t\tif (value instanceof String && (findType == null || FindByPropertiesType.Fuzzy.equals(findType))) {\n\t        \t\t\tString valueStr = (String) entry.getValue();\n\t        \t\t\tql.append(\"upper(model.\" + entry.getKey() + \") like :propertyValue\" + index + \" and \");\n\t        \t\t\tparams.put(index++, \"%\" + valueStr.trim().toUpperCase() + \"%\");\n\t        \t\t} else if(QueryValue.NULL.equals(value)) {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \" is null and \");\n\t        \t\t} else if(QueryValue.NotNull.equals(value)) {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \" is not null and \");\n\t        \t\t} else {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \"=:propertyValue\" + index + \" and \");\n\t        \t\t\tparams.put(index++, entry.getValue());\n\t        \t\t}\n\t        \t\t\n\t        \t\tdoDeleteAnd = true;\n\t        \t}\n\t        }\n\t        if (doDeleteAnd)\n\t        \tql = ql.delete(ql.toString().lastIndexOf(\" and \"), ql.toString().length());\n\t        if (doDeletewWere)\n        \t\tql = ql.delete(ql.toString().lastIndexOf(\" where \"), ql.toString().length());\n\t\t}\n\t\treturn ql;\n\t}\n```\n\n![upload successful](A问题/1.png)\n\n总结：需要深度了解底层代码。","source":"_posts/A问题.md","raw":"title: 底层代码构造sql忽略NUll条件\nauthor: wen\ntags:\n  - jpa\ncategories:\n  - spring cloud\ndate: 2019-05-06 11:00:00\n---\n代码没有判断查询的值null，导致把全部数据load内存里，这样系统崩溃\n\n代码：com.test.common.jpa.repository.JpaRepoUtil\n```\n\n\tprivate static StringBuilder generateQlForQueryByProperties(Map<String, Object> propertiesMap,\n\t\t\tStringBuilder ql, Map<Integer, Object> params, FindByPropertiesType findType) {\n\t\tint index = 0;\n\t\t\n\t\tif (propertiesMap != null && !propertiesMap.isEmpty()) {\n\t\t\tboolean doDeleteAnd = false, doDeletewWere = true;\n\t\t\tql.append(\" where \");\n\t        for (Entry<String,Object> entry: propertiesMap.entrySet()) {\n\t        \tObject value = entry.getValue();\n                //忽略null 的值\n\t        \tif (value != null) {\n\t        \t\tif (doDeletewWere) \n\t        \t\t\tdoDeletewWere = false;\n\t        \t\t\n\t        \t\tif (value instanceof String && (findType == null || FindByPropertiesType.Fuzzy.equals(findType))) {\n\t        \t\t\tString valueStr = (String) entry.getValue();\n\t        \t\t\tql.append(\"upper(model.\" + entry.getKey() + \") like :propertyValue\" + index + \" and \");\n\t        \t\t\tparams.put(index++, \"%\" + valueStr.trim().toUpperCase() + \"%\");\n\t        \t\t} else if(QueryValue.NULL.equals(value)) {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \" is null and \");\n\t        \t\t} else if(QueryValue.NotNull.equals(value)) {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \" is not null and \");\n\t        \t\t} else {\n\t        \t\t\tql.append(\"model.\" + entry.getKey() + \"=:propertyValue\" + index + \" and \");\n\t        \t\t\tparams.put(index++, entry.getValue());\n\t        \t\t}\n\t        \t\t\n\t        \t\tdoDeleteAnd = true;\n\t        \t}\n\t        }\n\t        if (doDeleteAnd)\n\t        \tql = ql.delete(ql.toString().lastIndexOf(\" and \"), ql.toString().length());\n\t        if (doDeletewWere)\n        \t\tql = ql.delete(ql.toString().lastIndexOf(\" where \"), ql.toString().length());\n\t\t}\n\t\treturn ql;\n\t}\n```\n\n![upload successful](A问题/1.png)\n\n总结：需要深度了解底层代码。","slug":"A问题","published":1,"updated":"2019-06-09T15:13:13.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37e000gn6zqkrh0bdbb","content":"<p>代码没有判断查询的值null，导致把全部数据load内存里，这样系统崩溃</p>\n<p>代码：com.test.common.jpa.repository.JpaRepoUtil<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private static StringBuilder generateQlForQueryByProperties(Map&lt;String, Object&gt; propertiesMap,</span><br><span class=\"line\">\t\tStringBuilder ql, Map&lt;Integer, Object&gt; params, FindByPropertiesType findType) &#123;</span><br><span class=\"line\">\tint index = 0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tif (propertiesMap != null &amp;&amp; !propertiesMap.isEmpty()) &#123;</span><br><span class=\"line\">\t\tboolean doDeleteAnd = false, doDeletewWere = true;</span><br><span class=\"line\">\t\tql.append(&quot; where &quot;);</span><br><span class=\"line\">        for (Entry&lt;String,Object&gt; entry: propertiesMap.entrySet()) &#123;</span><br><span class=\"line\">        \tObject value = entry.getValue();</span><br><span class=\"line\">               //忽略null 的值</span><br><span class=\"line\">        \tif (value != null) &#123;</span><br><span class=\"line\">        \t\tif (doDeletewWere) </span><br><span class=\"line\">        \t\t\tdoDeletewWere = false;</span><br><span class=\"line\">        \t\t</span><br><span class=\"line\">        \t\tif (value instanceof String &amp;&amp; (findType == null || FindByPropertiesType.Fuzzy.equals(findType))) &#123;</span><br><span class=\"line\">        \t\t\tString valueStr = (String) entry.getValue();</span><br><span class=\"line\">        \t\t\tql.append(&quot;upper(model.&quot; + entry.getKey() + &quot;) like :propertyValue&quot; + index + &quot; and &quot;);</span><br><span class=\"line\">        \t\t\tparams.put(index++, &quot;%&quot; + valueStr.trim().toUpperCase() + &quot;%&quot;);</span><br><span class=\"line\">        \t\t&#125; else if(QueryValue.NULL.equals(value)) &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot; is null and &quot;);</span><br><span class=\"line\">        \t\t&#125; else if(QueryValue.NotNull.equals(value)) &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot; is not null and &quot;);</span><br><span class=\"line\">        \t\t&#125; else &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot;=:propertyValue&quot; + index + &quot; and &quot;);</span><br><span class=\"line\">        \t\t\tparams.put(index++, entry.getValue());</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t\t</span><br><span class=\"line\">        \t\tdoDeleteAnd = true;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (doDeleteAnd)</span><br><span class=\"line\">        \tql = ql.delete(ql.toString().lastIndexOf(&quot; and &quot;), ql.toString().length());</span><br><span class=\"line\">        if (doDeletewWere)</span><br><span class=\"line\">       \t\tql = ql.delete(ql.toString().lastIndexOf(&quot; where &quot;), ql.toString().length());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ql;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/05/06/A问题/1.png\" alt=\"upload successful\"></p>\n<p>总结：需要深度了解底层代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>代码没有判断查询的值null，导致把全部数据load内存里，这样系统崩溃</p>\n<p>代码：com.test.common.jpa.repository.JpaRepoUtil<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private static StringBuilder generateQlForQueryByProperties(Map&lt;String, Object&gt; propertiesMap,</span><br><span class=\"line\">\t\tStringBuilder ql, Map&lt;Integer, Object&gt; params, FindByPropertiesType findType) &#123;</span><br><span class=\"line\">\tint index = 0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tif (propertiesMap != null &amp;&amp; !propertiesMap.isEmpty()) &#123;</span><br><span class=\"line\">\t\tboolean doDeleteAnd = false, doDeletewWere = true;</span><br><span class=\"line\">\t\tql.append(&quot; where &quot;);</span><br><span class=\"line\">        for (Entry&lt;String,Object&gt; entry: propertiesMap.entrySet()) &#123;</span><br><span class=\"line\">        \tObject value = entry.getValue();</span><br><span class=\"line\">               //忽略null 的值</span><br><span class=\"line\">        \tif (value != null) &#123;</span><br><span class=\"line\">        \t\tif (doDeletewWere) </span><br><span class=\"line\">        \t\t\tdoDeletewWere = false;</span><br><span class=\"line\">        \t\t</span><br><span class=\"line\">        \t\tif (value instanceof String &amp;&amp; (findType == null || FindByPropertiesType.Fuzzy.equals(findType))) &#123;</span><br><span class=\"line\">        \t\t\tString valueStr = (String) entry.getValue();</span><br><span class=\"line\">        \t\t\tql.append(&quot;upper(model.&quot; + entry.getKey() + &quot;) like :propertyValue&quot; + index + &quot; and &quot;);</span><br><span class=\"line\">        \t\t\tparams.put(index++, &quot;%&quot; + valueStr.trim().toUpperCase() + &quot;%&quot;);</span><br><span class=\"line\">        \t\t&#125; else if(QueryValue.NULL.equals(value)) &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot; is null and &quot;);</span><br><span class=\"line\">        \t\t&#125; else if(QueryValue.NotNull.equals(value)) &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot; is not null and &quot;);</span><br><span class=\"line\">        \t\t&#125; else &#123;</span><br><span class=\"line\">        \t\t\tql.append(&quot;model.&quot; + entry.getKey() + &quot;=:propertyValue&quot; + index + &quot; and &quot;);</span><br><span class=\"line\">        \t\t\tparams.put(index++, entry.getValue());</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t\t</span><br><span class=\"line\">        \t\tdoDeleteAnd = true;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (doDeleteAnd)</span><br><span class=\"line\">        \tql = ql.delete(ql.toString().lastIndexOf(&quot; and &quot;), ql.toString().length());</span><br><span class=\"line\">        if (doDeletewWere)</span><br><span class=\"line\">       \t\tql = ql.delete(ql.toString().lastIndexOf(&quot; where &quot;), ql.toString().length());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ql;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/05/06/A问题/1.png\" alt=\"upload successful\"></p>\n<p>总结：需要深度了解底层代码。</p>\n"},{"title":"RabbitMq","author":"wen","date":"2019-11-22T08:13:00.000Z","_content":"\n# 思考问题：为什么要使用消息队列\n 一个系统需要调用多个系统或者模块，互相之间调用很复杂，维护起来很麻烦。\n\n## 情景1--未使用队列前\n![logo](bbitMq/1.png)\n如果现在新增e系统，就需要a系统的开发改系统；\n如果现在D不需要A系统调用接口，就需要A系统的开发改系统\n……\n\n## 消息队列优点--解耦\n![logo](bbitMq/2.png)\n哪个系统需要数据，自己去MQ里消费数据\n\n## 情景2-未使用队列\n![logo](bbitMq/3.png)\n这样，系统调用太多接口，影响用户体验\n\n## 消息队列优点--异步\n![logo](bbitMq/4.png)\n\n# 思考：引入消息队列会存在哪些问题\n\n## 消息队列存在问题：\n* 1 系统可用性降低\n\n系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好，ABCD四个系统好哈的，没啥问题，\n现在改为MQ,若MQ挂了怎么办\n\n* 系统复杂性提高\n\n例如：现在使用了MQ,你需要考虑消息是否重复消费？ 怎么处理消息丢失情况？问题大一堆，很痛苦吧\n\n* 系统一致性问题\n\n使用MQ后，BD系统写库成功，结果c系统写库失败，现在怎么办？\n\n## RabbitMq可靠性--镜像集群模式\n![logo](bbitMq/5.png)\n\n## 数据丢失怎么办\n\n![logo](bbitMq/7.png)\n生产者\n* 1 设置channel 设置成confirm的模式\n* 2 发送一个消息\n* 3  RabbitMq如果接收到了这条消息的话，\n就会回调你系统里一个接口，通知消息已经收到了；\n如果接收消息失败，也通知你消息接收失败，\n此时候你可以进行重推\n\nRabbitMq:\n* rabbitmq:持久化磁盘（queue 持久化，发送消息，deliveryMode=2）\n\n消费者：\n* auto ack机制，消费到了一条消息\n\n## 数据丢失处理方案图\n![logo](bbitMq/6.png)\n\n## 关于重复消费\n解决方案：每个消息都有一个唯一id，如果已经处理过无需再次处理\n\n## 其他问题\n\n* 1 ）如果Mq数据挤压怎么办\n 解决方案：\n  第一步修复consumer故障\n  \n  第二步 临时部署多一些consumer应用进行消费\n* 2）rabbitmq设置了消息过期时间，导致数据丢失了，怎么办\n解决方案：生产者消息重发\n* 3）mq数据挤压，磁盘满了怎么办？\n解决方案：临时写一个程序把消费一个放弃一个；在进行重推消息\n\n\n\n\n\n","source":"_posts/bbitMq.md","raw":"title: RabbitMq\nauthor: wen\ntags:\n  - RabbitMq\n  - 消息队列\ncategories:\n  - RabbitMq\n  - 消息队列\ndate: 2019-11-22 16:13:00\n---\n\n# 思考问题：为什么要使用消息队列\n 一个系统需要调用多个系统或者模块，互相之间调用很复杂，维护起来很麻烦。\n\n## 情景1--未使用队列前\n![logo](bbitMq/1.png)\n如果现在新增e系统，就需要a系统的开发改系统；\n如果现在D不需要A系统调用接口，就需要A系统的开发改系统\n……\n\n## 消息队列优点--解耦\n![logo](bbitMq/2.png)\n哪个系统需要数据，自己去MQ里消费数据\n\n## 情景2-未使用队列\n![logo](bbitMq/3.png)\n这样，系统调用太多接口，影响用户体验\n\n## 消息队列优点--异步\n![logo](bbitMq/4.png)\n\n# 思考：引入消息队列会存在哪些问题\n\n## 消息队列存在问题：\n* 1 系统可用性降低\n\n系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好，ABCD四个系统好哈的，没啥问题，\n现在改为MQ,若MQ挂了怎么办\n\n* 系统复杂性提高\n\n例如：现在使用了MQ,你需要考虑消息是否重复消费？ 怎么处理消息丢失情况？问题大一堆，很痛苦吧\n\n* 系统一致性问题\n\n使用MQ后，BD系统写库成功，结果c系统写库失败，现在怎么办？\n\n## RabbitMq可靠性--镜像集群模式\n![logo](bbitMq/5.png)\n\n## 数据丢失怎么办\n\n![logo](bbitMq/7.png)\n生产者\n* 1 设置channel 设置成confirm的模式\n* 2 发送一个消息\n* 3  RabbitMq如果接收到了这条消息的话，\n就会回调你系统里一个接口，通知消息已经收到了；\n如果接收消息失败，也通知你消息接收失败，\n此时候你可以进行重推\n\nRabbitMq:\n* rabbitmq:持久化磁盘（queue 持久化，发送消息，deliveryMode=2）\n\n消费者：\n* auto ack机制，消费到了一条消息\n\n## 数据丢失处理方案图\n![logo](bbitMq/6.png)\n\n## 关于重复消费\n解决方案：每个消息都有一个唯一id，如果已经处理过无需再次处理\n\n## 其他问题\n\n* 1 ）如果Mq数据挤压怎么办\n 解决方案：\n  第一步修复consumer故障\n  \n  第二步 临时部署多一些consumer应用进行消费\n* 2）rabbitmq设置了消息过期时间，导致数据丢失了，怎么办\n解决方案：生产者消息重发\n* 3）mq数据挤压，磁盘满了怎么办？\n解决方案：临时写一个程序把消费一个放弃一个；在进行重推消息\n\n\n\n\n\n","slug":"bbitMq","published":1,"updated":"2020-02-17T15:08:47.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37h000kn6zqu0tbx4d0","content":"<h1 id=\"思考问题：为什么要使用消息队列\"><a href=\"#思考问题：为什么要使用消息队列\" class=\"headerlink\" title=\"思考问题：为什么要使用消息队列\"></a>思考问题：为什么要使用消息队列</h1><p> 一个系统需要调用多个系统或者模块，互相之间调用很复杂，维护起来很麻烦。</p>\n<h2 id=\"情景1–未使用队列前\"><a href=\"#情景1–未使用队列前\" class=\"headerlink\" title=\"情景1–未使用队列前\"></a>情景1–未使用队列前</h2><p><img src=\"/2019/11/22/bbitMq/1.png\" alt=\"logo\"><br>如果现在新增e系统，就需要a系统的开发改系统；<br>如果现在D不需要A系统调用接口，就需要A系统的开发改系统<br>……</p>\n<h2 id=\"消息队列优点–解耦\"><a href=\"#消息队列优点–解耦\" class=\"headerlink\" title=\"消息队列优点–解耦\"></a>消息队列优点–解耦</h2><p><img src=\"/2019/11/22/bbitMq/2.png\" alt=\"logo\"><br>哪个系统需要数据，自己去MQ里消费数据</p>\n<h2 id=\"情景2-未使用队列\"><a href=\"#情景2-未使用队列\" class=\"headerlink\" title=\"情景2-未使用队列\"></a>情景2-未使用队列</h2><p><img src=\"/2019/11/22/bbitMq/3.png\" alt=\"logo\"><br>这样，系统调用太多接口，影响用户体验</p>\n<h2 id=\"消息队列优点–异步\"><a href=\"#消息队列优点–异步\" class=\"headerlink\" title=\"消息队列优点–异步\"></a>消息队列优点–异步</h2><p><img src=\"/2019/11/22/bbitMq/4.png\" alt=\"logo\"></p>\n<h1 id=\"思考：引入消息队列会存在哪些问题\"><a href=\"#思考：引入消息队列会存在哪些问题\" class=\"headerlink\" title=\"思考：引入消息队列会存在哪些问题\"></a>思考：引入消息队列会存在哪些问题</h1><h2 id=\"消息队列存在问题：\"><a href=\"#消息队列存在问题：\" class=\"headerlink\" title=\"消息队列存在问题：\"></a>消息队列存在问题：</h2><ul>\n<li>1 系统可用性降低</li>\n</ul>\n<p>系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好，ABCD四个系统好哈的，没啥问题，<br>现在改为MQ,若MQ挂了怎么办</p>\n<ul>\n<li>系统复杂性提高</li>\n</ul>\n<p>例如：现在使用了MQ,你需要考虑消息是否重复消费？ 怎么处理消息丢失情况？问题大一堆，很痛苦吧</p>\n<ul>\n<li>系统一致性问题</li>\n</ul>\n<p>使用MQ后，BD系统写库成功，结果c系统写库失败，现在怎么办？</p>\n<h2 id=\"RabbitMq可靠性–镜像集群模式\"><a href=\"#RabbitMq可靠性–镜像集群模式\" class=\"headerlink\" title=\"RabbitMq可靠性–镜像集群模式\"></a>RabbitMq可靠性–镜像集群模式</h2><p><img src=\"/2019/11/22/bbitMq/5.png\" alt=\"logo\"></p>\n<h2 id=\"数据丢失怎么办\"><a href=\"#数据丢失怎么办\" class=\"headerlink\" title=\"数据丢失怎么办\"></a>数据丢失怎么办</h2><p><img src=\"/2019/11/22/bbitMq/7.png\" alt=\"logo\"><br>生产者</p>\n<ul>\n<li>1 设置channel 设置成confirm的模式</li>\n<li>2 发送一个消息</li>\n<li>3  RabbitMq如果接收到了这条消息的话，<br>就会回调你系统里一个接口，通知消息已经收到了；<br>如果接收消息失败，也通知你消息接收失败，<br>此时候你可以进行重推</li>\n</ul>\n<p>RabbitMq:</p>\n<ul>\n<li>rabbitmq:持久化磁盘（queue 持久化，发送消息，deliveryMode=2）</li>\n</ul>\n<p>消费者：</p>\n<ul>\n<li>auto ack机制，消费到了一条消息</li>\n</ul>\n<h2 id=\"数据丢失处理方案图\"><a href=\"#数据丢失处理方案图\" class=\"headerlink\" title=\"数据丢失处理方案图\"></a>数据丢失处理方案图</h2><p><img src=\"/2019/11/22/bbitMq/6.png\" alt=\"logo\"></p>\n<h2 id=\"关于重复消费\"><a href=\"#关于重复消费\" class=\"headerlink\" title=\"关于重复消费\"></a>关于重复消费</h2><p>解决方案：每个消息都有一个唯一id，如果已经处理过无需再次处理</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><ul>\n<li><p>1 ）如果Mq数据挤压怎么办<br>解决方案：<br>第一步修复consumer故障</p>\n<p>第二步 临时部署多一些consumer应用进行消费</p>\n</li>\n<li>2）rabbitmq设置了消息过期时间，导致数据丢失了，怎么办<br>解决方案：生产者消息重发</li>\n<li>3）mq数据挤压，磁盘满了怎么办？<br>解决方案：临时写一个程序把消费一个放弃一个；在进行重推消息</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"思考问题：为什么要使用消息队列\"><a href=\"#思考问题：为什么要使用消息队列\" class=\"headerlink\" title=\"思考问题：为什么要使用消息队列\"></a>思考问题：为什么要使用消息队列</h1><p> 一个系统需要调用多个系统或者模块，互相之间调用很复杂，维护起来很麻烦。</p>\n<h2 id=\"情景1–未使用队列前\"><a href=\"#情景1–未使用队列前\" class=\"headerlink\" title=\"情景1–未使用队列前\"></a>情景1–未使用队列前</h2><p><img src=\"/2019/11/22/bbitMq/1.png\" alt=\"logo\"><br>如果现在新增e系统，就需要a系统的开发改系统；<br>如果现在D不需要A系统调用接口，就需要A系统的开发改系统<br>……</p>\n<h2 id=\"消息队列优点–解耦\"><a href=\"#消息队列优点–解耦\" class=\"headerlink\" title=\"消息队列优点–解耦\"></a>消息队列优点–解耦</h2><p><img src=\"/2019/11/22/bbitMq/2.png\" alt=\"logo\"><br>哪个系统需要数据，自己去MQ里消费数据</p>\n<h2 id=\"情景2-未使用队列\"><a href=\"#情景2-未使用队列\" class=\"headerlink\" title=\"情景2-未使用队列\"></a>情景2-未使用队列</h2><p><img src=\"/2019/11/22/bbitMq/3.png\" alt=\"logo\"><br>这样，系统调用太多接口，影响用户体验</p>\n<h2 id=\"消息队列优点–异步\"><a href=\"#消息队列优点–异步\" class=\"headerlink\" title=\"消息队列优点–异步\"></a>消息队列优点–异步</h2><p><img src=\"/2019/11/22/bbitMq/4.png\" alt=\"logo\"></p>\n<h1 id=\"思考：引入消息队列会存在哪些问题\"><a href=\"#思考：引入消息队列会存在哪些问题\" class=\"headerlink\" title=\"思考：引入消息队列会存在哪些问题\"></a>思考：引入消息队列会存在哪些问题</h1><h2 id=\"消息队列存在问题：\"><a href=\"#消息队列存在问题：\" class=\"headerlink\" title=\"消息队列存在问题：\"></a>消息队列存在问题：</h2><ul>\n<li>1 系统可用性降低</li>\n</ul>\n<p>系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好，ABCD四个系统好哈的，没啥问题，<br>现在改为MQ,若MQ挂了怎么办</p>\n<ul>\n<li>系统复杂性提高</li>\n</ul>\n<p>例如：现在使用了MQ,你需要考虑消息是否重复消费？ 怎么处理消息丢失情况？问题大一堆，很痛苦吧</p>\n<ul>\n<li>系统一致性问题</li>\n</ul>\n<p>使用MQ后，BD系统写库成功，结果c系统写库失败，现在怎么办？</p>\n<h2 id=\"RabbitMq可靠性–镜像集群模式\"><a href=\"#RabbitMq可靠性–镜像集群模式\" class=\"headerlink\" title=\"RabbitMq可靠性–镜像集群模式\"></a>RabbitMq可靠性–镜像集群模式</h2><p><img src=\"/2019/11/22/bbitMq/5.png\" alt=\"logo\"></p>\n<h2 id=\"数据丢失怎么办\"><a href=\"#数据丢失怎么办\" class=\"headerlink\" title=\"数据丢失怎么办\"></a>数据丢失怎么办</h2><p><img src=\"/2019/11/22/bbitMq/7.png\" alt=\"logo\"><br>生产者</p>\n<ul>\n<li>1 设置channel 设置成confirm的模式</li>\n<li>2 发送一个消息</li>\n<li>3  RabbitMq如果接收到了这条消息的话，<br>就会回调你系统里一个接口，通知消息已经收到了；<br>如果接收消息失败，也通知你消息接收失败，<br>此时候你可以进行重推</li>\n</ul>\n<p>RabbitMq:</p>\n<ul>\n<li>rabbitmq:持久化磁盘（queue 持久化，发送消息，deliveryMode=2）</li>\n</ul>\n<p>消费者：</p>\n<ul>\n<li>auto ack机制，消费到了一条消息</li>\n</ul>\n<h2 id=\"数据丢失处理方案图\"><a href=\"#数据丢失处理方案图\" class=\"headerlink\" title=\"数据丢失处理方案图\"></a>数据丢失处理方案图</h2><p><img src=\"/2019/11/22/bbitMq/6.png\" alt=\"logo\"></p>\n<h2 id=\"关于重复消费\"><a href=\"#关于重复消费\" class=\"headerlink\" title=\"关于重复消费\"></a>关于重复消费</h2><p>解决方案：每个消息都有一个唯一id，如果已经处理过无需再次处理</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><ul>\n<li><p>1 ）如果Mq数据挤压怎么办<br>解决方案：<br>第一步修复consumer故障</p>\n<p>第二步 临时部署多一些consumer应用进行消费</p>\n</li>\n<li>2）rabbitmq设置了消息过期时间，导致数据丢失了，怎么办<br>解决方案：生产者消息重发</li>\n<li>3）mq数据挤压，磁盘满了怎么办？<br>解决方案：临时写一个程序把消费一个放弃一个；在进行重推消息</li>\n</ul>\n"},{"title":"apacheHttpd日志说明","author":"wen","date":"2019-11-21T02:00:00.000Z","_content":"# 日志目录\n* 1,首先，你要确定你的apache工作路径:ps -aux\n* 2,其次，你可查看httpd.conf,看是否有特定的设置，一般logs文件夹与conf文件夹在同一个父目录下；\n* 3，访问日志为access_log，错误日志为error_log；\n* 4，如果上面的尝试都失败，那你再在/var/log/messages看看\n\n## access_log 访问日志\naccess_log为访问日志,记录所有对apache服务器进行请求的访问,它的位置和内容由CustomLog指令控制,LogFormat指令可以用来简化该日志的内容和格式 \n\n##  error_log 错误日志\nerror_log为错误日志,记录下任何错误的处理请求,它的位置和内容由ErrorLog指令控制,通常服务器出现什么错误,首先对它进行查阅,是一个最重要的日志文件。\n\n看一条典型的access_log的日志记录：\n61.155.149.20 - - [13/Jan/2017:15:42:47 +0800] \"GET /category/db/ HTTP/1.1\" 200 23225\n\n1).61.155.149.20 \n这是一个请求到apache服务器的客户端ip,默认的情况下,第一项信息只是远程主机的ip地址,但我们如果需要apache查出主机的名字,可以将 HostnameLookups设置为on,不推荐使用，会大大降低网站速度。\n\n2). - \n这一项是空白,使用\"-\"来代替,用于记录浏览者的标识，对于大多数浏览器，这项都是空。\n\n3). - \n也为空，记录浏览者进行身份验证时提供的名字，大多数这项也为空。\n\n4). [13/Jan/2017:15:42:47 +0800]\n第四项是记录请求的时间,格式为[day/month/year:hour:minute:second zone],最后的+0800表示服务器所处的时区为东八区\n\n5). \"GET /category/db/ HTTP/1.1\" \n这一项最有用,首先,它告诉我们的服务器收到的是一个GET请求,其次,是客户端请求的资源路径,第三,客户端使用的协议时HTTP/1.1,整个格式为\"%m %U%q %H\",即\"请求方法/访问路径/协议\"\n\n6). 200 \n这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为200，表示服务器已经成 功的响应了客户端的请求,一般来说,这项值以2开头的表示请求成功,以3开头的表示重定向,以4开头的标示客户端存在某些的错误,以5开头的标示服务器端 存在某些错误。\n\n7).23225 \n这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少\n","source":"_posts/acheHttpd日志说明.md","raw":"title: apacheHttpd日志说明\nauthor: wen\ntags:\n  - httpd\ncategories:\n  - apache\ndate: 2019-11-21 10:00:00\n---\n# 日志目录\n* 1,首先，你要确定你的apache工作路径:ps -aux\n* 2,其次，你可查看httpd.conf,看是否有特定的设置，一般logs文件夹与conf文件夹在同一个父目录下；\n* 3，访问日志为access_log，错误日志为error_log；\n* 4，如果上面的尝试都失败，那你再在/var/log/messages看看\n\n## access_log 访问日志\naccess_log为访问日志,记录所有对apache服务器进行请求的访问,它的位置和内容由CustomLog指令控制,LogFormat指令可以用来简化该日志的内容和格式 \n\n##  error_log 错误日志\nerror_log为错误日志,记录下任何错误的处理请求,它的位置和内容由ErrorLog指令控制,通常服务器出现什么错误,首先对它进行查阅,是一个最重要的日志文件。\n\n看一条典型的access_log的日志记录：\n61.155.149.20 - - [13/Jan/2017:15:42:47 +0800] \"GET /category/db/ HTTP/1.1\" 200 23225\n\n1).61.155.149.20 \n这是一个请求到apache服务器的客户端ip,默认的情况下,第一项信息只是远程主机的ip地址,但我们如果需要apache查出主机的名字,可以将 HostnameLookups设置为on,不推荐使用，会大大降低网站速度。\n\n2). - \n这一项是空白,使用\"-\"来代替,用于记录浏览者的标识，对于大多数浏览器，这项都是空。\n\n3). - \n也为空，记录浏览者进行身份验证时提供的名字，大多数这项也为空。\n\n4). [13/Jan/2017:15:42:47 +0800]\n第四项是记录请求的时间,格式为[day/month/year:hour:minute:second zone],最后的+0800表示服务器所处的时区为东八区\n\n5). \"GET /category/db/ HTTP/1.1\" \n这一项最有用,首先,它告诉我们的服务器收到的是一个GET请求,其次,是客户端请求的资源路径,第三,客户端使用的协议时HTTP/1.1,整个格式为\"%m %U%q %H\",即\"请求方法/访问路径/协议\"\n\n6). 200 \n这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为200，表示服务器已经成 功的响应了客户端的请求,一般来说,这项值以2开头的表示请求成功,以3开头的表示重定向,以4开头的标示客户端存在某些的错误,以5开头的标示服务器端 存在某些错误。\n\n7).23225 \n这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少\n","slug":"acheHttpd日志说明","published":1,"updated":"2020-02-17T15:08:47.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37j000ln6zq0rqv6fw5","content":"<h1 id=\"日志目录\"><a href=\"#日志目录\" class=\"headerlink\" title=\"日志目录\"></a>日志目录</h1><ul>\n<li>1,首先，你要确定你的apache工作路径:ps -aux</li>\n<li>2,其次，你可查看httpd.conf,看是否有特定的设置，一般logs文件夹与conf文件夹在同一个父目录下；</li>\n<li>3，访问日志为access_log，错误日志为error_log；</li>\n<li>4，如果上面的尝试都失败，那你再在/var/log/messages看看</li>\n</ul>\n<h2 id=\"access-log-访问日志\"><a href=\"#access-log-访问日志\" class=\"headerlink\" title=\"access_log 访问日志\"></a>access_log 访问日志</h2><p>access_log为访问日志,记录所有对apache服务器进行请求的访问,它的位置和内容由CustomLog指令控制,LogFormat指令可以用来简化该日志的内容和格式 </p>\n<h2 id=\"error-log-错误日志\"><a href=\"#error-log-错误日志\" class=\"headerlink\" title=\"error_log 错误日志\"></a>error_log 错误日志</h2><p>error_log为错误日志,记录下任何错误的处理请求,它的位置和内容由ErrorLog指令控制,通常服务器出现什么错误,首先对它进行查阅,是一个最重要的日志文件。</p>\n<p>看一条典型的access_log的日志记录：<br>61.155.149.20 - - [13/Jan/2017:15:42:47 +0800] “GET /category/db/ HTTP/1.1” 200 23225</p>\n<p>1).61.155.149.20<br>这是一个请求到apache服务器的客户端ip,默认的情况下,第一项信息只是远程主机的ip地址,但我们如果需要apache查出主机的名字,可以将 HostnameLookups设置为on,不推荐使用，会大大降低网站速度。</p>\n<p>2). -<br>这一项是空白,使用”-“来代替,用于记录浏览者的标识，对于大多数浏览器，这项都是空。</p>\n<p>3). -<br>也为空，记录浏览者进行身份验证时提供的名字，大多数这项也为空。</p>\n<p>4). [13/Jan/2017:15:42:47 +0800]<br>第四项是记录请求的时间,格式为[day/month/year:hour:minute:second zone],最后的+0800表示服务器所处的时区为东八区</p>\n<p>5). “GET /category/db/ HTTP/1.1”<br>这一项最有用,首先,它告诉我们的服务器收到的是一个GET请求,其次,是客户端请求的资源路径,第三,客户端使用的协议时HTTP/1.1,整个格式为”%m %U%q %H”,即”请求方法/访问路径/协议”</p>\n<p>6). 200<br>这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为200，表示服务器已经成 功的响应了客户端的请求,一般来说,这项值以2开头的表示请求成功,以3开头的表示重定向,以4开头的标示客户端存在某些的错误,以5开头的标示服务器端 存在某些错误。</p>\n<p>7).23225<br>这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"日志目录\"><a href=\"#日志目录\" class=\"headerlink\" title=\"日志目录\"></a>日志目录</h1><ul>\n<li>1,首先，你要确定你的apache工作路径:ps -aux</li>\n<li>2,其次，你可查看httpd.conf,看是否有特定的设置，一般logs文件夹与conf文件夹在同一个父目录下；</li>\n<li>3，访问日志为access_log，错误日志为error_log；</li>\n<li>4，如果上面的尝试都失败，那你再在/var/log/messages看看</li>\n</ul>\n<h2 id=\"access-log-访问日志\"><a href=\"#access-log-访问日志\" class=\"headerlink\" title=\"access_log 访问日志\"></a>access_log 访问日志</h2><p>access_log为访问日志,记录所有对apache服务器进行请求的访问,它的位置和内容由CustomLog指令控制,LogFormat指令可以用来简化该日志的内容和格式 </p>\n<h2 id=\"error-log-错误日志\"><a href=\"#error-log-错误日志\" class=\"headerlink\" title=\"error_log 错误日志\"></a>error_log 错误日志</h2><p>error_log为错误日志,记录下任何错误的处理请求,它的位置和内容由ErrorLog指令控制,通常服务器出现什么错误,首先对它进行查阅,是一个最重要的日志文件。</p>\n<p>看一条典型的access_log的日志记录：<br>61.155.149.20 - - [13/Jan/2017:15:42:47 +0800] “GET /category/db/ HTTP/1.1” 200 23225</p>\n<p>1).61.155.149.20<br>这是一个请求到apache服务器的客户端ip,默认的情况下,第一项信息只是远程主机的ip地址,但我们如果需要apache查出主机的名字,可以将 HostnameLookups设置为on,不推荐使用，会大大降低网站速度。</p>\n<p>2). -<br>这一项是空白,使用”-“来代替,用于记录浏览者的标识，对于大多数浏览器，这项都是空。</p>\n<p>3). -<br>也为空，记录浏览者进行身份验证时提供的名字，大多数这项也为空。</p>\n<p>4). [13/Jan/2017:15:42:47 +0800]<br>第四项是记录请求的时间,格式为[day/month/year:hour:minute:second zone],最后的+0800表示服务器所处的时区为东八区</p>\n<p>5). “GET /category/db/ HTTP/1.1”<br>这一项最有用,首先,它告诉我们的服务器收到的是一个GET请求,其次,是客户端请求的资源路径,第三,客户端使用的协议时HTTP/1.1,整个格式为”%m %U%q %H”,即”请求方法/访问路径/协议”</p>\n<p>6). 200<br>这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为200，表示服务器已经成 功的响应了客户端的请求,一般来说,这项值以2开头的表示请求成功,以3开头的表示重定向,以4开头的标示客户端存在某些的错误,以5开头的标示服务器端 存在某些错误。</p>\n<p>7).23225<br>这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少</p>\n"},{"title":"[Java] 查看占用 CPU 最高的线程","author":"wen","date":"2019-11-13T03:15:00.000Z","_content":"# 步骤\n* top 命令找出应用 pid-app\n* top -Hp <pid-app> 命令找出线程 pid-thread\n* printf '%x\\n' <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex\n* jstack <pid-app> | grep 'pid-thread-hex' 命令查看线程信息\n# 示例\n* 1.top 命令找出应用 pid-app\n![logo](ava-查看占用-CPU-最高的线程/1.png)\n\n应用 pid 为8790\n\n* top -Hp <pid-app> 命令找出线程 pid-thread\n![logo](ava-查看占用-CPU-最高的线程/2.png)\n\n线程 pid 为9702\n\n* printf '%x\\n' <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex\n![logo](ava-查看占用-CPU-最高的线程/3.png)\n\n* jstack <pid-app> | grep 'pid-thread-hex' 命令查看线程信息\n\n![logo](ava-查看占用-CPU-最高的线程/4.png)\n\n* 查看整个JVM内存状态 \njmap -heap [pid]\n![logo](ava-查看占用-CPU-最高的线程/5.png)\n\n* 导出整个JVM 中内存信息，可以利用其它工具打开dump文件分析，例如jdk自带的visualvm工具\njmap -dump:file=文件名.dump [pid]\n\n使用MemoryAnalyzer.exe 分析dump\n![logo](ava-查看占用-CPU-最高的线程/6.png)\n* 打印java线程数\njcmd pid Thread.print> thread.txt\n![logo](ava-查看占用-CPU-最高的线程/7.png)","source":"_posts/ava-查看占用-CPU-最高的线程.md","raw":"title: '[Java] 查看占用 CPU 最高的线程'\nauthor: wen\ntags:\n  - java\ncategories:\n  - java\ndate: 2019-11-13 11:15:00\n---\n# 步骤\n* top 命令找出应用 pid-app\n* top -Hp <pid-app> 命令找出线程 pid-thread\n* printf '%x\\n' <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex\n* jstack <pid-app> | grep 'pid-thread-hex' 命令查看线程信息\n# 示例\n* 1.top 命令找出应用 pid-app\n![logo](ava-查看占用-CPU-最高的线程/1.png)\n\n应用 pid 为8790\n\n* top -Hp <pid-app> 命令找出线程 pid-thread\n![logo](ava-查看占用-CPU-最高的线程/2.png)\n\n线程 pid 为9702\n\n* printf '%x\\n' <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex\n![logo](ava-查看占用-CPU-最高的线程/3.png)\n\n* jstack <pid-app> | grep 'pid-thread-hex' 命令查看线程信息\n\n![logo](ava-查看占用-CPU-最高的线程/4.png)\n\n* 查看整个JVM内存状态 \njmap -heap [pid]\n![logo](ava-查看占用-CPU-最高的线程/5.png)\n\n* 导出整个JVM 中内存信息，可以利用其它工具打开dump文件分析，例如jdk自带的visualvm工具\njmap -dump:file=文件名.dump [pid]\n\n使用MemoryAnalyzer.exe 分析dump\n![logo](ava-查看占用-CPU-最高的线程/6.png)\n* 打印java线程数\njcmd pid Thread.print> thread.txt\n![logo](ava-查看占用-CPU-最高的线程/7.png)","slug":"ava-查看占用-CPU-最高的线程","published":1,"updated":"2020-02-17T15:08:47.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37k000pn6zqbcufi4l9","content":"<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><ul>\n<li>top 命令找出应用 pid-app</li>\n<li>top -Hp <pid-app> 命令找出线程 pid-thread</pid-app></li>\n<li>printf ‘%x\\n’ <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex</pid-thread></li>\n<li>jstack <pid-app> | grep ‘pid-thread-hex’ 命令查看线程信息<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1></pid-app></li>\n<li>1.top 命令找出应用 pid-app<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/1.png\" alt=\"logo\"></li>\n</ul>\n<p>应用 pid 为8790</p>\n<ul>\n<li>top -Hp <pid-app> 命令找出线程 pid-thread<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/2.png\" alt=\"logo\"></pid-app></li>\n</ul>\n<p>线程 pid 为9702</p>\n<ul>\n<li><p>printf ‘%x\\n’ <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/3.png\" alt=\"logo\"></pid-thread></p>\n</li>\n<li><p>jstack <pid-app> | grep ‘pid-thread-hex’ 命令查看线程信息</pid-app></p>\n</li>\n</ul>\n<p><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/4.png\" alt=\"logo\"></p>\n<ul>\n<li><p>查看整个JVM内存状态<br>jmap -heap [pid]<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/5.png\" alt=\"logo\"></p>\n</li>\n<li><p>导出整个JVM 中内存信息，可以利用其它工具打开dump文件分析，例如jdk自带的visualvm工具<br>jmap -dump:file=文件名.dump [pid]</p>\n</li>\n</ul>\n<p>使用MemoryAnalyzer.exe 分析dump<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/6.png\" alt=\"logo\"></p>\n<ul>\n<li>打印java线程数<br>jcmd pid Thread.print&gt; thread.txt<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/7.png\" alt=\"logo\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><ul>\n<li>top 命令找出应用 pid-app</li>\n<li>top -Hp <pid-app> 命令找出线程 pid-thread</pid-app></li>\n<li>printf ‘%x\\n’ <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex</pid-thread></li>\n<li>jstack <pid-app> | grep ‘pid-thread-hex’ 命令查看线程信息<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1></pid-app></li>\n<li>1.top 命令找出应用 pid-app<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/1.png\" alt=\"logo\"></li>\n</ul>\n<p>应用 pid 为8790</p>\n<ul>\n<li>top -Hp <pid-app> 命令找出线程 pid-thread<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/2.png\" alt=\"logo\"></pid-app></li>\n</ul>\n<p>线程 pid 为9702</p>\n<ul>\n<li><p>printf ‘%x\\n’ <pid-thread> 命令将线程 pid 转换成 16 进制 pid-thread-hex<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/3.png\" alt=\"logo\"></pid-thread></p>\n</li>\n<li><p>jstack <pid-app> | grep ‘pid-thread-hex’ 命令查看线程信息</pid-app></p>\n</li>\n</ul>\n<p><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/4.png\" alt=\"logo\"></p>\n<ul>\n<li><p>查看整个JVM内存状态<br>jmap -heap [pid]<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/5.png\" alt=\"logo\"></p>\n</li>\n<li><p>导出整个JVM 中内存信息，可以利用其它工具打开dump文件分析，例如jdk自带的visualvm工具<br>jmap -dump:file=文件名.dump [pid]</p>\n</li>\n</ul>\n<p>使用MemoryAnalyzer.exe 分析dump<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/6.png\" alt=\"logo\"></p>\n<ul>\n<li>打印java线程数<br>jcmd pid Thread.print&gt; thread.txt<br><img src=\"/2019/11/13/ava-查看占用-CPU-最高的线程/7.png\" alt=\"logo\"></li>\n</ul>\n"},{"title":"docker的使用","author":"wen","date":"2018-06-11T12:50:00.000Z","_content":"\n\n1 docker build出现Temporary failure resolving\n```\nvi/etc/systemd/system/multi-user.target.wants/docker.service ExecStart=/usr/bin/dockerd \n添加 --dns=8.8.8.8\n重新加载配置\n>systemctl daemon-reload \n --启动docker\n>systemctl start docker\n```","source":"_posts/docker的使用.md","raw":"title: docker的使用\nauthor: wen\ntags:\n  - docker\ncategories:\n  - docker\ndate: 2018-06-11 20:50:00\n---\n\n\n1 docker build出现Temporary failure resolving\n```\nvi/etc/systemd/system/multi-user.target.wants/docker.service ExecStart=/usr/bin/dockerd \n添加 --dns=8.8.8.8\n重新加载配置\n>systemctl daemon-reload \n --启动docker\n>systemctl start docker\n```","slug":"docker的使用","published":1,"updated":"2019-05-05T02:41:23.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37m000sn6zqs5z8o83w","content":"<p>1 docker build出现Temporary failure resolving<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi/etc/systemd/system/multi-user.target.wants/docker.service ExecStart=/usr/bin/dockerd </span><br><span class=\"line\">添加 --dns=8.8.8.8</span><br><span class=\"line\">重新加载配置</span><br><span class=\"line\">&gt;systemctl daemon-reload </span><br><span class=\"line\"> --启动docker</span><br><span class=\"line\">&gt;systemctl start docker</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 docker build出现Temporary failure resolving<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi/etc/systemd/system/multi-user.target.wants/docker.service ExecStart=/usr/bin/dockerd </span><br><span class=\"line\">添加 --dns=8.8.8.8</span><br><span class=\"line\">重新加载配置</span><br><span class=\"line\">&gt;systemctl daemon-reload </span><br><span class=\"line\"> --启动docker</span><br><span class=\"line\">&gt;systemctl start docker</span><br></pre></td></tr></table></figure></p>\n"},{"title":"thymeleaf学习的坑","author":"wen","date":"2018-05-08T06:30:00.000Z","_content":"# 引入css和js文件\n```\n<link th:href=\"@{/resources/admin/css/common.css}\" rel=\"stylesheet\" type=\"text/css\" />\n<script  type=\"text/javascript\" th:src=\"@{/resources/admin/js/jquery.js}\"></script>\n```\n\n# 网页标题(多语言)\n使用#{key}\n```\n  <title th:text=\"#{system.name}\"></title>\n# thymeleaf结合js\n<script  th:inline=\"javascript\">\n       //controller 使用Model设置属性\n         var error=[[${error}]];\n       //多语言\n       var usernameRequired=[[#{admin.login.usernameRequired}]]\n    </script>\n    ```\n# thymeleaf结合js 冲突\n```\n//使用<![CDATA[ ]]>\n<script th:inline=\"javascript\">\n//<![CDATA[\n  js code\n\t// ]]>\n</script>\n```\n# th:include\ncompontent/commonJs.html\n```\n<div th:fragment=\"commonJs\">\n<script th:inline=\"javascript\">\njs代码（国际化语言）\n</script>\n</div>\n```\n\n引用\n```\n <div th:include=\"compontent/commonJs::commonJs\"></div>\n ```\n# th:href\n```\n<a th:href=\"@{/admin/publicInfo/info(id=${publicInfo.id})}\" target=\"iframe\" th:text=\"#{admin.menu.publicManage.name}\"></a>\n```\n# th:each\n```\n<tr th:each=\"admin:${page.content}\">\n\t\t\t  <td th:text=\"${admin.username}\"></td>\n\t      </tr>```\n# 格式化日期\n```\n<td th:text=\"${#calendars.format(admin.createDate,'yyyy年MM月dd日')}\"></td>\n```\n# th:if\n•\t单个条件\n```\n<td th:if=\"${admin.username}=='admin'\"><input type=\"checkbox\" name=\"ids\" th:value=\"${admin.id}\" disabled=\"disabled\"/></td>\n```\n•\t并且条件\n```\n<td th:if=\"${session.username}!='admin' and ${admin.username}==${session.username}\">\n<a th:href=\"@{initEdit(id=${admin.id})}\" th:text=\"#{admin.menu.admin.edit}\">\n</a>\n</td>\n```\n\n","source":"_posts/hymeleaf学习的坑.md","raw":"title: thymeleaf学习的坑\nauthor: wen\ntags:\n  - thymeleaf\ncategories: []\ndate: 2018-05-08 14:30:00\n---\n# 引入css和js文件\n```\n<link th:href=\"@{/resources/admin/css/common.css}\" rel=\"stylesheet\" type=\"text/css\" />\n<script  type=\"text/javascript\" th:src=\"@{/resources/admin/js/jquery.js}\"></script>\n```\n\n# 网页标题(多语言)\n使用#{key}\n```\n  <title th:text=\"#{system.name}\"></title>\n# thymeleaf结合js\n<script  th:inline=\"javascript\">\n       //controller 使用Model设置属性\n         var error=[[${error}]];\n       //多语言\n       var usernameRequired=[[#{admin.login.usernameRequired}]]\n    </script>\n    ```\n# thymeleaf结合js 冲突\n```\n//使用<![CDATA[ ]]>\n<script th:inline=\"javascript\">\n//<![CDATA[\n  js code\n\t// ]]>\n</script>\n```\n# th:include\ncompontent/commonJs.html\n```\n<div th:fragment=\"commonJs\">\n<script th:inline=\"javascript\">\njs代码（国际化语言）\n</script>\n</div>\n```\n\n引用\n```\n <div th:include=\"compontent/commonJs::commonJs\"></div>\n ```\n# th:href\n```\n<a th:href=\"@{/admin/publicInfo/info(id=${publicInfo.id})}\" target=\"iframe\" th:text=\"#{admin.menu.publicManage.name}\"></a>\n```\n# th:each\n```\n<tr th:each=\"admin:${page.content}\">\n\t\t\t  <td th:text=\"${admin.username}\"></td>\n\t      </tr>```\n# 格式化日期\n```\n<td th:text=\"${#calendars.format(admin.createDate,'yyyy年MM月dd日')}\"></td>\n```\n# th:if\n•\t单个条件\n```\n<td th:if=\"${admin.username}=='admin'\"><input type=\"checkbox\" name=\"ids\" th:value=\"${admin.id}\" disabled=\"disabled\"/></td>\n```\n•\t并且条件\n```\n<td th:if=\"${session.username}!='admin' and ${admin.username}==${session.username}\">\n<a th:href=\"@{initEdit(id=${admin.id})}\" th:text=\"#{admin.menu.admin.edit}\">\n</a>\n</td>\n```\n\n","slug":"hymeleaf学习的坑","published":1,"updated":"2019-05-05T02:41:23.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37p000wn6zqdlx4oixv","content":"<h1 id=\"引入css和js文件\"><a href=\"#引入css和js文件\" class=\"headerlink\" title=\"引入css和js文件\"></a>引入css和js文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link th:href=&quot;@&#123;/resources/admin/css/common.css&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br><span class=\"line\">&lt;script  type=&quot;text/javascript&quot; th:src=&quot;@&#123;/resources/admin/js/jquery.js&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"网页标题-多语言\"><a href=\"#网页标题-多语言\" class=\"headerlink\" title=\"网页标题(多语言)\"></a>网页标题(多语言)</h1><p>使用#{key}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;title th:text=&quot;#&#123;system.name&#125;&quot;&gt;&lt;/title&gt;</span><br><span class=\"line\"># thymeleaf结合js</span><br><span class=\"line\">&lt;script  th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">       //controller 使用Model设置属性</span><br><span class=\"line\">         var error=[[$&#123;error&#125;]];</span><br><span class=\"line\">       //多语言</span><br><span class=\"line\">       var usernameRequired=[[#&#123;admin.login.usernameRequired&#125;]]</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"thymeleaf结合js-冲突\"><a href=\"#thymeleaf结合js-冲突\" class=\"headerlink\" title=\"thymeleaf结合js 冲突\"></a>thymeleaf结合js 冲突</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用&lt;![CDATA[ ]]&gt;</span><br><span class=\"line\">&lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">//&lt;![CDATA[</span><br><span class=\"line\">  js code</span><br><span class=\"line\">\t// ]]&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-include\"><a href=\"#th-include\" class=\"headerlink\" title=\"th:include\"></a>th:include</h1><p>compontent/commonJs.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div th:fragment=&quot;commonJs&quot;&gt;</span><br><span class=\"line\">&lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">js代码（国际化语言）</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div th:include=&quot;compontent/commonJs::commonJs&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"th-href\"><a href=\"#th-href\" class=\"headerlink\" title=\"th:href\"></a>th:href</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a th:href=&quot;@&#123;/admin/publicInfo/info(id=$&#123;publicInfo.id&#125;)&#125;&quot; target=&quot;iframe&quot; th:text=&quot;#&#123;admin.menu.publicManage.name&#125;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-each\"><a href=\"#th-each\" class=\"headerlink\" title=\"th:each\"></a>th:each</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tr th:each=&quot;admin:$&#123;page.content&#125;&quot;&gt;</span><br><span class=\"line\">\t\t\t  &lt;td th:text=&quot;$&#123;admin.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class=\"line\">\t      &lt;/tr&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"格式化日期\"><a href=\"#格式化日期\" class=\"headerlink\" title=\"格式化日期\"></a>格式化日期</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:text=&quot;$&#123;#calendars.format(admin.createDate,&apos;yyyy年MM月dd日&apos;)&#125;&quot;&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-if\"><a href=\"#th-if\" class=\"headerlink\" title=\"th:if\"></a>th:if</h1><p>•    单个条件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:if=&quot;$&#123;admin.username&#125;==&apos;admin&apos;&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; th:value=&quot;$&#123;admin.id&#125;&quot; disabled=&quot;disabled&quot;/&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n<p>•    并且条件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:if=&quot;$&#123;session.username&#125;!=&apos;admin&apos; and $&#123;admin.username&#125;==$&#123;session.username&#125;&quot;&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;initEdit(id=$&#123;admin.id&#125;)&#125;&quot; th:text=&quot;#&#123;admin.menu.admin.edit&#125;&quot;&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br><span class=\"line\">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引入css和js文件\"><a href=\"#引入css和js文件\" class=\"headerlink\" title=\"引入css和js文件\"></a>引入css和js文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link th:href=&quot;@&#123;/resources/admin/css/common.css&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br><span class=\"line\">&lt;script  type=&quot;text/javascript&quot; th:src=&quot;@&#123;/resources/admin/js/jquery.js&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"网页标题-多语言\"><a href=\"#网页标题-多语言\" class=\"headerlink\" title=\"网页标题(多语言)\"></a>网页标题(多语言)</h1><p>使用#{key}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;title th:text=&quot;#&#123;system.name&#125;&quot;&gt;&lt;/title&gt;</span><br><span class=\"line\"># thymeleaf结合js</span><br><span class=\"line\">&lt;script  th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">       //controller 使用Model设置属性</span><br><span class=\"line\">         var error=[[$&#123;error&#125;]];</span><br><span class=\"line\">       //多语言</span><br><span class=\"line\">       var usernameRequired=[[#&#123;admin.login.usernameRequired&#125;]]</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"thymeleaf结合js-冲突\"><a href=\"#thymeleaf结合js-冲突\" class=\"headerlink\" title=\"thymeleaf结合js 冲突\"></a>thymeleaf结合js 冲突</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用&lt;![CDATA[ ]]&gt;</span><br><span class=\"line\">&lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">//&lt;![CDATA[</span><br><span class=\"line\">  js code</span><br><span class=\"line\">\t// ]]&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-include\"><a href=\"#th-include\" class=\"headerlink\" title=\"th:include\"></a>th:include</h1><p>compontent/commonJs.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div th:fragment=&quot;commonJs&quot;&gt;</span><br><span class=\"line\">&lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class=\"line\">js代码（国际化语言）</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div th:include=&quot;compontent/commonJs::commonJs&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"th-href\"><a href=\"#th-href\" class=\"headerlink\" title=\"th:href\"></a>th:href</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a th:href=&quot;@&#123;/admin/publicInfo/info(id=$&#123;publicInfo.id&#125;)&#125;&quot; target=&quot;iframe&quot; th:text=&quot;#&#123;admin.menu.publicManage.name&#125;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-each\"><a href=\"#th-each\" class=\"headerlink\" title=\"th:each\"></a>th:each</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tr th:each=&quot;admin:$&#123;page.content&#125;&quot;&gt;</span><br><span class=\"line\">\t\t\t  &lt;td th:text=&quot;$&#123;admin.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class=\"line\">\t      &lt;/tr&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"格式化日期\"><a href=\"#格式化日期\" class=\"headerlink\" title=\"格式化日期\"></a>格式化日期</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:text=&quot;$&#123;#calendars.format(admin.createDate,&apos;yyyy年MM月dd日&apos;)&#125;&quot;&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"th-if\"><a href=\"#th-if\" class=\"headerlink\" title=\"th:if\"></a>th:if</h1><p>•    单个条件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:if=&quot;$&#123;admin.username&#125;==&apos;admin&apos;&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; th:value=&quot;$&#123;admin.id&#125;&quot; disabled=&quot;disabled&quot;/&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n<p>•    并且条件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td th:if=&quot;$&#123;session.username&#125;!=&apos;admin&apos; and $&#123;admin.username&#125;==$&#123;session.username&#125;&quot;&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;initEdit(id=$&#123;admin.id&#125;)&#125;&quot; th:text=&quot;#&#123;admin.menu.admin.edit&#125;&quot;&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br><span class=\"line\">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Spring体系结构","author":"wen","date":"2020-08-09T08:13:00.000Z","_content":"# 官网：\nhttps://spring.io/\n\n# Spring简介\nSpring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。\n## Spring优点：\nSpring的优点:\n\n* （1）方便解耦，简化开发\n\nSpring就是一个大工厂，可以将所有对象创建和依赖的关系维护，交给Spring管理。\n\n* （2）AOP编程的支持\n\nSpring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n* （3）声明式事务的支持\n\n只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n* （4）方便程序的测试\n\nSpring对Junit4支持，可以通过注解方便的测试Spring程序。\n\n*（5）方便集成各种优秀框架\n\nSpring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。\n\n*（6）降低JavaEE API的使用难度\n\nSpring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。\n\n# spring 项目\n在官网点击project 菜单 就见到spring很多项目\n![spring project](Spring体系结构/1.png)\n\n\n## springFramework\n这是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等\n体系结构\n![spring project](Spring体系结构/3.png)\nSpring的核心容器是其他模块建立的基础，有Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）等模块组成。\n\n* Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。\n* Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。\n* Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。\n* Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。\n* Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。\n* Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。\n* Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。\n* Spring-jdbc模块：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析。\n*  Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-orm模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。\n* Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。\n* Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了与Spring-messaging模块的集成。\n* Spring-tx模块（事务模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理\n* Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IOC容器以及Web应用上下文。\n* Spring-webmvc模块：也称为Web-Servlet模块，包含用于web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。\n* Spring-websocket模块：Spring4.0以后新增的模块，它提供了WebSocket和SocketJS的实现。\n* Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现\n* Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。\n\n## spring boot\n我们原来运行Spring程序，需要在Maven或者Gradle中添加一些Spring的依赖，然后再通过这些构建工具提供的服务器来运行程序。使用Spring Boot，则可以免去这些繁复的工作。Spring Boot提供了一系列功能可以自动搜索、配置Spring程序。Spring Boot会将项目打包为一个可执行的jar文件，内部包含有tomcat这样的服务器，让我们可以直接以命令行的方式运行Spring程序。Spring Boot官方介绍说，它可以让你尽可能快的运行起Spring程序\n\n\n## Springcloud\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n* Spring Cloud Netflix\n　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。\n* Spring Cloud Config\n　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件\n* Spring Cloud Bus\n　　分布式消息队列，是对Kafka, MQ的封装\n* Spring Cloud Security\n　　对Spring Security的封装，并能配合Netflix使用\n* Spring Cloud Zookeeper\n　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用\n* Spring Cloud Eureka\nSpring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。\nSpring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。\n## Spring Data\n这是Spring关于处理数据的框架，其中包含了多个模块，可以让我们使用JPA操作数据、在Redis等非SQL数据库上存取数据等很多功能\n## Spring Security\nSpring的安全框架，支持在程序中设置安全权限，限制未授权的用户访问某些页面，也提供了一些加密功能方便地加密数据\n## Spring Session\n提供了一个Session的实现，帮助我们管理用户会话。\n## Spring Integration\n这个框架用来将Spring和其他框架、协议、服务集成起来，这些服务包括但不限于控制总线、FTP服务器、Web服务，社交服务、套接字、消息队列、邮件系统……Spring Integration提供了一些适配器，可以方便的和这些服务进行集成。\n## Spring AMQP\n用于开发AMQP的解决方案\n","source":"_posts/Spring体系结构.md","raw":"title: Spring体系结构\nauthor: wen\ntags: []\ncategories:\n  - spring\ndate: 2020-08-09 16:13:00\n---\n# 官网：\nhttps://spring.io/\n\n# Spring简介\nSpring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。\n## Spring优点：\nSpring的优点:\n\n* （1）方便解耦，简化开发\n\nSpring就是一个大工厂，可以将所有对象创建和依赖的关系维护，交给Spring管理。\n\n* （2）AOP编程的支持\n\nSpring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n* （3）声明式事务的支持\n\n只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n* （4）方便程序的测试\n\nSpring对Junit4支持，可以通过注解方便的测试Spring程序。\n\n*（5）方便集成各种优秀框架\n\nSpring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。\n\n*（6）降低JavaEE API的使用难度\n\nSpring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。\n\n# spring 项目\n在官网点击project 菜单 就见到spring很多项目\n![spring project](Spring体系结构/1.png)\n\n\n## springFramework\n这是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等\n体系结构\n![spring project](Spring体系结构/3.png)\nSpring的核心容器是其他模块建立的基础，有Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）等模块组成。\n\n* Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。\n* Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。\n* Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。\n* Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。\n* Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。\n* Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。\n* Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。\n* Spring-jdbc模块：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析。\n*  Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-orm模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。\n* Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。\n* Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了与Spring-messaging模块的集成。\n* Spring-tx模块（事务模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理\n* Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IOC容器以及Web应用上下文。\n* Spring-webmvc模块：也称为Web-Servlet模块，包含用于web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。\n* Spring-websocket模块：Spring4.0以后新增的模块，它提供了WebSocket和SocketJS的实现。\n* Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现\n* Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。\n\n## spring boot\n我们原来运行Spring程序，需要在Maven或者Gradle中添加一些Spring的依赖，然后再通过这些构建工具提供的服务器来运行程序。使用Spring Boot，则可以免去这些繁复的工作。Spring Boot提供了一系列功能可以自动搜索、配置Spring程序。Spring Boot会将项目打包为一个可执行的jar文件，内部包含有tomcat这样的服务器，让我们可以直接以命令行的方式运行Spring程序。Spring Boot官方介绍说，它可以让你尽可能快的运行起Spring程序\n\n\n## Springcloud\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n* Spring Cloud Netflix\n　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。\n* Spring Cloud Config\n　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件\n* Spring Cloud Bus\n　　分布式消息队列，是对Kafka, MQ的封装\n* Spring Cloud Security\n　　对Spring Security的封装，并能配合Netflix使用\n* Spring Cloud Zookeeper\n　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用\n* Spring Cloud Eureka\nSpring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。\nSpring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。\n## Spring Data\n这是Spring关于处理数据的框架，其中包含了多个模块，可以让我们使用JPA操作数据、在Redis等非SQL数据库上存取数据等很多功能\n## Spring Security\nSpring的安全框架，支持在程序中设置安全权限，限制未授权的用户访问某些页面，也提供了一些加密功能方便地加密数据\n## Spring Session\n提供了一个Session的实现，帮助我们管理用户会话。\n## Spring Integration\n这个框架用来将Spring和其他框架、协议、服务集成起来，这些服务包括但不限于控制总线、FTP服务器、Web服务，社交服务、套接字、消息队列、邮件系统……Spring Integration提供了一些适配器，可以方便的和这些服务进行集成。\n## Spring AMQP\n用于开发AMQP的解决方案\n","slug":"Spring体系结构","published":1,"updated":"2020-08-09T08:45:20.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37q000yn6zq1c404kjh","content":"<h1 id=\"官网：\"><a href=\"#官网：\" class=\"headerlink\" title=\"官网：\"></a>官网：</h1><p><a href=\"https://spring.io/\" target=\"_blank\" rel=\"noopener\">https://spring.io/</a></p>\n<h1 id=\"Spring简介\"><a href=\"#Spring简介\" class=\"headerlink\" title=\"Spring简介\"></a>Spring简介</h1><p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>\n<h2 id=\"Spring优点：\"><a href=\"#Spring优点：\" class=\"headerlink\" title=\"Spring优点：\"></a>Spring优点：</h2><p>Spring的优点:</p>\n<ul>\n<li>（1）方便解耦，简化开发</li>\n</ul>\n<p>Spring就是一个大工厂，可以将所有对象创建和依赖的关系维护，交给Spring管理。</p>\n<ul>\n<li>（2）AOP编程的支持</li>\n</ul>\n<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n<ul>\n<li>（3）声明式事务的支持</li>\n</ul>\n<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n<ul>\n<li>（4）方便程序的测试</li>\n</ul>\n<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>\n<p>*（5）方便集成各种优秀框架</p>\n<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>\n<p>*（6）降低JavaEE API的使用难度</p>\n<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>\n<h1 id=\"spring-项目\"><a href=\"#spring-项目\" class=\"headerlink\" title=\"spring 项目\"></a>spring 项目</h1><p>在官网点击project 菜单 就见到spring很多项目<br><img src=\"/2020/08/09/Spring体系结构/1.png\" alt=\"spring project\"></p>\n<h2 id=\"springFramework\"><a href=\"#springFramework\" class=\"headerlink\" title=\"springFramework\"></a>springFramework</h2><p>这是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等<br>体系结构<br><img src=\"/2020/08/09/Spring体系结构/3.png\" alt=\"spring project\"><br>Spring的核心容器是其他模块建立的基础，有Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）等模块组成。</p>\n<ul>\n<li>Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>\n<li>Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li>\n<li>Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。</li>\n<li>Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。</li>\n<li>Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。</li>\n<li>Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。</li>\n<li>Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。</li>\n<li>Spring-jdbc模块：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析。</li>\n<li>Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-orm模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。</li>\n<li>Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。</li>\n<li>Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了与Spring-messaging模块的集成。</li>\n<li>Spring-tx模块（事务模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理</li>\n<li>Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IOC容器以及Web应用上下文。</li>\n<li>Spring-webmvc模块：也称为Web-Servlet模块，包含用于web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。</li>\n<li>Spring-websocket模块：Spring4.0以后新增的模块，它提供了WebSocket和SocketJS的实现。</li>\n<li>Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现</li>\n<li>Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>\n</ul>\n<h2 id=\"spring-boot\"><a href=\"#spring-boot\" class=\"headerlink\" title=\"spring boot\"></a>spring boot</h2><p>我们原来运行Spring程序，需要在Maven或者Gradle中添加一些Spring的依赖，然后再通过这些构建工具提供的服务器来运行程序。使用Spring Boot，则可以免去这些繁复的工作。Spring Boot提供了一系列功能可以自动搜索、配置Spring程序。Spring Boot会将项目打包为一个可执行的jar文件，内部包含有tomcat这样的服务器，让我们可以直接以命令行的方式运行Spring程序。Spring Boot官方介绍说，它可以让你尽可能快的运行起Spring程序</p>\n<h2 id=\"Springcloud\"><a href=\"#Springcloud\" class=\"headerlink\" title=\"Springcloud\"></a>Springcloud</h2><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<ul>\n<li>Spring Cloud Netflix<br>　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</li>\n<li>Spring Cloud Config<br>　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件</li>\n<li>Spring Cloud Bus<br>　　分布式消息队列，是对Kafka, MQ的封装</li>\n<li>Spring Cloud Security<br>　　对Spring Security的封装，并能配合Netflix使用</li>\n<li>Spring Cloud Zookeeper<br>　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用</li>\n<li>Spring Cloud Eureka<br>Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。<br>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。<h2 id=\"Spring-Data\"><a href=\"#Spring-Data\" class=\"headerlink\" title=\"Spring Data\"></a>Spring Data</h2>这是Spring关于处理数据的框架，其中包含了多个模块，可以让我们使用JPA操作数据、在Redis等非SQL数据库上存取数据等很多功能<h2 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h2>Spring的安全框架，支持在程序中设置安全权限，限制未授权的用户访问某些页面，也提供了一些加密功能方便地加密数据<h2 id=\"Spring-Session\"><a href=\"#Spring-Session\" class=\"headerlink\" title=\"Spring Session\"></a>Spring Session</h2>提供了一个Session的实现，帮助我们管理用户会话。<h2 id=\"Spring-Integration\"><a href=\"#Spring-Integration\" class=\"headerlink\" title=\"Spring Integration\"></a>Spring Integration</h2>这个框架用来将Spring和其他框架、协议、服务集成起来，这些服务包括但不限于控制总线、FTP服务器、Web服务，社交服务、套接字、消息队列、邮件系统……Spring Integration提供了一些适配器，可以方便的和这些服务进行集成。<h2 id=\"Spring-AMQP\"><a href=\"#Spring-AMQP\" class=\"headerlink\" title=\"Spring AMQP\"></a>Spring AMQP</h2>用于开发AMQP的解决方案</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"官网：\"><a href=\"#官网：\" class=\"headerlink\" title=\"官网：\"></a>官网：</h1><p><a href=\"https://spring.io/\" target=\"_blank\" rel=\"noopener\">https://spring.io/</a></p>\n<h1 id=\"Spring简介\"><a href=\"#Spring简介\" class=\"headerlink\" title=\"Spring简介\"></a>Spring简介</h1><p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>\n<h2 id=\"Spring优点：\"><a href=\"#Spring优点：\" class=\"headerlink\" title=\"Spring优点：\"></a>Spring优点：</h2><p>Spring的优点:</p>\n<ul>\n<li>（1）方便解耦，简化开发</li>\n</ul>\n<p>Spring就是一个大工厂，可以将所有对象创建和依赖的关系维护，交给Spring管理。</p>\n<ul>\n<li>（2）AOP编程的支持</li>\n</ul>\n<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n<ul>\n<li>（3）声明式事务的支持</li>\n</ul>\n<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n<ul>\n<li>（4）方便程序的测试</li>\n</ul>\n<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>\n<p>*（5）方便集成各种优秀框架</p>\n<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>\n<p>*（6）降低JavaEE API的使用难度</p>\n<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>\n<h1 id=\"spring-项目\"><a href=\"#spring-项目\" class=\"headerlink\" title=\"spring 项目\"></a>spring 项目</h1><p>在官网点击project 菜单 就见到spring很多项目<br><img src=\"/2020/08/09/Spring体系结构/1.png\" alt=\"spring project\"></p>\n<h2 id=\"springFramework\"><a href=\"#springFramework\" class=\"headerlink\" title=\"springFramework\"></a>springFramework</h2><p>这是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等<br>体系结构<br><img src=\"/2020/08/09/Spring体系结构/3.png\" alt=\"spring project\"><br>Spring的核心容器是其他模块建立的基础，有Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）等模块组成。</p>\n<ul>\n<li>Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>\n<li>Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li>\n<li>Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。</li>\n<li>Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。</li>\n<li>Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。</li>\n<li>Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。</li>\n<li>Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。</li>\n<li>Spring-jdbc模块：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析。</li>\n<li>Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-orm模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。</li>\n<li>Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。</li>\n<li>Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了与Spring-messaging模块的集成。</li>\n<li>Spring-tx模块（事务模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理</li>\n<li>Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IOC容器以及Web应用上下文。</li>\n<li>Spring-webmvc模块：也称为Web-Servlet模块，包含用于web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。</li>\n<li>Spring-websocket模块：Spring4.0以后新增的模块，它提供了WebSocket和SocketJS的实现。</li>\n<li>Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现</li>\n<li>Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>\n</ul>\n<h2 id=\"spring-boot\"><a href=\"#spring-boot\" class=\"headerlink\" title=\"spring boot\"></a>spring boot</h2><p>我们原来运行Spring程序，需要在Maven或者Gradle中添加一些Spring的依赖，然后再通过这些构建工具提供的服务器来运行程序。使用Spring Boot，则可以免去这些繁复的工作。Spring Boot提供了一系列功能可以自动搜索、配置Spring程序。Spring Boot会将项目打包为一个可执行的jar文件，内部包含有tomcat这样的服务器，让我们可以直接以命令行的方式运行Spring程序。Spring Boot官方介绍说，它可以让你尽可能快的运行起Spring程序</p>\n<h2 id=\"Springcloud\"><a href=\"#Springcloud\" class=\"headerlink\" title=\"Springcloud\"></a>Springcloud</h2><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<ul>\n<li>Spring Cloud Netflix<br>　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</li>\n<li>Spring Cloud Config<br>　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件</li>\n<li>Spring Cloud Bus<br>　　分布式消息队列，是对Kafka, MQ的封装</li>\n<li>Spring Cloud Security<br>　　对Spring Security的封装，并能配合Netflix使用</li>\n<li>Spring Cloud Zookeeper<br>　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用</li>\n<li>Spring Cloud Eureka<br>Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。<br>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。<h2 id=\"Spring-Data\"><a href=\"#Spring-Data\" class=\"headerlink\" title=\"Spring Data\"></a>Spring Data</h2>这是Spring关于处理数据的框架，其中包含了多个模块，可以让我们使用JPA操作数据、在Redis等非SQL数据库上存取数据等很多功能<h2 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h2>Spring的安全框架，支持在程序中设置安全权限，限制未授权的用户访问某些页面，也提供了一些加密功能方便地加密数据<h2 id=\"Spring-Session\"><a href=\"#Spring-Session\" class=\"headerlink\" title=\"Spring Session\"></a>Spring Session</h2>提供了一个Session的实现，帮助我们管理用户会话。<h2 id=\"Spring-Integration\"><a href=\"#Spring-Integration\" class=\"headerlink\" title=\"Spring Integration\"></a>Spring Integration</h2>这个框架用来将Spring和其他框架、协议、服务集成起来，这些服务包括但不限于控制总线、FTP服务器、Web服务，社交服务、套接字、消息队列、邮件系统……Spring Integration提供了一些适配器，可以方便的和这些服务进行集成。<h2 id=\"Spring-AMQP\"><a href=\"#Spring-AMQP\" class=\"headerlink\" title=\"Spring AMQP\"></a>Spring AMQP</h2>用于开发AMQP的解决方案</li>\n</ul>\n"},{"title":"solr教程","author":"wen","date":"2018-10-13T05:50:00.000Z","_content":"# 1.为什么选择Apache Solr\nApache Solr是一个功能强大的搜索服务器，它支持REST风格API。Solr是基于Lucene的，Lucene 支持强大的匹配能力，如短语，通配符，连接，分组和更多不同的数据类型。它使用 Apache Zookeeper特别针对高流量进行优化。Apache Solr提供各式各样的功能，我们列出了部分最主要的功能。\n\n* 先进的全文搜索功能。\n* XML，JSON和HTTP - 基于开放接口标准。\n* 高度可扩展和容错。\n* 同时支持模式和无模式配置。\n* 分页搜索和过滤。\n* 支持像英语，德语，中国，日本，法国和许多主要语言\n* 丰富的文档分析。\n\n# 安装solr\n要首先让从以下位置下载最新版本的Apache Solr：\nhttp://lucene.apache.org/solr/downloads.html\n在撰写本文时，可用的稳定版本是7.4.0。\n一旦Solr的zip文件下载将它解压缩到一个文件夹。提取的文件夹看起来像下面。\n![logo](lr教程/1.png)\nSolr的文件夹\n\n\nbin文件夹中包含用来启动和停止服务器的脚本。example 文件夹包含几个示例文件。我们将使用其中的一种，以说明Solr如何索引数据。server 文件夹包含logs 文件夹，所有的Solr的日志都写入该文件夹。这将有助于索引过程来检查任何错误日志。在sever文件夹下的Solr文件夹包含不同的集合或核心（core/collection）。对于各集合或核心的配置和数据都存储在相应的集合或核心文件夹。\nApache Solr带有一个内置的Jetty服务器。但在我们开始之前，我们必须验证JAVA_HOME已经配置。\n我们可以使用命令行脚本启动服务器。让我们去solr的bin目录，从命令提示符输入出以下命令\n````\nsolr start\n````\n这将启动下的默认端口8983 Solr的服务器。\n\n现在，我们可以在浏览器中打开以下网址和验证，我们的Solr的实例正在运行。solr的管理工具的细节超出了示例的范围。\n\nhttp://localhost:8983/Solr/\n![logo](lr教程/2.png)\n\n# 配置Apache Solr\n在本节中，我们将告诉你如何配置的核心/集合作为Solr实例，以及如何定义的字段。Apache Solr附带称为无模式模式的选项。这个选项允许用户构建有效的架构，而无需手动编辑模式文件。但是，在这个例子中，我们将使用架构配置理解Solr的内部。\n\n## 建立核心（core）\n当Solr的服务器在独立模式下启动的配置称为核心，当它在SolrCloud模式启动的配置称为集合。在这个例子中，我们将有关独立服务器和核心讨论。我们将在以后再讨论SolrCloud。首先，我们需要创建一个核心的索引数据。Solr的创建命令有以下选项：\n\n-c <name> -要创建的核心或集合的名称（必需）。\n-d <confdir> -配置目录，在SolrCloud模式非常有用。\n-n <configName> -配置名称。这将默认为核心或集合的名称。\n-p <port> -本地Solr的实例的端口发送create命令; 默认脚本试图通过寻找运行Solr的实例来检测端口。\n-s <shards> -Number of shards to split a collection into, default is 1.\n-rf <replicas> -集合中的每个文件的份数。默认值是1。\n在这个例子中，我们将使用的核心名称和配置目录-d参数-c参数。对于所有其它参数我们使用默认设置。\n\n现在在命令窗口浏览 solr-7.4.0\\bin文件夹，并发出以下命令。\n```\nsolr create -c jcg\n```\n我们可以看到在命令窗口中下面的输出。\n```\nCreating new core 'jcg' using command:\nhttp://localhost:8983/solr/admin/cores?action=CREATE&name=jcg&instanceDir=jcg\n {\n \"responseHeader\":{\n \"status\":0,\n \"QTime\":663},\n \"core\":\"jcg\"}\n ``` \n现在我们导航到以下网址，我们可以看到JCG核心被填充在核心选择器上。还可以看到核心的统计信息。\nhttp://localhost:8983/Solr\n![logo](lr教程/3.png)\n\n## 修改Schema.xml文件\n我们需要修改schema.xml中文件的文件夹下，server\\solr\\jcg\\conf包含的字段。我们将使用随Solr的安装索引附带的示例文件“books.csv”之一。该文件所在的文件夹下  的solr-7.4.0\\example\\exampledocs\n\n现在，我们定位到该文件夹  server\\solr目录。你会看到一个名为JCG的文件夹被创建。子文件夹conf和data分别拥有核心的配置和索引的数据。\n现在编辑\\server\\solr\\jcg\\conf\\server\\solr\\jcg\\conf\\schema.xml文件，设置唯一元素后添加以下内容。\n我们已经设置了属性索引为true。这指定字段用于索引和记录可以使用索引进行检索。该值设置为false将只存储领域，但不能进行查询。\n另外请注意另一个属性stored并将其设置为true。这指定字段被存储，并且可以在输出被返回。将此字段设置为假将使字段唯一索引，并且不能在输出进行检索。\n我们已经分配给存在于此处的“books.csv”文件中的字段的类型。在CSV文件“ID”第一场由索引Schema.xml文件的唯一键自动元素的照顾。如果你注意，我们已经略过字段series_t，sequence_i和genre_s未做任何条目。但是，当我们执行索引时，所有这些字段都被索引且没有任何问题。如果你想知道这种情况需要在Schema.xml文件的dynamicField部分一探究竟。\n[schema.xml](schema.xml)\n\n既然我们已经修改了配置，我们必须停止和启动服务器。要做到这一点，我们需要通过命令行发出从bin目录下面的命令。\n```\nSolr  stop -all\n```\n服务器将停止现在。现在启动服务器问题从bin目录中通过命令行运行以下命令。\n```\nSolr start\n```\n# 导入数据\nApache Solr带有一个叫做SimplePostTool独立的Java程序。这个程序被打包成JAR,在安装目录下 example\\exampledocs可看到。\n现在，我们在命令行定位到example\\exampledocs文件夹，然后键入以下命令。你会看到一堆选项，使用的工具。\n![logo](lr教程/4.png)\n正如我们前面所说，我们将索引“books.csv”文件中的数据。我们将导航到solr-7.4.0\\example\\exampledocs在命令提示符并发出以下命令。\n![logo](lr教程/5.png)\n现在我们导航到以下网址并选择核心JCG。\nhttp://localhost:8983/solr\n![logo](lr教程/6.png)\nSolr的JCG核心数据\n就拿在统计部分仔细一看，该民文档参数将显示索引的行数。\n# 访问索引的文档\nApache Solr提供了一种基于REST API来访问的数据，并还提供了不同的参数，以检索数据。我们将向您展示一些基于场景的查询。\n## 按名称搜索\n我们将用它的名字检索书的细节。要做到这一点，我们将使用下面的语法。URL中的参数“Q”是查询事件。\n打开浏览器下列URL。\nhttp://localhost:8983/solr/jcg/select?q=name:\"A Clash of Kings\"\n输出将在下面，如图所示。\n![logo](lr教程/7.png)\n## 首字母搜索\n现在我们将告诉你如何搜索记录，如果我们只知道起始字母或单词，不记得完整的标题。我们可以用下面的查询检索结果。\nhttp://localhost:8983/solr/jcg/select?q=name:\"A\"\n输出将列出所有的书籍字母A盯着\n![logo](lr教程/8.png)\n\n## 搜索使用通配符\nSolr的支持通配符搜索。我们将下面的展示如何检索所有书名包含“of”的书。\nhttp://localhost:8983/solr/jcg/select?q=name:\"*of\"\n![logo](lr教程/9.png)\n\n## 搜索使用的条件\nSolr的支持条件的搜索。我们可以设置条件，我们的查询提供了“FQ”参数。在下面我们将告诉你如何查询价格低于￥6的书。\nhttp://localhost:8983/solr/jcg/select?q=*&fq=price:[0 TO 6]\n输出将只列出这是低于$ 6的书籍。\n![logo](lr教程/10.png)","source":"_posts/lr教程.md","raw":"title: solr教程\nauthor: wen\ntags:\n  - solr\ncategories:\n  - solr\ndate: 2018-10-13 13:50:00\n---\n# 1.为什么选择Apache Solr\nApache Solr是一个功能强大的搜索服务器，它支持REST风格API。Solr是基于Lucene的，Lucene 支持强大的匹配能力，如短语，通配符，连接，分组和更多不同的数据类型。它使用 Apache Zookeeper特别针对高流量进行优化。Apache Solr提供各式各样的功能，我们列出了部分最主要的功能。\n\n* 先进的全文搜索功能。\n* XML，JSON和HTTP - 基于开放接口标准。\n* 高度可扩展和容错。\n* 同时支持模式和无模式配置。\n* 分页搜索和过滤。\n* 支持像英语，德语，中国，日本，法国和许多主要语言\n* 丰富的文档分析。\n\n# 安装solr\n要首先让从以下位置下载最新版本的Apache Solr：\nhttp://lucene.apache.org/solr/downloads.html\n在撰写本文时，可用的稳定版本是7.4.0。\n一旦Solr的zip文件下载将它解压缩到一个文件夹。提取的文件夹看起来像下面。\n![logo](lr教程/1.png)\nSolr的文件夹\n\n\nbin文件夹中包含用来启动和停止服务器的脚本。example 文件夹包含几个示例文件。我们将使用其中的一种，以说明Solr如何索引数据。server 文件夹包含logs 文件夹，所有的Solr的日志都写入该文件夹。这将有助于索引过程来检查任何错误日志。在sever文件夹下的Solr文件夹包含不同的集合或核心（core/collection）。对于各集合或核心的配置和数据都存储在相应的集合或核心文件夹。\nApache Solr带有一个内置的Jetty服务器。但在我们开始之前，我们必须验证JAVA_HOME已经配置。\n我们可以使用命令行脚本启动服务器。让我们去solr的bin目录，从命令提示符输入出以下命令\n````\nsolr start\n````\n这将启动下的默认端口8983 Solr的服务器。\n\n现在，我们可以在浏览器中打开以下网址和验证，我们的Solr的实例正在运行。solr的管理工具的细节超出了示例的范围。\n\nhttp://localhost:8983/Solr/\n![logo](lr教程/2.png)\n\n# 配置Apache Solr\n在本节中，我们将告诉你如何配置的核心/集合作为Solr实例，以及如何定义的字段。Apache Solr附带称为无模式模式的选项。这个选项允许用户构建有效的架构，而无需手动编辑模式文件。但是，在这个例子中，我们将使用架构配置理解Solr的内部。\n\n## 建立核心（core）\n当Solr的服务器在独立模式下启动的配置称为核心，当它在SolrCloud模式启动的配置称为集合。在这个例子中，我们将有关独立服务器和核心讨论。我们将在以后再讨论SolrCloud。首先，我们需要创建一个核心的索引数据。Solr的创建命令有以下选项：\n\n-c <name> -要创建的核心或集合的名称（必需）。\n-d <confdir> -配置目录，在SolrCloud模式非常有用。\n-n <configName> -配置名称。这将默认为核心或集合的名称。\n-p <port> -本地Solr的实例的端口发送create命令; 默认脚本试图通过寻找运行Solr的实例来检测端口。\n-s <shards> -Number of shards to split a collection into, default is 1.\n-rf <replicas> -集合中的每个文件的份数。默认值是1。\n在这个例子中，我们将使用的核心名称和配置目录-d参数-c参数。对于所有其它参数我们使用默认设置。\n\n现在在命令窗口浏览 solr-7.4.0\\bin文件夹，并发出以下命令。\n```\nsolr create -c jcg\n```\n我们可以看到在命令窗口中下面的输出。\n```\nCreating new core 'jcg' using command:\nhttp://localhost:8983/solr/admin/cores?action=CREATE&name=jcg&instanceDir=jcg\n {\n \"responseHeader\":{\n \"status\":0,\n \"QTime\":663},\n \"core\":\"jcg\"}\n ``` \n现在我们导航到以下网址，我们可以看到JCG核心被填充在核心选择器上。还可以看到核心的统计信息。\nhttp://localhost:8983/Solr\n![logo](lr教程/3.png)\n\n## 修改Schema.xml文件\n我们需要修改schema.xml中文件的文件夹下，server\\solr\\jcg\\conf包含的字段。我们将使用随Solr的安装索引附带的示例文件“books.csv”之一。该文件所在的文件夹下  的solr-7.4.0\\example\\exampledocs\n\n现在，我们定位到该文件夹  server\\solr目录。你会看到一个名为JCG的文件夹被创建。子文件夹conf和data分别拥有核心的配置和索引的数据。\n现在编辑\\server\\solr\\jcg\\conf\\server\\solr\\jcg\\conf\\schema.xml文件，设置唯一元素后添加以下内容。\n我们已经设置了属性索引为true。这指定字段用于索引和记录可以使用索引进行检索。该值设置为false将只存储领域，但不能进行查询。\n另外请注意另一个属性stored并将其设置为true。这指定字段被存储，并且可以在输出被返回。将此字段设置为假将使字段唯一索引，并且不能在输出进行检索。\n我们已经分配给存在于此处的“books.csv”文件中的字段的类型。在CSV文件“ID”第一场由索引Schema.xml文件的唯一键自动元素的照顾。如果你注意，我们已经略过字段series_t，sequence_i和genre_s未做任何条目。但是，当我们执行索引时，所有这些字段都被索引且没有任何问题。如果你想知道这种情况需要在Schema.xml文件的dynamicField部分一探究竟。\n[schema.xml](schema.xml)\n\n既然我们已经修改了配置，我们必须停止和启动服务器。要做到这一点，我们需要通过命令行发出从bin目录下面的命令。\n```\nSolr  stop -all\n```\n服务器将停止现在。现在启动服务器问题从bin目录中通过命令行运行以下命令。\n```\nSolr start\n```\n# 导入数据\nApache Solr带有一个叫做SimplePostTool独立的Java程序。这个程序被打包成JAR,在安装目录下 example\\exampledocs可看到。\n现在，我们在命令行定位到example\\exampledocs文件夹，然后键入以下命令。你会看到一堆选项，使用的工具。\n![logo](lr教程/4.png)\n正如我们前面所说，我们将索引“books.csv”文件中的数据。我们将导航到solr-7.4.0\\example\\exampledocs在命令提示符并发出以下命令。\n![logo](lr教程/5.png)\n现在我们导航到以下网址并选择核心JCG。\nhttp://localhost:8983/solr\n![logo](lr教程/6.png)\nSolr的JCG核心数据\n就拿在统计部分仔细一看，该民文档参数将显示索引的行数。\n# 访问索引的文档\nApache Solr提供了一种基于REST API来访问的数据，并还提供了不同的参数，以检索数据。我们将向您展示一些基于场景的查询。\n## 按名称搜索\n我们将用它的名字检索书的细节。要做到这一点，我们将使用下面的语法。URL中的参数“Q”是查询事件。\n打开浏览器下列URL。\nhttp://localhost:8983/solr/jcg/select?q=name:\"A Clash of Kings\"\n输出将在下面，如图所示。\n![logo](lr教程/7.png)\n## 首字母搜索\n现在我们将告诉你如何搜索记录，如果我们只知道起始字母或单词，不记得完整的标题。我们可以用下面的查询检索结果。\nhttp://localhost:8983/solr/jcg/select?q=name:\"A\"\n输出将列出所有的书籍字母A盯着\n![logo](lr教程/8.png)\n\n## 搜索使用通配符\nSolr的支持通配符搜索。我们将下面的展示如何检索所有书名包含“of”的书。\nhttp://localhost:8983/solr/jcg/select?q=name:\"*of\"\n![logo](lr教程/9.png)\n\n## 搜索使用的条件\nSolr的支持条件的搜索。我们可以设置条件，我们的查询提供了“FQ”参数。在下面我们将告诉你如何查询价格低于￥6的书。\nhttp://localhost:8983/solr/jcg/select?q=*&fq=price:[0 TO 6]\n输出将只列出这是低于$ 6的书籍。\n![logo](lr教程/10.png)","slug":"lr教程","published":1,"updated":"2019-05-05T02:41:23.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce37s0010n6zqjc34y1nl","content":"<h1 id=\"1-为什么选择Apache-Solr\"><a href=\"#1-为什么选择Apache-Solr\" class=\"headerlink\" title=\"1.为什么选择Apache Solr\"></a>1.为什么选择Apache Solr</h1><p>Apache Solr是一个功能强大的搜索服务器，它支持REST风格API。Solr是基于Lucene的，Lucene 支持强大的匹配能力，如短语，通配符，连接，分组和更多不同的数据类型。它使用 Apache Zookeeper特别针对高流量进行优化。Apache Solr提供各式各样的功能，我们列出了部分最主要的功能。</p>\n<ul>\n<li>先进的全文搜索功能。</li>\n<li>XML，JSON和HTTP - 基于开放接口标准。</li>\n<li>高度可扩展和容错。</li>\n<li>同时支持模式和无模式配置。</li>\n<li>分页搜索和过滤。</li>\n<li>支持像英语，德语，中国，日本，法国和许多主要语言</li>\n<li>丰富的文档分析。</li>\n</ul>\n<h1 id=\"安装solr\"><a href=\"#安装solr\" class=\"headerlink\" title=\"安装solr\"></a>安装solr</h1><p>要首先让从以下位置下载最新版本的Apache Solr：<br><a href=\"http://lucene.apache.org/solr/downloads.html\" target=\"_blank\" rel=\"noopener\">http://lucene.apache.org/solr/downloads.html</a><br>在撰写本文时，可用的稳定版本是7.4.0。<br>一旦Solr的zip文件下载将它解压缩到一个文件夹。提取的文件夹看起来像下面。<br><img src=\"/2018/10/13/lr教程/1.png\" alt=\"logo\"><br>Solr的文件夹</p>\n<p>bin文件夹中包含用来启动和停止服务器的脚本。example 文件夹包含几个示例文件。我们将使用其中的一种，以说明Solr如何索引数据。server 文件夹包含logs 文件夹，所有的Solr的日志都写入该文件夹。这将有助于索引过程来检查任何错误日志。在sever文件夹下的Solr文件夹包含不同的集合或核心（core/collection）。对于各集合或核心的配置和数据都存储在相应的集合或核心文件夹。<br>Apache Solr带有一个内置的Jetty服务器。但在我们开始之前，我们必须验证JAVA_HOME已经配置。<br>我们可以使用命令行脚本启动服务器。让我们去solr的bin目录，从命令提示符输入出以下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">solr start</span><br></pre></td></tr></table></figure></p>\n<p>这将启动下的默认端口8983 Solr的服务器。</p>\n<p>现在，我们可以在浏览器中打开以下网址和验证，我们的Solr的实例正在运行。solr的管理工具的细节超出了示例的范围。</p>\n<p><a href=\"http://localhost:8983/Solr/\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/Solr/</a><br><img src=\"/2018/10/13/lr教程/2.png\" alt=\"logo\"></p>\n<h1 id=\"配置Apache-Solr\"><a href=\"#配置Apache-Solr\" class=\"headerlink\" title=\"配置Apache Solr\"></a>配置Apache Solr</h1><p>在本节中，我们将告诉你如何配置的核心/集合作为Solr实例，以及如何定义的字段。Apache Solr附带称为无模式模式的选项。这个选项允许用户构建有效的架构，而无需手动编辑模式文件。但是，在这个例子中，我们将使用架构配置理解Solr的内部。</p>\n<h2 id=\"建立核心（core）\"><a href=\"#建立核心（core）\" class=\"headerlink\" title=\"建立核心（core）\"></a>建立核心（core）</h2><p>当Solr的服务器在独立模式下启动的配置称为核心，当它在SolrCloud模式启动的配置称为集合。在这个例子中，我们将有关独立服务器和核心讨论。我们将在以后再讨论SolrCloud。首先，我们需要创建一个核心的索引数据。Solr的创建命令有以下选项：</p>\n<p>-c <name> -要创建的核心或集合的名称（必需）。<br>-d <confdir> -配置目录，在SolrCloud模式非常有用。<br>-n <configname> -配置名称。这将默认为核心或集合的名称。<br>-p <port> -本地Solr的实例的端口发送create命令; 默认脚本试图通过寻找运行Solr的实例来检测端口。<br>-s <shards> -Number of shards to split a collection into, default is 1.<br>-rf <replicas> -集合中的每个文件的份数。默认值是1。<br>在这个例子中，我们将使用的核心名称和配置目录-d参数-c参数。对于所有其它参数我们使用默认设置。</replicas></shards></port></configname></confdir></name></p>\n<p>现在在命令窗口浏览 solr-7.4.0\\bin文件夹，并发出以下命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">solr create -c jcg</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在命令窗口中下面的输出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating new core &apos;jcg&apos; using command:</span><br><span class=\"line\">http://localhost:8983/solr/admin/cores?action=CREATE&amp;name=jcg&amp;instanceDir=jcg</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> &quot;responseHeader&quot;:&#123;</span><br><span class=\"line\"> &quot;status&quot;:0,</span><br><span class=\"line\"> &quot;QTime&quot;:663&#125;,</span><br><span class=\"line\"> &quot;core&quot;:&quot;jcg&quot;&#125;</span><br><span class=\"line\"> ``` </span><br><span class=\"line\">现在我们导航到以下网址，我们可以看到JCG核心被填充在核心选择器上。还可以看到核心的统计信息。</span><br><span class=\"line\">http://localhost:8983/Solr</span><br><span class=\"line\">![logo](lr教程/3.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 修改Schema.xml文件</span><br><span class=\"line\">我们需要修改schema.xml中文件的文件夹下，server\\solr\\jcg\\conf包含的字段。我们将使用随Solr的安装索引附带的示例文件“books.csv”之一。该文件所在的文件夹下  的solr-7.4.0\\example\\exampledocs</span><br><span class=\"line\"></span><br><span class=\"line\">现在，我们定位到该文件夹  server\\solr目录。你会看到一个名为JCG的文件夹被创建。子文件夹conf和data分别拥有核心的配置和索引的数据。</span><br><span class=\"line\">现在编辑\\server\\solr\\jcg\\conf\\server\\solr\\jcg\\conf\\schema.xml文件，设置唯一元素后添加以下内容。</span><br><span class=\"line\">我们已经设置了属性索引为true。这指定字段用于索引和记录可以使用索引进行检索。该值设置为false将只存储领域，但不能进行查询。</span><br><span class=\"line\">另外请注意另一个属性stored并将其设置为true。这指定字段被存储，并且可以在输出被返回。将此字段设置为假将使字段唯一索引，并且不能在输出进行检索。</span><br><span class=\"line\">我们已经分配给存在于此处的“books.csv”文件中的字段的类型。在CSV文件“ID”第一场由索引Schema.xml文件的唯一键自动元素的照顾。如果你注意，我们已经略过字段series_t，sequence_i和genre_s未做任何条目。但是，当我们执行索引时，所有这些字段都被索引且没有任何问题。如果你想知道这种情况需要在Schema.xml文件的dynamicField部分一探究竟。</span><br><span class=\"line\">[schema.xml](schema.xml)</span><br><span class=\"line\"></span><br><span class=\"line\">既然我们已经修改了配置，我们必须停止和启动服务器。要做到这一点，我们需要通过命令行发出从bin目录下面的命令。</span><br></pre></td></tr></table></figure></p>\n<p>Solr  stop -all<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器将停止现在。现在启动服务器问题从bin目录中通过命令行运行以下命令。</span><br></pre></td></tr></table></figure></p>\n<p>Solr start<br><code>`</code></p>\n<h1 id=\"导入数据\"><a href=\"#导入数据\" class=\"headerlink\" title=\"导入数据\"></a>导入数据</h1><p>Apache Solr带有一个叫做SimplePostTool独立的Java程序。这个程序被打包成JAR,在安装目录下 example\\exampledocs可看到。<br>现在，我们在命令行定位到example\\exampledocs文件夹，然后键入以下命令。你会看到一堆选项，使用的工具。<br><img src=\"/2018/10/13/lr教程/4.png\" alt=\"logo\"><br>正如我们前面所说，我们将索引“books.csv”文件中的数据。我们将导航到solr-7.4.0\\example\\exampledocs在命令提示符并发出以下命令。<br><img src=\"/2018/10/13/lr教程/5.png\" alt=\"logo\"><br>现在我们导航到以下网址并选择核心JCG。<br><a href=\"http://localhost:8983/solr\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr</a><br><img src=\"/2018/10/13/lr教程/6.png\" alt=\"logo\"><br>Solr的JCG核心数据<br>就拿在统计部分仔细一看，该民文档参数将显示索引的行数。</p>\n<h1 id=\"访问索引的文档\"><a href=\"#访问索引的文档\" class=\"headerlink\" title=\"访问索引的文档\"></a>访问索引的文档</h1><p>Apache Solr提供了一种基于REST API来访问的数据，并还提供了不同的参数，以检索数据。我们将向您展示一些基于场景的查询。</p>\n<h2 id=\"按名称搜索\"><a href=\"#按名称搜索\" class=\"headerlink\" title=\"按名称搜索\"></a>按名称搜索</h2><p>我们将用它的名字检索书的细节。要做到这一点，我们将使用下面的语法。URL中的参数“Q”是查询事件。<br>打开浏览器下列URL。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;A\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;A</a> Clash of Kings”<br>输出将在下面，如图所示。<br><img src=\"/2018/10/13/lr教程/7.png\" alt=\"logo\"></p>\n<h2 id=\"首字母搜索\"><a href=\"#首字母搜索\" class=\"headerlink\" title=\"首字母搜索\"></a>首字母搜索</h2><p>现在我们将告诉你如何搜索记录，如果我们只知道起始字母或单词，不记得完整的标题。我们可以用下面的查询检索结果。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;A&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;A&quot;</a><br>输出将列出所有的书籍字母A盯着<br><img src=\"/2018/10/13/lr教程/8.png\" alt=\"logo\"></p>\n<h2 id=\"搜索使用通配符\"><a href=\"#搜索使用通配符\" class=\"headerlink\" title=\"搜索使用通配符\"></a>搜索使用通配符</h2><p>Solr的支持通配符搜索。我们将下面的展示如何检索所有书名包含“of”的书。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;*of&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;*of&quot;</a><br><img src=\"/2018/10/13/lr教程/9.png\" alt=\"logo\"></p>\n<h2 id=\"搜索使用的条件\"><a href=\"#搜索使用的条件\" class=\"headerlink\" title=\"搜索使用的条件\"></a>搜索使用的条件</h2><p>Solr的支持条件的搜索。我们可以设置条件，我们的查询提供了“FQ”参数。在下面我们将告诉你如何查询价格低于￥6的书。<br><a href=\"http://localhost:8983/solr/jcg/select?q=*&amp;fq=price:[0\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=*&amp;fq=price:[0</a> TO 6]<br>输出将只列出这是低于$ 6的书籍。<br><img src=\"/2018/10/13/lr教程/10.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-为什么选择Apache-Solr\"><a href=\"#1-为什么选择Apache-Solr\" class=\"headerlink\" title=\"1.为什么选择Apache Solr\"></a>1.为什么选择Apache Solr</h1><p>Apache Solr是一个功能强大的搜索服务器，它支持REST风格API。Solr是基于Lucene的，Lucene 支持强大的匹配能力，如短语，通配符，连接，分组和更多不同的数据类型。它使用 Apache Zookeeper特别针对高流量进行优化。Apache Solr提供各式各样的功能，我们列出了部分最主要的功能。</p>\n<ul>\n<li>先进的全文搜索功能。</li>\n<li>XML，JSON和HTTP - 基于开放接口标准。</li>\n<li>高度可扩展和容错。</li>\n<li>同时支持模式和无模式配置。</li>\n<li>分页搜索和过滤。</li>\n<li>支持像英语，德语，中国，日本，法国和许多主要语言</li>\n<li>丰富的文档分析。</li>\n</ul>\n<h1 id=\"安装solr\"><a href=\"#安装solr\" class=\"headerlink\" title=\"安装solr\"></a>安装solr</h1><p>要首先让从以下位置下载最新版本的Apache Solr：<br><a href=\"http://lucene.apache.org/solr/downloads.html\" target=\"_blank\" rel=\"noopener\">http://lucene.apache.org/solr/downloads.html</a><br>在撰写本文时，可用的稳定版本是7.4.0。<br>一旦Solr的zip文件下载将它解压缩到一个文件夹。提取的文件夹看起来像下面。<br><img src=\"/2018/10/13/lr教程/1.png\" alt=\"logo\"><br>Solr的文件夹</p>\n<p>bin文件夹中包含用来启动和停止服务器的脚本。example 文件夹包含几个示例文件。我们将使用其中的一种，以说明Solr如何索引数据。server 文件夹包含logs 文件夹，所有的Solr的日志都写入该文件夹。这将有助于索引过程来检查任何错误日志。在sever文件夹下的Solr文件夹包含不同的集合或核心（core/collection）。对于各集合或核心的配置和数据都存储在相应的集合或核心文件夹。<br>Apache Solr带有一个内置的Jetty服务器。但在我们开始之前，我们必须验证JAVA_HOME已经配置。<br>我们可以使用命令行脚本启动服务器。让我们去solr的bin目录，从命令提示符输入出以下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">solr start</span><br></pre></td></tr></table></figure></p>\n<p>这将启动下的默认端口8983 Solr的服务器。</p>\n<p>现在，我们可以在浏览器中打开以下网址和验证，我们的Solr的实例正在运行。solr的管理工具的细节超出了示例的范围。</p>\n<p><a href=\"http://localhost:8983/Solr/\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/Solr/</a><br><img src=\"/2018/10/13/lr教程/2.png\" alt=\"logo\"></p>\n<h1 id=\"配置Apache-Solr\"><a href=\"#配置Apache-Solr\" class=\"headerlink\" title=\"配置Apache Solr\"></a>配置Apache Solr</h1><p>在本节中，我们将告诉你如何配置的核心/集合作为Solr实例，以及如何定义的字段。Apache Solr附带称为无模式模式的选项。这个选项允许用户构建有效的架构，而无需手动编辑模式文件。但是，在这个例子中，我们将使用架构配置理解Solr的内部。</p>\n<h2 id=\"建立核心（core）\"><a href=\"#建立核心（core）\" class=\"headerlink\" title=\"建立核心（core）\"></a>建立核心（core）</h2><p>当Solr的服务器在独立模式下启动的配置称为核心，当它在SolrCloud模式启动的配置称为集合。在这个例子中，我们将有关独立服务器和核心讨论。我们将在以后再讨论SolrCloud。首先，我们需要创建一个核心的索引数据。Solr的创建命令有以下选项：</p>\n<p>-c <name> -要创建的核心或集合的名称（必需）。<br>-d <confdir> -配置目录，在SolrCloud模式非常有用。<br>-n <configname> -配置名称。这将默认为核心或集合的名称。<br>-p <port> -本地Solr的实例的端口发送create命令; 默认脚本试图通过寻找运行Solr的实例来检测端口。<br>-s <shards> -Number of shards to split a collection into, default is 1.<br>-rf <replicas> -集合中的每个文件的份数。默认值是1。<br>在这个例子中，我们将使用的核心名称和配置目录-d参数-c参数。对于所有其它参数我们使用默认设置。</replicas></shards></port></configname></confdir></name></p>\n<p>现在在命令窗口浏览 solr-7.4.0\\bin文件夹，并发出以下命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">solr create -c jcg</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在命令窗口中下面的输出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating new core &apos;jcg&apos; using command:</span><br><span class=\"line\">http://localhost:8983/solr/admin/cores?action=CREATE&amp;name=jcg&amp;instanceDir=jcg</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> &quot;responseHeader&quot;:&#123;</span><br><span class=\"line\"> &quot;status&quot;:0,</span><br><span class=\"line\"> &quot;QTime&quot;:663&#125;,</span><br><span class=\"line\"> &quot;core&quot;:&quot;jcg&quot;&#125;</span><br><span class=\"line\"> ``` </span><br><span class=\"line\">现在我们导航到以下网址，我们可以看到JCG核心被填充在核心选择器上。还可以看到核心的统计信息。</span><br><span class=\"line\">http://localhost:8983/Solr</span><br><span class=\"line\">![logo](lr教程/3.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 修改Schema.xml文件</span><br><span class=\"line\">我们需要修改schema.xml中文件的文件夹下，server\\solr\\jcg\\conf包含的字段。我们将使用随Solr的安装索引附带的示例文件“books.csv”之一。该文件所在的文件夹下  的solr-7.4.0\\example\\exampledocs</span><br><span class=\"line\"></span><br><span class=\"line\">现在，我们定位到该文件夹  server\\solr目录。你会看到一个名为JCG的文件夹被创建。子文件夹conf和data分别拥有核心的配置和索引的数据。</span><br><span class=\"line\">现在编辑\\server\\solr\\jcg\\conf\\server\\solr\\jcg\\conf\\schema.xml文件，设置唯一元素后添加以下内容。</span><br><span class=\"line\">我们已经设置了属性索引为true。这指定字段用于索引和记录可以使用索引进行检索。该值设置为false将只存储领域，但不能进行查询。</span><br><span class=\"line\">另外请注意另一个属性stored并将其设置为true。这指定字段被存储，并且可以在输出被返回。将此字段设置为假将使字段唯一索引，并且不能在输出进行检索。</span><br><span class=\"line\">我们已经分配给存在于此处的“books.csv”文件中的字段的类型。在CSV文件“ID”第一场由索引Schema.xml文件的唯一键自动元素的照顾。如果你注意，我们已经略过字段series_t，sequence_i和genre_s未做任何条目。但是，当我们执行索引时，所有这些字段都被索引且没有任何问题。如果你想知道这种情况需要在Schema.xml文件的dynamicField部分一探究竟。</span><br><span class=\"line\">[schema.xml](schema.xml)</span><br><span class=\"line\"></span><br><span class=\"line\">既然我们已经修改了配置，我们必须停止和启动服务器。要做到这一点，我们需要通过命令行发出从bin目录下面的命令。</span><br></pre></td></tr></table></figure></p>\n<p>Solr  stop -all<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器将停止现在。现在启动服务器问题从bin目录中通过命令行运行以下命令。</span><br></pre></td></tr></table></figure></p>\n<p>Solr start<br><code>`</code></p>\n<h1 id=\"导入数据\"><a href=\"#导入数据\" class=\"headerlink\" title=\"导入数据\"></a>导入数据</h1><p>Apache Solr带有一个叫做SimplePostTool独立的Java程序。这个程序被打包成JAR,在安装目录下 example\\exampledocs可看到。<br>现在，我们在命令行定位到example\\exampledocs文件夹，然后键入以下命令。你会看到一堆选项，使用的工具。<br><img src=\"/2018/10/13/lr教程/4.png\" alt=\"logo\"><br>正如我们前面所说，我们将索引“books.csv”文件中的数据。我们将导航到solr-7.4.0\\example\\exampledocs在命令提示符并发出以下命令。<br><img src=\"/2018/10/13/lr教程/5.png\" alt=\"logo\"><br>现在我们导航到以下网址并选择核心JCG。<br><a href=\"http://localhost:8983/solr\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr</a><br><img src=\"/2018/10/13/lr教程/6.png\" alt=\"logo\"><br>Solr的JCG核心数据<br>就拿在统计部分仔细一看，该民文档参数将显示索引的行数。</p>\n<h1 id=\"访问索引的文档\"><a href=\"#访问索引的文档\" class=\"headerlink\" title=\"访问索引的文档\"></a>访问索引的文档</h1><p>Apache Solr提供了一种基于REST API来访问的数据，并还提供了不同的参数，以检索数据。我们将向您展示一些基于场景的查询。</p>\n<h2 id=\"按名称搜索\"><a href=\"#按名称搜索\" class=\"headerlink\" title=\"按名称搜索\"></a>按名称搜索</h2><p>我们将用它的名字检索书的细节。要做到这一点，我们将使用下面的语法。URL中的参数“Q”是查询事件。<br>打开浏览器下列URL。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;A\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;A</a> Clash of Kings”<br>输出将在下面，如图所示。<br><img src=\"/2018/10/13/lr教程/7.png\" alt=\"logo\"></p>\n<h2 id=\"首字母搜索\"><a href=\"#首字母搜索\" class=\"headerlink\" title=\"首字母搜索\"></a>首字母搜索</h2><p>现在我们将告诉你如何搜索记录，如果我们只知道起始字母或单词，不记得完整的标题。我们可以用下面的查询检索结果。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;A&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;A&quot;</a><br>输出将列出所有的书籍字母A盯着<br><img src=\"/2018/10/13/lr教程/8.png\" alt=\"logo\"></p>\n<h2 id=\"搜索使用通配符\"><a href=\"#搜索使用通配符\" class=\"headerlink\" title=\"搜索使用通配符\"></a>搜索使用通配符</h2><p>Solr的支持通配符搜索。我们将下面的展示如何检索所有书名包含“of”的书。<br><a href=\"http://localhost:8983/solr/jcg/select?q=name:&quot;*of&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=name:&quot;*of&quot;</a><br><img src=\"/2018/10/13/lr教程/9.png\" alt=\"logo\"></p>\n<h2 id=\"搜索使用的条件\"><a href=\"#搜索使用的条件\" class=\"headerlink\" title=\"搜索使用的条件\"></a>搜索使用的条件</h2><p>Solr的支持条件的搜索。我们可以设置条件，我们的查询提供了“FQ”参数。在下面我们将告诉你如何查询价格低于￥6的书。<br><a href=\"http://localhost:8983/solr/jcg/select?q=*&amp;fq=price:[0\" target=\"_blank\" rel=\"noopener\">http://localhost:8983/solr/jcg/select?q=*&amp;fq=price:[0</a> TO 6]<br>输出将只列出这是低于$ 6的书籍。<br><img src=\"/2018/10/13/lr教程/10.png\" alt=\"logo\"></p>\n"},{"title":"Solr的主从模式Master-Slave","author":"wen","date":"2018-10-14T07:25:00.000Z","_content":"# 摘要：\n如今，为了提高Solr的搜索速度，使其具有很好的容灾能力，往往会配置SolrCloud，但在Solr4之前，还有一种很流行的方式，Master-Slave模式，为什么要提及这种方式，因为我们公司目前用的就是这种方式。\n\n# 引入Master-Slave\nSolr在查询的时候，特别忌讳进行写操作，因为它是IO阻塞型的。现在的流行的Elasticsearch就对此有很好的改进。在引入Master-Slave以后，将读写分配到不同的服务器上，你可以使用master来做索引，然后使用slaves来做查询。\n1.在多台服务器上分别搭建好可以独立运行的Solr，参见[这里](https://smallwenzi.github.io/2018/10/13/lr%E6%95%99%E7%A8%8B/)\n2.指定其中的一台为Master，只需要在SolrConifg.xml中配置：\n```\n   <requestHandler name=\"/replication\" class=\"solr.ReplicationHandler\">\n        <lst name=\"master\">\n            <str name=\"enable\">${enable.master:true}</str>\n            <!--\n                Create a backup after 'optimize'. Other values can be 'commit', 'startup'.\n                It is possible to have multiple entries of this config string.\n                Note that this is just for backup, replication does not require this.\n            -->\n            <str name=\"backupAfter\">optimize</str>\n            <!-- Replicate on 'commit'. 'startup' and 'optimize' are also the valid values for replicateAfter. -->\n            <str name=\"replicateAfter\">commit</str>\n            <!-- If configuration files need to be replicated give the names here, separated by comma -->\n            <str name=\"confFiles\">schema.xml,dict.txt,synonyms.txt</str>\n            <str name=\"commitReserveDuration\">00:00:10</str>\n        </lst>\n        <int name=\"maxNumberOfBackups\">2</int>\n           </requestHandler>\n```\n3.指定其他多有的服务为Slave，只需要分别SolrConifg.xml配置：\n```\n  <requestHandler name=\"/replication\" class=\"solr.ReplicationHandler\" >\n    <lst name=\"slave\">\n        <str name=\"enable\">${enable.slave:true}</str>\n        <str name=\"masterUrl\">http://192.168.1.102:8983/solr/jcg</str>\n        <str name=\"pollInterval\">00:00:10</str>\n        <str name=\"httpConnTimeout\">5000</str>\n        <str name=\"httpReadTimeout\">10000</str>\n     </lst>\n  </requestHandler>\n```\n4.重启所有的master-slave服务即可","source":"_posts/olr的主从模式Master-Slave.md","raw":"title: Solr的主从模式Master-Slave\nauthor: wen\ntags:\n  - solr\n  - solr-master\n  - solr-slave\ncategories:\n  - solr\ndate: 2018-10-14 15:25:00\n---\n# 摘要：\n如今，为了提高Solr的搜索速度，使其具有很好的容灾能力，往往会配置SolrCloud，但在Solr4之前，还有一种很流行的方式，Master-Slave模式，为什么要提及这种方式，因为我们公司目前用的就是这种方式。\n\n# 引入Master-Slave\nSolr在查询的时候，特别忌讳进行写操作，因为它是IO阻塞型的。现在的流行的Elasticsearch就对此有很好的改进。在引入Master-Slave以后，将读写分配到不同的服务器上，你可以使用master来做索引，然后使用slaves来做查询。\n1.在多台服务器上分别搭建好可以独立运行的Solr，参见[这里](https://smallwenzi.github.io/2018/10/13/lr%E6%95%99%E7%A8%8B/)\n2.指定其中的一台为Master，只需要在SolrConifg.xml中配置：\n```\n   <requestHandler name=\"/replication\" class=\"solr.ReplicationHandler\">\n        <lst name=\"master\">\n            <str name=\"enable\">${enable.master:true}</str>\n            <!--\n                Create a backup after 'optimize'. Other values can be 'commit', 'startup'.\n                It is possible to have multiple entries of this config string.\n                Note that this is just for backup, replication does not require this.\n            -->\n            <str name=\"backupAfter\">optimize</str>\n            <!-- Replicate on 'commit'. 'startup' and 'optimize' are also the valid values for replicateAfter. -->\n            <str name=\"replicateAfter\">commit</str>\n            <!-- If configuration files need to be replicated give the names here, separated by comma -->\n            <str name=\"confFiles\">schema.xml,dict.txt,synonyms.txt</str>\n            <str name=\"commitReserveDuration\">00:00:10</str>\n        </lst>\n        <int name=\"maxNumberOfBackups\">2</int>\n           </requestHandler>\n```\n3.指定其他多有的服务为Slave，只需要分别SolrConifg.xml配置：\n```\n  <requestHandler name=\"/replication\" class=\"solr.ReplicationHandler\" >\n    <lst name=\"slave\">\n        <str name=\"enable\">${enable.slave:true}</str>\n        <str name=\"masterUrl\">http://192.168.1.102:8983/solr/jcg</str>\n        <str name=\"pollInterval\">00:00:10</str>\n        <str name=\"httpConnTimeout\">5000</str>\n        <str name=\"httpReadTimeout\">10000</str>\n     </lst>\n  </requestHandler>\n```\n4.重启所有的master-slave服务即可","slug":"olr的主从模式Master-Slave","published":1,"updated":"2019-05-05T02:41:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce3800014n6zqytisf5mw","content":"<h1 id=\"摘要：\"><a href=\"#摘要：\" class=\"headerlink\" title=\"摘要：\"></a>摘要：</h1><p>如今，为了提高Solr的搜索速度，使其具有很好的容灾能力，往往会配置SolrCloud，但在Solr4之前，还有一种很流行的方式，Master-Slave模式，为什么要提及这种方式，因为我们公司目前用的就是这种方式。</p>\n<h1 id=\"引入Master-Slave\"><a href=\"#引入Master-Slave\" class=\"headerlink\" title=\"引入Master-Slave\"></a>引入Master-Slave</h1><p>Solr在查询的时候，特别忌讳进行写操作，因为它是IO阻塞型的。现在的流行的Elasticsearch就对此有很好的改进。在引入Master-Slave以后，将读写分配到不同的服务器上，你可以使用master来做索引，然后使用slaves来做查询。<br>1.在多台服务器上分别搭建好可以独立运行的Solr，参见<a href=\"https://smallwenzi.github.io/2018/10/13/lr%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">这里</a><br>2.指定其中的一台为Master，只需要在SolrConifg.xml中配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot;&gt;</span><br><span class=\"line\">     &lt;lst name=&quot;master&quot;&gt;</span><br><span class=\"line\">         &lt;str name=&quot;enable&quot;&gt;$&#123;enable.master:true&#125;&lt;/str&gt;</span><br><span class=\"line\">         &lt;!--</span><br><span class=\"line\">             Create a backup after &apos;optimize&apos;. Other values can be &apos;commit&apos;, &apos;startup&apos;.</span><br><span class=\"line\">             It is possible to have multiple entries of this config string.</span><br><span class=\"line\">             Note that this is just for backup, replication does not require this.</span><br><span class=\"line\">         --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;backupAfter&quot;&gt;optimize&lt;/str&gt;</span><br><span class=\"line\">         &lt;!-- Replicate on &apos;commit&apos;. &apos;startup&apos; and &apos;optimize&apos; are also the valid values for replicateAfter. --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;replicateAfter&quot;&gt;commit&lt;/str&gt;</span><br><span class=\"line\">         &lt;!-- If configuration files need to be replicated give the names here, separated by comma --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;confFiles&quot;&gt;schema.xml,dict.txt,synonyms.txt&lt;/str&gt;</span><br><span class=\"line\">         &lt;str name=&quot;commitReserveDuration&quot;&gt;00:00:10&lt;/str&gt;</span><br><span class=\"line\">     &lt;/lst&gt;</span><br><span class=\"line\">     &lt;int name=&quot;maxNumberOfBackups&quot;&gt;2&lt;/int&gt;</span><br><span class=\"line\">        &lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure></p>\n<p>3.指定其他多有的服务为Slave，只需要分别SolrConifg.xml配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot; &gt;</span><br><span class=\"line\">  &lt;lst name=&quot;slave&quot;&gt;</span><br><span class=\"line\">      &lt;str name=&quot;enable&quot;&gt;$&#123;enable.slave:true&#125;&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;masterUrl&quot;&gt;http://192.168.1.102:8983/solr/jcg&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;pollInterval&quot;&gt;00:00:10&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;httpConnTimeout&quot;&gt;5000&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;httpReadTimeout&quot;&gt;10000&lt;/str&gt;</span><br><span class=\"line\">   &lt;/lst&gt;</span><br><span class=\"line\">&lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure></p>\n<p>4.重启所有的master-slave服务即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摘要：\"><a href=\"#摘要：\" class=\"headerlink\" title=\"摘要：\"></a>摘要：</h1><p>如今，为了提高Solr的搜索速度，使其具有很好的容灾能力，往往会配置SolrCloud，但在Solr4之前，还有一种很流行的方式，Master-Slave模式，为什么要提及这种方式，因为我们公司目前用的就是这种方式。</p>\n<h1 id=\"引入Master-Slave\"><a href=\"#引入Master-Slave\" class=\"headerlink\" title=\"引入Master-Slave\"></a>引入Master-Slave</h1><p>Solr在查询的时候，特别忌讳进行写操作，因为它是IO阻塞型的。现在的流行的Elasticsearch就对此有很好的改进。在引入Master-Slave以后，将读写分配到不同的服务器上，你可以使用master来做索引，然后使用slaves来做查询。<br>1.在多台服务器上分别搭建好可以独立运行的Solr，参见<a href=\"https://smallwenzi.github.io/2018/10/13/lr%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">这里</a><br>2.指定其中的一台为Master，只需要在SolrConifg.xml中配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot;&gt;</span><br><span class=\"line\">     &lt;lst name=&quot;master&quot;&gt;</span><br><span class=\"line\">         &lt;str name=&quot;enable&quot;&gt;$&#123;enable.master:true&#125;&lt;/str&gt;</span><br><span class=\"line\">         &lt;!--</span><br><span class=\"line\">             Create a backup after &apos;optimize&apos;. Other values can be &apos;commit&apos;, &apos;startup&apos;.</span><br><span class=\"line\">             It is possible to have multiple entries of this config string.</span><br><span class=\"line\">             Note that this is just for backup, replication does not require this.</span><br><span class=\"line\">         --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;backupAfter&quot;&gt;optimize&lt;/str&gt;</span><br><span class=\"line\">         &lt;!-- Replicate on &apos;commit&apos;. &apos;startup&apos; and &apos;optimize&apos; are also the valid values for replicateAfter. --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;replicateAfter&quot;&gt;commit&lt;/str&gt;</span><br><span class=\"line\">         &lt;!-- If configuration files need to be replicated give the names here, separated by comma --&gt;</span><br><span class=\"line\">         &lt;str name=&quot;confFiles&quot;&gt;schema.xml,dict.txt,synonyms.txt&lt;/str&gt;</span><br><span class=\"line\">         &lt;str name=&quot;commitReserveDuration&quot;&gt;00:00:10&lt;/str&gt;</span><br><span class=\"line\">     &lt;/lst&gt;</span><br><span class=\"line\">     &lt;int name=&quot;maxNumberOfBackups&quot;&gt;2&lt;/int&gt;</span><br><span class=\"line\">        &lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure></p>\n<p>3.指定其他多有的服务为Slave，只需要分别SolrConifg.xml配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot; &gt;</span><br><span class=\"line\">  &lt;lst name=&quot;slave&quot;&gt;</span><br><span class=\"line\">      &lt;str name=&quot;enable&quot;&gt;$&#123;enable.slave:true&#125;&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;masterUrl&quot;&gt;http://192.168.1.102:8983/solr/jcg&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;pollInterval&quot;&gt;00:00:10&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;httpConnTimeout&quot;&gt;5000&lt;/str&gt;</span><br><span class=\"line\">      &lt;str name=&quot;httpReadTimeout&quot;&gt;10000&lt;/str&gt;</span><br><span class=\"line\">   &lt;/lst&gt;</span><br><span class=\"line\">&lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure></p>\n<p>4.重启所有的master-slave服务即可</p>\n"},{"title":"十）jenkins 配置java和Maven环境","author":"wen","date":"2018-05-11T15:01:00.000Z","_content":"参考：\n[linux配置java和maven](/2018/05/11/九-linux配置java和maven/)\n[docker安装本地仓库](2018/05/08/（六）docker安装本地仓库（root用户）/)\n[安装jenkins](/2018/05/08/安装jenkins/)\n\n# 一配置maven\n/app/apache-maven-3.2.3/conf/settings.xml\n库位置\n![logo](enkinx-配置任务/1.png)\n以下是私有docker库 用户名密码）\n![logo](enkinx-配置任务/2.png)\n\n# 二 jenkins 配置java和Maven环境\n2.1点击系统管理\n![logo](enkinx-配置任务/11278290-aab55082195f5c56.png)\n2.2 点击 全局工具配置 \n![logo](enkinx-配置任务/3.png)\n2.3 如下图配置 java和maven.\n![logo](enkinx-配置任务/4.png)\n\n![logo](enkinx-配置任务/5.png)\n2.4 点击 保存 再次点击 系统设置\n![logo](enkinx-配置任务/6.png)\n2.5 再次配置java和maven目录\n![logo](enkinx-配置任务/7.png)","source":"_posts/enkinx-配置任务.md","raw":"title: 十）jenkins 配置java和Maven环境\nauthor: wen\ntags:\n  - docker\n  - jenkins\n  - java\n  - maven\ncategories:\n  - jenkins\ndate: 2018-05-11 23:01:00\n---\n参考：\n[linux配置java和maven](/2018/05/11/九-linux配置java和maven/)\n[docker安装本地仓库](2018/05/08/（六）docker安装本地仓库（root用户）/)\n[安装jenkins](/2018/05/08/安装jenkins/)\n\n# 一配置maven\n/app/apache-maven-3.2.3/conf/settings.xml\n库位置\n![logo](enkinx-配置任务/1.png)\n以下是私有docker库 用户名密码）\n![logo](enkinx-配置任务/2.png)\n\n# 二 jenkins 配置java和Maven环境\n2.1点击系统管理\n![logo](enkinx-配置任务/11278290-aab55082195f5c56.png)\n2.2 点击 全局工具配置 \n![logo](enkinx-配置任务/3.png)\n2.3 如下图配置 java和maven.\n![logo](enkinx-配置任务/4.png)\n\n![logo](enkinx-配置任务/5.png)\n2.4 点击 保存 再次点击 系统设置\n![logo](enkinx-配置任务/6.png)\n2.5 再次配置java和maven目录\n![logo](enkinx-配置任务/7.png)","slug":"enkinx-配置任务","published":1,"updated":"2019-05-05T02:41:23.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce3820016n6zqquu7joal","content":"<p>参考：<br><a href=\"/2018/05/11/九-linux配置java和maven/\">linux配置java和maven</a><br><a href=\"2018/05/08/（六）docker安装本地仓库（root用户）/\">docker安装本地仓库</a><br><a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a></p>\n<h1 id=\"一配置maven\"><a href=\"#一配置maven\" class=\"headerlink\" title=\"一配置maven\"></a>一配置maven</h1><p>/app/apache-maven-3.2.3/conf/settings.xml<br>库位置<br><img src=\"/2018/05/11/enkinx-配置任务/1.png\" alt=\"logo\"><br>以下是私有docker库 用户名密码）<br><img src=\"/2018/05/11/enkinx-配置任务/2.png\" alt=\"logo\"></p>\n<h1 id=\"二-jenkins-配置java和Maven环境\"><a href=\"#二-jenkins-配置java和Maven环境\" class=\"headerlink\" title=\"二 jenkins 配置java和Maven环境\"></a>二 jenkins 配置java和Maven环境</h1><p>2.1点击系统管理<br><img src=\"/2018/05/11/enkinx-配置任务/11278290-aab55082195f5c56.png\" alt=\"logo\"><br>2.2 点击 全局工具配置<br><img src=\"/2018/05/11/enkinx-配置任务/3.png\" alt=\"logo\"><br>2.3 如下图配置 java和maven.<br><img src=\"/2018/05/11/enkinx-配置任务/4.png\" alt=\"logo\"></p>\n<p><img src=\"/2018/05/11/enkinx-配置任务/5.png\" alt=\"logo\"><br>2.4 点击 保存 再次点击 系统设置<br><img src=\"/2018/05/11/enkinx-配置任务/6.png\" alt=\"logo\"><br>2.5 再次配置java和maven目录<br><img src=\"/2018/05/11/enkinx-配置任务/7.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<br><a href=\"/2018/05/11/九-linux配置java和maven/\">linux配置java和maven</a><br><a href=\"2018/05/08/（六）docker安装本地仓库（root用户）/\">docker安装本地仓库</a><br><a href=\"/2018/05/08/安装jenkins/\">安装jenkins</a></p>\n<h1 id=\"一配置maven\"><a href=\"#一配置maven\" class=\"headerlink\" title=\"一配置maven\"></a>一配置maven</h1><p>/app/apache-maven-3.2.3/conf/settings.xml<br>库位置<br><img src=\"/2018/05/11/enkinx-配置任务/1.png\" alt=\"logo\"><br>以下是私有docker库 用户名密码）<br><img src=\"/2018/05/11/enkinx-配置任务/2.png\" alt=\"logo\"></p>\n<h1 id=\"二-jenkins-配置java和Maven环境\"><a href=\"#二-jenkins-配置java和Maven环境\" class=\"headerlink\" title=\"二 jenkins 配置java和Maven环境\"></a>二 jenkins 配置java和Maven环境</h1><p>2.1点击系统管理<br><img src=\"/2018/05/11/enkinx-配置任务/11278290-aab55082195f5c56.png\" alt=\"logo\"><br>2.2 点击 全局工具配置<br><img src=\"/2018/05/11/enkinx-配置任务/3.png\" alt=\"logo\"><br>2.3 如下图配置 java和maven.<br><img src=\"/2018/05/11/enkinx-配置任务/4.png\" alt=\"logo\"></p>\n<p><img src=\"/2018/05/11/enkinx-配置任务/5.png\" alt=\"logo\"><br>2.4 点击 保存 再次点击 系统设置<br><img src=\"/2018/05/11/enkinx-配置任务/6.png\" alt=\"logo\"><br>2.5 再次配置java和maven目录<br><img src=\"/2018/05/11/enkinx-配置任务/7.png\" alt=\"logo\"></p>\n"},{"title":"用GTmetrix来优化你的网页（集成了YSlow、FireBug的功能）","author":"wen","date":"2017-02-28T06:57:00.000Z","_content":"<Excerpt in index | 首页摘要>\n网址是：http://gtmetrix.com/ ，输入自己需要分析的链接，稍微等会儿，有两个得分，一是YSlow的分析得分，二是PageSpeed的分析得分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![logo](gtmetix/1.jpg)\n一般互联网的网站，得分要达到C（包含A和B）以上，最好能达到B。\n\n## YSlow的检查项目\n  ### Leverage browser caching  浏览器缓存\n  Page load times can be significantly improved by asking visitors to save and reuse the files included in your website. 要求访问者保存和重复使用您网站中包含的文件，可以显着提高页面加载时间。\n      \n  ### Specify a cache validator 指定缓存验证器   \nAll static resources should have either a Last-Modified or ETag header. This will allow browsers to take advantage of the full benefits of caching.所有静态资源应具有Last-Modified或ETag头。 这将允许浏览器利用缓存的全部好处。\n\n ### Optimize images 优化图片\nReduce the load times of pages by loading appropriately sized images.通过加载适当大小的图像减少页面的加载时间。\n\n### Specify image dimensions 指定图片大小\nSpecifying a width and height for all images allows for faster rendering by eliminating the need for unnecessary reflows and repaints.为所有图像指定宽度和高度允许通过消除对不必要的回流和重绘的需要来更快地呈现。\n\n### Enable gzip compression 启用gzip压缩\n\nReduce the size of files sent from your server to increase the speed to which they are transferred to the browser.减少从服务器发送的文件的大小，以提高它们传输到浏览器的速度。\n\n### Minify JavaScript 缩小javascript\nCompacting JavaScript code can save many bytes of data and speed up downloading, parsing, and execution time.压缩JavaScript代码可以节省大量数据字节，并加快下载，解析和执行时间\n\n### Minify HTML 缩小HTML\nCompacting HTML code, including any inline JavaScript and CSS contained in it, can save many bytes of data and speed up downloading, parsing, and execution time.压缩HTML代码，包括其中包含的任何内联JavaScript和CSS，可以节省许多字节的数据，加快下载，解析和执行时间。\n\n### Specify a Vary: Accept-Encoding header\n\nBugs in some public proxies may lead to compressed versions of your resources being served to users that don't support compression. Specifying the Vary: Accept-Encoding header instructs the proxy to store both a compressed and uncompressed version of the resource.一些公共代理中的错误可能导致向不支持压缩的用户提供资源的压缩版本。 指定Vary：Accept-Encoding标头指示代理存储资源的压缩和未压缩版本。\n\n### Remove query strings from static resources 从静态资源中删除查询字符串\n\nMost proxies, most notably Squid up through version 3.0, do not cache resources with a \"?\" in their URL even if a Cache-control: public header is present in the response. To enable proxy caching for these resources, remove query strings from references to static resources, and instead encode the parameters into the file names themselves.大多数代理，最引人注目的是Squid通过3.0版本，不缓存资源与“？ 即使在响应中存在Cache-control：public标头，也可以在其URL中查找。 要为这些资源启用代理缓存，请从静态资源引用中删除查询字符串，而不是将参数编入文件名本身。\n\n### Avoid bad requests 避免不良的请求\nRemoving \"broken links\", or requests that result in 404/410 errors, avoids wasteful requests.删除“损坏的链接”或导致404/410错误的请求，可避免浪费的请求。\n\n### Avoid landing page redirects 避免着陆页重定向\nRedirections on landing pages add delays to the page load and while the redirections are occurring, nothing is shown to the client. In many cases, redirections can be eliminated without changing the function of a page.着陆页的重定向会增加页面加载的延迟，并且当重定向发生时，客户端不会显示任何内容。 在许多情况下，可以消除重定向而不改变页面的功能。\n\n### Defer parsing of JavaScript 延迟JavaScript的解析\nIn order to load a page, the browser must parse the contents of all <script> tags, which adds additional time to the page load. By minimizing the amount of JavaScript needed to render the page, and deferring parsing of unneeded JavaScript until it needs to be executed, you can reduce the initial load time of your page.为了加载页面，浏览器必须解析所有<script>标签的内容，这会给页面加载增加额外的时间。 通过最小化呈现页面所需的JavaScript量，并推迟对不需要的JavaScript进行解析，直到需要执行它，您可以减少页面的初始加载时间。\n\n### Enable Keep-Alive 启用保持活动\nEnabling HTTP Keep-Alive or HTTP persistent connections allow the same TCP connection to send and receive multiple HTTP requests, thus reducing the latency for subsequent requests.启用HTTP Keep-Alive或HTTP持久连接允许同一TCP连接发送和接收多个HTTP请求，从而减少后续请求的延迟。\n\n### Inline small CSS 内联小型外部CSS文件\nInlining small external CSS files can save the overhead of fetching these small files. A good alternative to inline CSS is to combine the external CSS files.内联小型外部CSS文件可以节省获取这些小文件的开销。 内联CSS的一个好的替代方法是组合外部CSS文件。\n\n## PageSpeed的检查项\n\n## Waterfall\n\n## Timings\n\n\n## vedio\n\n## Histroy","source":"_posts/gtmetix.md","raw":"title: 用GTmetrix来优化你的网页（集成了YSlow、FireBug的功能）\nauthor: wen\ntags:\n  - 性能优化\ncategories:\n  - 性能优化\ndate: 2017-02-28 14:57:00\n---\n<Excerpt in index | 首页摘要>\n网址是：http://gtmetrix.com/ ，输入自己需要分析的链接，稍微等会儿，有两个得分，一是YSlow的分析得分，二是PageSpeed的分析得分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![logo](gtmetix/1.jpg)\n一般互联网的网站，得分要达到C（包含A和B）以上，最好能达到B。\n\n## YSlow的检查项目\n  ### Leverage browser caching  浏览器缓存\n  Page load times can be significantly improved by asking visitors to save and reuse the files included in your website. 要求访问者保存和重复使用您网站中包含的文件，可以显着提高页面加载时间。\n      \n  ### Specify a cache validator 指定缓存验证器   \nAll static resources should have either a Last-Modified or ETag header. This will allow browsers to take advantage of the full benefits of caching.所有静态资源应具有Last-Modified或ETag头。 这将允许浏览器利用缓存的全部好处。\n\n ### Optimize images 优化图片\nReduce the load times of pages by loading appropriately sized images.通过加载适当大小的图像减少页面的加载时间。\n\n### Specify image dimensions 指定图片大小\nSpecifying a width and height for all images allows for faster rendering by eliminating the need for unnecessary reflows and repaints.为所有图像指定宽度和高度允许通过消除对不必要的回流和重绘的需要来更快地呈现。\n\n### Enable gzip compression 启用gzip压缩\n\nReduce the size of files sent from your server to increase the speed to which they are transferred to the browser.减少从服务器发送的文件的大小，以提高它们传输到浏览器的速度。\n\n### Minify JavaScript 缩小javascript\nCompacting JavaScript code can save many bytes of data and speed up downloading, parsing, and execution time.压缩JavaScript代码可以节省大量数据字节，并加快下载，解析和执行时间\n\n### Minify HTML 缩小HTML\nCompacting HTML code, including any inline JavaScript and CSS contained in it, can save many bytes of data and speed up downloading, parsing, and execution time.压缩HTML代码，包括其中包含的任何内联JavaScript和CSS，可以节省许多字节的数据，加快下载，解析和执行时间。\n\n### Specify a Vary: Accept-Encoding header\n\nBugs in some public proxies may lead to compressed versions of your resources being served to users that don't support compression. Specifying the Vary: Accept-Encoding header instructs the proxy to store both a compressed and uncompressed version of the resource.一些公共代理中的错误可能导致向不支持压缩的用户提供资源的压缩版本。 指定Vary：Accept-Encoding标头指示代理存储资源的压缩和未压缩版本。\n\n### Remove query strings from static resources 从静态资源中删除查询字符串\n\nMost proxies, most notably Squid up through version 3.0, do not cache resources with a \"?\" in their URL even if a Cache-control: public header is present in the response. To enable proxy caching for these resources, remove query strings from references to static resources, and instead encode the parameters into the file names themselves.大多数代理，最引人注目的是Squid通过3.0版本，不缓存资源与“？ 即使在响应中存在Cache-control：public标头，也可以在其URL中查找。 要为这些资源启用代理缓存，请从静态资源引用中删除查询字符串，而不是将参数编入文件名本身。\n\n### Avoid bad requests 避免不良的请求\nRemoving \"broken links\", or requests that result in 404/410 errors, avoids wasteful requests.删除“损坏的链接”或导致404/410错误的请求，可避免浪费的请求。\n\n### Avoid landing page redirects 避免着陆页重定向\nRedirections on landing pages add delays to the page load and while the redirections are occurring, nothing is shown to the client. In many cases, redirections can be eliminated without changing the function of a page.着陆页的重定向会增加页面加载的延迟，并且当重定向发生时，客户端不会显示任何内容。 在许多情况下，可以消除重定向而不改变页面的功能。\n\n### Defer parsing of JavaScript 延迟JavaScript的解析\nIn order to load a page, the browser must parse the contents of all <script> tags, which adds additional time to the page load. By minimizing the amount of JavaScript needed to render the page, and deferring parsing of unneeded JavaScript until it needs to be executed, you can reduce the initial load time of your page.为了加载页面，浏览器必须解析所有<script>标签的内容，这会给页面加载增加额外的时间。 通过最小化呈现页面所需的JavaScript量，并推迟对不需要的JavaScript进行解析，直到需要执行它，您可以减少页面的初始加载时间。\n\n### Enable Keep-Alive 启用保持活动\nEnabling HTTP Keep-Alive or HTTP persistent connections allow the same TCP connection to send and receive multiple HTTP requests, thus reducing the latency for subsequent requests.启用HTTP Keep-Alive或HTTP持久连接允许同一TCP连接发送和接收多个HTTP请求，从而减少后续请求的延迟。\n\n### Inline small CSS 内联小型外部CSS文件\nInlining small external CSS files can save the overhead of fetching these small files. A good alternative to inline CSS is to combine the external CSS files.内联小型外部CSS文件可以节省获取这些小文件的开销。 内联CSS的一个好的替代方法是组合外部CSS文件。\n\n## PageSpeed的检查项\n\n## Waterfall\n\n## Timings\n\n\n## vedio\n\n## Histroy","slug":"gtmetix","published":1,"updated":"2019-05-05T02:41:23.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce385001an6zq6knm8nbx","content":"<p><excerpt in index | 首页摘要><br>网址是：<a href=\"http://gtmetrix.com/\" target=\"_blank\" rel=\"noopener\">http://gtmetrix.com/</a> ，输入自己需要分析的链接，稍微等会儿，有两个得分，一是YSlow的分析得分，二是PageSpeed的分析得分。<br><a id=\"more\"></a></excerpt></p>\n<the rest of contents | 余下全文>\n\n<p><img src=\"/2017/02/28/gtmetix/1.jpg\" alt=\"logo\"><br>一般互联网的网站，得分要达到C（包含A和B）以上，最好能达到B。</p>\n<h2 id=\"YSlow的检查项目\"><a href=\"#YSlow的检查项目\" class=\"headerlink\" title=\"YSlow的检查项目\"></a>YSlow的检查项目</h2><h3 id=\"Leverage-browser-caching-浏览器缓存\"><a href=\"#Leverage-browser-caching-浏览器缓存\" class=\"headerlink\" title=\"Leverage browser caching  浏览器缓存\"></a>Leverage browser caching  浏览器缓存</h3><p>  Page load times can be significantly improved by asking visitors to save and reuse the files included in your website. 要求访问者保存和重复使用您网站中包含的文件，可以显着提高页面加载时间。</p>\n<h3 id=\"Specify-a-cache-validator-指定缓存验证器\"><a href=\"#Specify-a-cache-validator-指定缓存验证器\" class=\"headerlink\" title=\"Specify a cache validator 指定缓存验证器\"></a>Specify a cache validator 指定缓存验证器</h3><p>All static resources should have either a Last-Modified or ETag header. This will allow browsers to take advantage of the full benefits of caching.所有静态资源应具有Last-Modified或ETag头。 这将允许浏览器利用缓存的全部好处。</p>\n<h3 id=\"Optimize-images-优化图片\"><a href=\"#Optimize-images-优化图片\" class=\"headerlink\" title=\"Optimize images 优化图片\"></a>Optimize images 优化图片</h3><p>Reduce the load times of pages by loading appropriately sized images.通过加载适当大小的图像减少页面的加载时间。</p>\n<h3 id=\"Specify-image-dimensions-指定图片大小\"><a href=\"#Specify-image-dimensions-指定图片大小\" class=\"headerlink\" title=\"Specify image dimensions 指定图片大小\"></a>Specify image dimensions 指定图片大小</h3><p>Specifying a width and height for all images allows for faster rendering by eliminating the need for unnecessary reflows and repaints.为所有图像指定宽度和高度允许通过消除对不必要的回流和重绘的需要来更快地呈现。</p>\n<h3 id=\"Enable-gzip-compression-启用gzip压缩\"><a href=\"#Enable-gzip-compression-启用gzip压缩\" class=\"headerlink\" title=\"Enable gzip compression 启用gzip压缩\"></a>Enable gzip compression 启用gzip压缩</h3><p>Reduce the size of files sent from your server to increase the speed to which they are transferred to the browser.减少从服务器发送的文件的大小，以提高它们传输到浏览器的速度。</p>\n<h3 id=\"Minify-JavaScript-缩小javascript\"><a href=\"#Minify-JavaScript-缩小javascript\" class=\"headerlink\" title=\"Minify JavaScript 缩小javascript\"></a>Minify JavaScript 缩小javascript</h3><p>Compacting JavaScript code can save many bytes of data and speed up downloading, parsing, and execution time.压缩JavaScript代码可以节省大量数据字节，并加快下载，解析和执行时间</p>\n<h3 id=\"Minify-HTML-缩小HTML\"><a href=\"#Minify-HTML-缩小HTML\" class=\"headerlink\" title=\"Minify HTML 缩小HTML\"></a>Minify HTML 缩小HTML</h3><p>Compacting HTML code, including any inline JavaScript and CSS contained in it, can save many bytes of data and speed up downloading, parsing, and execution time.压缩HTML代码，包括其中包含的任何内联JavaScript和CSS，可以节省许多字节的数据，加快下载，解析和执行时间。</p>\n<h3 id=\"Specify-a-Vary-Accept-Encoding-header\"><a href=\"#Specify-a-Vary-Accept-Encoding-header\" class=\"headerlink\" title=\"Specify a Vary: Accept-Encoding header\"></a>Specify a Vary: Accept-Encoding header</h3><p>Bugs in some public proxies may lead to compressed versions of your resources being served to users that don’t support compression. Specifying the Vary: Accept-Encoding header instructs the proxy to store both a compressed and uncompressed version of the resource.一些公共代理中的错误可能导致向不支持压缩的用户提供资源的压缩版本。 指定Vary：Accept-Encoding标头指示代理存储资源的压缩和未压缩版本。</p>\n<h3 id=\"Remove-query-strings-from-static-resources-从静态资源中删除查询字符串\"><a href=\"#Remove-query-strings-from-static-resources-从静态资源中删除查询字符串\" class=\"headerlink\" title=\"Remove query strings from static resources 从静态资源中删除查询字符串\"></a>Remove query strings from static resources 从静态资源中删除查询字符串</h3><p>Most proxies, most notably Squid up through version 3.0, do not cache resources with a “?” in their URL even if a Cache-control: public header is present in the response. To enable proxy caching for these resources, remove query strings from references to static resources, and instead encode the parameters into the file names themselves.大多数代理，最引人注目的是Squid通过3.0版本，不缓存资源与“？ 即使在响应中存在Cache-control：public标头，也可以在其URL中查找。 要为这些资源启用代理缓存，请从静态资源引用中删除查询字符串，而不是将参数编入文件名本身。</p>\n<h3 id=\"Avoid-bad-requests-避免不良的请求\"><a href=\"#Avoid-bad-requests-避免不良的请求\" class=\"headerlink\" title=\"Avoid bad requests 避免不良的请求\"></a>Avoid bad requests 避免不良的请求</h3><p>Removing “broken links”, or requests that result in 404/410 errors, avoids wasteful requests.删除“损坏的链接”或导致404/410错误的请求，可避免浪费的请求。</p>\n<h3 id=\"Avoid-landing-page-redirects-避免着陆页重定向\"><a href=\"#Avoid-landing-page-redirects-避免着陆页重定向\" class=\"headerlink\" title=\"Avoid landing page redirects 避免着陆页重定向\"></a>Avoid landing page redirects 避免着陆页重定向</h3><p>Redirections on landing pages add delays to the page load and while the redirections are occurring, nothing is shown to the client. In many cases, redirections can be eliminated without changing the function of a page.着陆页的重定向会增加页面加载的延迟，并且当重定向发生时，客户端不会显示任何内容。 在许多情况下，可以消除重定向而不改变页面的功能。</p>\n<h3 id=\"Defer-parsing-of-JavaScript-延迟JavaScript的解析\"><a href=\"#Defer-parsing-of-JavaScript-延迟JavaScript的解析\" class=\"headerlink\" title=\"Defer parsing of JavaScript 延迟JavaScript的解析\"></a>Defer parsing of JavaScript 延迟JavaScript的解析</h3><p>In order to load a page, the browser must parse the contents of all <script> tags, which adds additional time to the page load. By minimizing the amount of JavaScript needed to render the page, and deferring parsing of unneeded JavaScript until it needs to be executed, you can reduce the initial load time of your page.为了加载页面，浏览器必须解析所有<script>标签的内容，这会给页面加载增加额外的时间。 通过最小化呈现页面所需的JavaScript量，并推迟对不需要的JavaScript进行解析，直到需要执行它，您可以减少页面的初始加载时间。</p>\n<h3 id=\"Enable-Keep-Alive-启用保持活动\"><a href=\"#Enable-Keep-Alive-启用保持活动\" class=\"headerlink\" title=\"Enable Keep-Alive 启用保持活动\"></a>Enable Keep-Alive 启用保持活动</h3><p>Enabling HTTP Keep-Alive or HTTP persistent connections allow the same TCP connection to send and receive multiple HTTP requests, thus reducing the latency for subsequent requests.启用HTTP Keep-Alive或HTTP持久连接允许同一TCP连接发送和接收多个HTTP请求，从而减少后续请求的延迟。</p>\n<h3 id=\"Inline-small-CSS-内联小型外部CSS文件\"><a href=\"#Inline-small-CSS-内联小型外部CSS文件\" class=\"headerlink\" title=\"Inline small CSS 内联小型外部CSS文件\"></a>Inline small CSS 内联小型外部CSS文件</h3><p>Inlining small external CSS files can save the overhead of fetching these small files. A good alternative to inline CSS is to combine the external CSS files.内联小型外部CSS文件可以节省获取这些小文件的开销。 内联CSS的一个好的替代方法是组合外部CSS文件。</p>\n<h2 id=\"PageSpeed的检查项\"><a href=\"#PageSpeed的检查项\" class=\"headerlink\" title=\"PageSpeed的检查项\"></a>PageSpeed的检查项</h2><h2 id=\"Waterfall\"><a href=\"#Waterfall\" class=\"headerlink\" title=\"Waterfall\"></a>Waterfall</h2><h2 id=\"Timings\"><a href=\"#Timings\" class=\"headerlink\" title=\"Timings\"></a>Timings</h2><h2 id=\"vedio\"><a href=\"#vedio\" class=\"headerlink\" title=\"vedio\"></a>vedio</h2><h2 id=\"Histroy\"><a href=\"#Histroy\" class=\"headerlink\" title=\"Histroy\"></a>Histroy</h2></script></p></the>","site":{"data":{}},"excerpt":"<p><excerpt in index | 首页摘要><br>网址是：<a href=\"http://gtmetrix.com/\" target=\"_blank\" rel=\"noopener\">http://gtmetrix.com/</a> ，输入自己需要分析的链接，稍微等会儿，有两个得分，一是YSlow的分析得分，二是PageSpeed的分析得分。<br></excerpt></p>","more":"<p></p>\n<the rest of contents | 余下全文>\n\n<p><img src=\"/2017/02/28/gtmetix/1.jpg\" alt=\"logo\"><br>一般互联网的网站，得分要达到C（包含A和B）以上，最好能达到B。</p>\n<h2 id=\"YSlow的检查项目\"><a href=\"#YSlow的检查项目\" class=\"headerlink\" title=\"YSlow的检查项目\"></a>YSlow的检查项目</h2><h3 id=\"Leverage-browser-caching-浏览器缓存\"><a href=\"#Leverage-browser-caching-浏览器缓存\" class=\"headerlink\" title=\"Leverage browser caching  浏览器缓存\"></a>Leverage browser caching  浏览器缓存</h3><p>  Page load times can be significantly improved by asking visitors to save and reuse the files included in your website. 要求访问者保存和重复使用您网站中包含的文件，可以显着提高页面加载时间。</p>\n<h3 id=\"Specify-a-cache-validator-指定缓存验证器\"><a href=\"#Specify-a-cache-validator-指定缓存验证器\" class=\"headerlink\" title=\"Specify a cache validator 指定缓存验证器\"></a>Specify a cache validator 指定缓存验证器</h3><p>All static resources should have either a Last-Modified or ETag header. This will allow browsers to take advantage of the full benefits of caching.所有静态资源应具有Last-Modified或ETag头。 这将允许浏览器利用缓存的全部好处。</p>\n<h3 id=\"Optimize-images-优化图片\"><a href=\"#Optimize-images-优化图片\" class=\"headerlink\" title=\"Optimize images 优化图片\"></a>Optimize images 优化图片</h3><p>Reduce the load times of pages by loading appropriately sized images.通过加载适当大小的图像减少页面的加载时间。</p>\n<h3 id=\"Specify-image-dimensions-指定图片大小\"><a href=\"#Specify-image-dimensions-指定图片大小\" class=\"headerlink\" title=\"Specify image dimensions 指定图片大小\"></a>Specify image dimensions 指定图片大小</h3><p>Specifying a width and height for all images allows for faster rendering by eliminating the need for unnecessary reflows and repaints.为所有图像指定宽度和高度允许通过消除对不必要的回流和重绘的需要来更快地呈现。</p>\n<h3 id=\"Enable-gzip-compression-启用gzip压缩\"><a href=\"#Enable-gzip-compression-启用gzip压缩\" class=\"headerlink\" title=\"Enable gzip compression 启用gzip压缩\"></a>Enable gzip compression 启用gzip压缩</h3><p>Reduce the size of files sent from your server to increase the speed to which they are transferred to the browser.减少从服务器发送的文件的大小，以提高它们传输到浏览器的速度。</p>\n<h3 id=\"Minify-JavaScript-缩小javascript\"><a href=\"#Minify-JavaScript-缩小javascript\" class=\"headerlink\" title=\"Minify JavaScript 缩小javascript\"></a>Minify JavaScript 缩小javascript</h3><p>Compacting JavaScript code can save many bytes of data and speed up downloading, parsing, and execution time.压缩JavaScript代码可以节省大量数据字节，并加快下载，解析和执行时间</p>\n<h3 id=\"Minify-HTML-缩小HTML\"><a href=\"#Minify-HTML-缩小HTML\" class=\"headerlink\" title=\"Minify HTML 缩小HTML\"></a>Minify HTML 缩小HTML</h3><p>Compacting HTML code, including any inline JavaScript and CSS contained in it, can save many bytes of data and speed up downloading, parsing, and execution time.压缩HTML代码，包括其中包含的任何内联JavaScript和CSS，可以节省许多字节的数据，加快下载，解析和执行时间。</p>\n<h3 id=\"Specify-a-Vary-Accept-Encoding-header\"><a href=\"#Specify-a-Vary-Accept-Encoding-header\" class=\"headerlink\" title=\"Specify a Vary: Accept-Encoding header\"></a>Specify a Vary: Accept-Encoding header</h3><p>Bugs in some public proxies may lead to compressed versions of your resources being served to users that don’t support compression. Specifying the Vary: Accept-Encoding header instructs the proxy to store both a compressed and uncompressed version of the resource.一些公共代理中的错误可能导致向不支持压缩的用户提供资源的压缩版本。 指定Vary：Accept-Encoding标头指示代理存储资源的压缩和未压缩版本。</p>\n<h3 id=\"Remove-query-strings-from-static-resources-从静态资源中删除查询字符串\"><a href=\"#Remove-query-strings-from-static-resources-从静态资源中删除查询字符串\" class=\"headerlink\" title=\"Remove query strings from static resources 从静态资源中删除查询字符串\"></a>Remove query strings from static resources 从静态资源中删除查询字符串</h3><p>Most proxies, most notably Squid up through version 3.0, do not cache resources with a “?” in their URL even if a Cache-control: public header is present in the response. To enable proxy caching for these resources, remove query strings from references to static resources, and instead encode the parameters into the file names themselves.大多数代理，最引人注目的是Squid通过3.0版本，不缓存资源与“？ 即使在响应中存在Cache-control：public标头，也可以在其URL中查找。 要为这些资源启用代理缓存，请从静态资源引用中删除查询字符串，而不是将参数编入文件名本身。</p>\n<h3 id=\"Avoid-bad-requests-避免不良的请求\"><a href=\"#Avoid-bad-requests-避免不良的请求\" class=\"headerlink\" title=\"Avoid bad requests 避免不良的请求\"></a>Avoid bad requests 避免不良的请求</h3><p>Removing “broken links”, or requests that result in 404/410 errors, avoids wasteful requests.删除“损坏的链接”或导致404/410错误的请求，可避免浪费的请求。</p>\n<h3 id=\"Avoid-landing-page-redirects-避免着陆页重定向\"><a href=\"#Avoid-landing-page-redirects-避免着陆页重定向\" class=\"headerlink\" title=\"Avoid landing page redirects 避免着陆页重定向\"></a>Avoid landing page redirects 避免着陆页重定向</h3><p>Redirections on landing pages add delays to the page load and while the redirections are occurring, nothing is shown to the client. In many cases, redirections can be eliminated without changing the function of a page.着陆页的重定向会增加页面加载的延迟，并且当重定向发生时，客户端不会显示任何内容。 在许多情况下，可以消除重定向而不改变页面的功能。</p>\n<h3 id=\"Defer-parsing-of-JavaScript-延迟JavaScript的解析\"><a href=\"#Defer-parsing-of-JavaScript-延迟JavaScript的解析\" class=\"headerlink\" title=\"Defer parsing of JavaScript 延迟JavaScript的解析\"></a>Defer parsing of JavaScript 延迟JavaScript的解析</h3><p>In order to load a page, the browser must parse the contents of all <script> tags, which adds additional time to the page load. By minimizing the amount of JavaScript needed to render the page, and deferring parsing of unneeded JavaScript until it needs to be executed, you can reduce the initial load time of your page.为了加载页面，浏览器必须解析所有<script>标签的内容，这会给页面加载增加额外的时间。 通过最小化呈现页面所需的JavaScript量，并推迟对不需要的JavaScript进行解析，直到需要执行它，您可以减少页面的初始加载时间。</p>\n<h3 id=\"Enable-Keep-Alive-启用保持活动\"><a href=\"#Enable-Keep-Alive-启用保持活动\" class=\"headerlink\" title=\"Enable Keep-Alive 启用保持活动\"></a>Enable Keep-Alive 启用保持活动</h3><p>Enabling HTTP Keep-Alive or HTTP persistent connections allow the same TCP connection to send and receive multiple HTTP requests, thus reducing the latency for subsequent requests.启用HTTP Keep-Alive或HTTP持久连接允许同一TCP连接发送和接收多个HTTP请求，从而减少后续请求的延迟。</p>\n<h3 id=\"Inline-small-CSS-内联小型外部CSS文件\"><a href=\"#Inline-small-CSS-内联小型外部CSS文件\" class=\"headerlink\" title=\"Inline small CSS 内联小型外部CSS文件\"></a>Inline small CSS 内联小型外部CSS文件</h3><p>Inlining small external CSS files can save the overhead of fetching these small files. A good alternative to inline CSS is to combine the external CSS files.内联小型外部CSS文件可以节省获取这些小文件的开销。 内联CSS的一个好的替代方法是组合外部CSS文件。</p>\n<h2 id=\"PageSpeed的检查项\"><a href=\"#PageSpeed的检查项\" class=\"headerlink\" title=\"PageSpeed的检查项\"></a>PageSpeed的检查项</h2><h2 id=\"Waterfall\"><a href=\"#Waterfall\" class=\"headerlink\" title=\"Waterfall\"></a>Waterfall</h2><h2 id=\"Timings\"><a href=\"#Timings\" class=\"headerlink\" title=\"Timings\"></a>Timings</h2><h2 id=\"vedio\"><a href=\"#vedio\" class=\"headerlink\" title=\"vedio\"></a>vedio</h2><h2 id=\"Histroy\"><a href=\"#Histroy\" class=\"headerlink\" title=\"Histroy\"></a>Histroy</h2></script></p></the>"},{"title":"spring admin配置","author":"wen","date":"2019-05-29T08:54:00.000Z","_content":"spring admin 接入 eureka\n\npom.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.test.springcloud</groupId>\n  <artifactId>springamdinserver</artifactId>\n  <version>2.1</version>\n\n   <name>基础设施:springamdinserver</name>\n\n  <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.0.RELEASE</version>\n    </parent>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n    <version>2.1.4</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n  </dependencies>\n\n   <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Finchley.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n  <build>\n   \n    <plugins>\n     <!-- 源码格式 -->\n            <plugin>  \n                <groupId>com.googlecode.maven-java-formatter-plugin</groupId>  \n                <artifactId>maven-java-formatter-plugin</artifactId>  \n                <version>0.4</version>  \n                <configuration>  \n                    <configFile>${project.basedir}/code-style.xml</configFile>  \n                </configuration>  \n                <executions>  \n                    <!--                 \t<execution>   -->\n                    <!--                     \t<goals>   -->\n                    <!--                         \t<goal>format</goal>   -->\n                    <!--                         </goals>   -->\n                    <!--                     </execution>   -->\n                </executions>  \n            </plugin>\n            <!-- 单元测试与覆盖率 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.1</version><!--$NO-MVN-MAN-VER$-->\n                <dependencies>\n                    <dependency>\n                        <groupId>org.apache.maven.surefire</groupId>\n                        <artifactId>surefire-junit47</artifactId>\n                        <version>2.21.0</version>\n                    </dependency>\n                </dependencies>\n                <configuration>\n                    <skip>true</skip>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-report-plugin</artifactId>\n                <version>2.21.0</version>\n                <configuration>\n                    <includes>\n                        <include>**/*Test.java</include>\n                    </includes>\n                </configuration>\n            </plugin>\n            <plugin>  \n                <groupId>org.codehaus.mojo</groupId>  \n                <artifactId>cobertura-maven-plugin</artifactId>  \n                <version>2.7</version> \n                <configuration>\n                    <formats>\n                        <format>html</format>\n                        <format>xml</format>\n                    </formats>\n                </configuration> \n            </plugin>\n            <!--编译-->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.0</version><!--$NO-MVN-MAN-VER$-->\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n            <!-- javadoc文档 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-javadoc-plugin</artifactId>\n                <version>3.0.1</version><!--$NO-MVN-MAN-VER$-->\n                <configuration>\n                    <aggregate>true</aggregate>\n                </configuration>\n            </plugin>\n            <!-- spring boot -->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>repackage</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.8</version><!--$NO-MVN-MAN-VER$-->\n                <executions>\n                    <execution>\n                        <id>copy-lib-src-webapps</id>\n                        <phase>package</phase>\n                        <configuration>\n                            <target>\n                                <copy todir=\"${project.basedir}/docker\">\n                                    <fileset dir=\"${project.basedir}/target\">\n                                        <include name=\"*.jar\" />\n                                    </fileset>\n                                </copy>\n                            </target>\n                        </configuration>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>docker-maven-plugin</artifactId>\n                <version>1.2.0</version>\n                <configuration>\n                    <!-- imageName必须全为小写 -->\n                    <imageName>springboot-unit-test:1.0</imageName>\n                    <dockerDirectory>${project.basedir}/docker</dockerDirectory>\n                    <resources>\n                        <resource>\n                            <targetPath>/</targetPath>\n                            <directory>${project.build.directory}</directory>\n                            <include>${project.build.finalName}.jar</include>\n                        </resource>\n                    </resources>\n                </configuration>\n            </plugin>\n      </plugins>\n  </build>\n</project>\n\n\n```\n\napplication.properties\n\n```\nspring.application.name=springadminserver\nserver.port=8080\n#using the info endpoint\ninfo.tags.environment=test\n#配置eureka\neureka.client.serviceUrl.defaultZone=${EUREKA_SERVICEURL}\neureka.instance.prefer-ip-address=true\nspring.cloud.inetutils.preferredNetworks=${PREFERRED_IP_PATTERN:.*}\neureka.instance.preferIpAddress=true\neureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}\neureka.instance.leaseRenewalIntervalInSeconds=10\neureka.instance.health-check-url-path=/actuator/health\neureka.client.registryFetchIntervalSeconds=5\n#公开的站点\nmanagement.endpoints.web.exposure.include=*\nmanagement.endpoints.health.show-details=ALWAYS\n# 安全密码\nspring.security.user.name=user\nspring.security.user.password=123456\n```\n\nSpringBootAdminApplication\n```\npackage com.springamdinserver;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;\n\nimport de.codecentric.boot.admin.server.config.AdminServerProperties;\nimport de.codecentric.boot.admin.server.config.EnableAdminServer;\n\n@Configuration\n@EnableAutoConfiguration\n@EnableAdminServer\n@EnableDiscoveryClient\npublic class SpringBootAdminApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAdminApplication.class, args);\n    }\n\n    @Configuration\n    public static class SecurityPermitAllConfig extends WebSecurityConfigurerAdapter {\n        private final String adminContextPath;\n\n        public SecurityPermitAllConfig(AdminServerProperties adminServerProperties) {\n            this.adminContextPath = adminServerProperties.getContextPath();\n        }\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n            // @formatter:off\n            SavedRequestAwareAuthenticationSuccessHandler successHandler =\n                    new SavedRequestAwareAuthenticationSuccessHandler();\n            successHandler.setTargetUrlParameter(\"redirectTo\");\n\n            http.authorizeRequests().antMatchers(adminContextPath + \"/assets/**\").permitAll()\n                    .antMatchers(adminContextPath + \"/login\").permitAll().anyRequest().authenticated().and()\n                    .formLogin().loginPage(adminContextPath + \"/login\").successHandler(successHandler).and().logout()\n                    .logoutUrl(adminContextPath + \"/logout\").and().httpBasic().and().csrf().disable();\n            // @formatter:on\n        }\n    }\n}\n\n```\n客户端配置\n```\nmanagement.endpoints.web.exposure.include=*\nmanagement.endpoints.health.show-details=ALWAYS\n##日志路径\nlogging.path=/applog/logincenterWxBindingService\n```\n重启服务\n\n控制台：\nhttp://localhost:8080/\n![logo](pring-admin配置/1.png)\neurka上服务\n![logo](pring-admin配置/2.png)\n每个服务 内存情况\n![logo](pring-admin配置/3.png)\n查看日志\n![logo](pring-admin配置/4.png)\n流量情况：\n![logo](pring-admin配置/5.png)\n\n\n参考：https://github.com/codecentric/spring-boot-admin","source":"_posts/pring-admin配置.md","raw":"title: spring admin配置\nauthor: wen\ntags:\n  - springAdmin\n  - spring cloud\ncategories:\n  - spring cloud\ndate: 2019-05-29 16:54:00\n---\nspring admin 接入 eureka\n\npom.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.test.springcloud</groupId>\n  <artifactId>springamdinserver</artifactId>\n  <version>2.1</version>\n\n   <name>基础设施:springamdinserver</name>\n\n  <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.0.RELEASE</version>\n    </parent>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n    <version>2.1.4</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n  </dependencies>\n\n   <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Finchley.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n  <build>\n   \n    <plugins>\n     <!-- 源码格式 -->\n            <plugin>  \n                <groupId>com.googlecode.maven-java-formatter-plugin</groupId>  \n                <artifactId>maven-java-formatter-plugin</artifactId>  \n                <version>0.4</version>  \n                <configuration>  \n                    <configFile>${project.basedir}/code-style.xml</configFile>  \n                </configuration>  \n                <executions>  \n                    <!--                 \t<execution>   -->\n                    <!--                     \t<goals>   -->\n                    <!--                         \t<goal>format</goal>   -->\n                    <!--                         </goals>   -->\n                    <!--                     </execution>   -->\n                </executions>  \n            </plugin>\n            <!-- 单元测试与覆盖率 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.1</version><!--$NO-MVN-MAN-VER$-->\n                <dependencies>\n                    <dependency>\n                        <groupId>org.apache.maven.surefire</groupId>\n                        <artifactId>surefire-junit47</artifactId>\n                        <version>2.21.0</version>\n                    </dependency>\n                </dependencies>\n                <configuration>\n                    <skip>true</skip>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-report-plugin</artifactId>\n                <version>2.21.0</version>\n                <configuration>\n                    <includes>\n                        <include>**/*Test.java</include>\n                    </includes>\n                </configuration>\n            </plugin>\n            <plugin>  \n                <groupId>org.codehaus.mojo</groupId>  \n                <artifactId>cobertura-maven-plugin</artifactId>  \n                <version>2.7</version> \n                <configuration>\n                    <formats>\n                        <format>html</format>\n                        <format>xml</format>\n                    </formats>\n                </configuration> \n            </plugin>\n            <!--编译-->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.0</version><!--$NO-MVN-MAN-VER$-->\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n            <!-- javadoc文档 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-javadoc-plugin</artifactId>\n                <version>3.0.1</version><!--$NO-MVN-MAN-VER$-->\n                <configuration>\n                    <aggregate>true</aggregate>\n                </configuration>\n            </plugin>\n            <!-- spring boot -->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>repackage</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.8</version><!--$NO-MVN-MAN-VER$-->\n                <executions>\n                    <execution>\n                        <id>copy-lib-src-webapps</id>\n                        <phase>package</phase>\n                        <configuration>\n                            <target>\n                                <copy todir=\"${project.basedir}/docker\">\n                                    <fileset dir=\"${project.basedir}/target\">\n                                        <include name=\"*.jar\" />\n                                    </fileset>\n                                </copy>\n                            </target>\n                        </configuration>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>docker-maven-plugin</artifactId>\n                <version>1.2.0</version>\n                <configuration>\n                    <!-- imageName必须全为小写 -->\n                    <imageName>springboot-unit-test:1.0</imageName>\n                    <dockerDirectory>${project.basedir}/docker</dockerDirectory>\n                    <resources>\n                        <resource>\n                            <targetPath>/</targetPath>\n                            <directory>${project.build.directory}</directory>\n                            <include>${project.build.finalName}.jar</include>\n                        </resource>\n                    </resources>\n                </configuration>\n            </plugin>\n      </plugins>\n  </build>\n</project>\n\n\n```\n\napplication.properties\n\n```\nspring.application.name=springadminserver\nserver.port=8080\n#using the info endpoint\ninfo.tags.environment=test\n#配置eureka\neureka.client.serviceUrl.defaultZone=${EUREKA_SERVICEURL}\neureka.instance.prefer-ip-address=true\nspring.cloud.inetutils.preferredNetworks=${PREFERRED_IP_PATTERN:.*}\neureka.instance.preferIpAddress=true\neureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}\neureka.instance.leaseRenewalIntervalInSeconds=10\neureka.instance.health-check-url-path=/actuator/health\neureka.client.registryFetchIntervalSeconds=5\n#公开的站点\nmanagement.endpoints.web.exposure.include=*\nmanagement.endpoints.health.show-details=ALWAYS\n# 安全密码\nspring.security.user.name=user\nspring.security.user.password=123456\n```\n\nSpringBootAdminApplication\n```\npackage com.springamdinserver;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;\n\nimport de.codecentric.boot.admin.server.config.AdminServerProperties;\nimport de.codecentric.boot.admin.server.config.EnableAdminServer;\n\n@Configuration\n@EnableAutoConfiguration\n@EnableAdminServer\n@EnableDiscoveryClient\npublic class SpringBootAdminApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAdminApplication.class, args);\n    }\n\n    @Configuration\n    public static class SecurityPermitAllConfig extends WebSecurityConfigurerAdapter {\n        private final String adminContextPath;\n\n        public SecurityPermitAllConfig(AdminServerProperties adminServerProperties) {\n            this.adminContextPath = adminServerProperties.getContextPath();\n        }\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n            // @formatter:off\n            SavedRequestAwareAuthenticationSuccessHandler successHandler =\n                    new SavedRequestAwareAuthenticationSuccessHandler();\n            successHandler.setTargetUrlParameter(\"redirectTo\");\n\n            http.authorizeRequests().antMatchers(adminContextPath + \"/assets/**\").permitAll()\n                    .antMatchers(adminContextPath + \"/login\").permitAll().anyRequest().authenticated().and()\n                    .formLogin().loginPage(adminContextPath + \"/login\").successHandler(successHandler).and().logout()\n                    .logoutUrl(adminContextPath + \"/logout\").and().httpBasic().and().csrf().disable();\n            // @formatter:on\n        }\n    }\n}\n\n```\n客户端配置\n```\nmanagement.endpoints.web.exposure.include=*\nmanagement.endpoints.health.show-details=ALWAYS\n##日志路径\nlogging.path=/applog/logincenterWxBindingService\n```\n重启服务\n\n控制台：\nhttp://localhost:8080/\n![logo](pring-admin配置/1.png)\neurka上服务\n![logo](pring-admin配置/2.png)\n每个服务 内存情况\n![logo](pring-admin配置/3.png)\n查看日志\n![logo](pring-admin配置/4.png)\n流量情况：\n![logo](pring-admin配置/5.png)\n\n\n参考：https://github.com/codecentric/spring-boot-admin","slug":"pring-admin配置","published":1,"updated":"2019-06-09T15:13:13.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce387001bn6zq3ej74k98","content":"<p>spring admin 接入 eureka</p>\n<p>pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;groupId&gt;com.test.springcloud&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;springamdinserver&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;2.1&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;name&gt;基础设施:springamdinserver&lt;/name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;parent&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;properties&gt;</span><br><span class=\"line\">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class=\"line\">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class=\"line\">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class=\"line\">  &lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.1.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;Finchley.RELEASE&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br><span class=\"line\">  &lt;build&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">     &lt;!-- 源码格式 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;  </span><br><span class=\"line\">                &lt;groupId&gt;com.googlecode.maven-java-formatter-plugin&lt;/groupId&gt;  </span><br><span class=\"line\">                &lt;artifactId&gt;maven-java-formatter-plugin&lt;/artifactId&gt;  </span><br><span class=\"line\">                &lt;version&gt;0.4&lt;/version&gt;  </span><br><span class=\"line\">                &lt;configuration&gt;  </span><br><span class=\"line\">                    &lt;configFile&gt;$&#123;project.basedir&#125;/code-style.xml&lt;/configFile&gt;  </span><br><span class=\"line\">                &lt;/configuration&gt;  </span><br><span class=\"line\">                &lt;executions&gt;  </span><br><span class=\"line\">                    &lt;!--                 \t&lt;execution&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                     \t&lt;goals&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                         \t&lt;goal&gt;format&lt;/goal&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                         &lt;/goals&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                     &lt;/execution&gt;   --&gt;</span><br><span class=\"line\">                &lt;/executions&gt;  </span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- 单元测试与覆盖率 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.22.1&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;dependencies&gt;</span><br><span class=\"line\">                    &lt;dependency&gt;</span><br><span class=\"line\">                        &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt;</span><br><span class=\"line\">                        &lt;artifactId&gt;surefire-junit47&lt;/artifactId&gt;</span><br><span class=\"line\">                        &lt;version&gt;2.21.0&lt;/version&gt;</span><br><span class=\"line\">                    &lt;/dependency&gt;</span><br><span class=\"line\">                &lt;/dependencies&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;skip&gt;true&lt;/skip&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-report-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.21.0&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;includes&gt;</span><br><span class=\"line\">                        &lt;include&gt;**/*Test.java&lt;/include&gt;</span><br><span class=\"line\">                    &lt;/includes&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;  </span><br><span class=\"line\">                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;  </span><br><span class=\"line\">                &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt;  </span><br><span class=\"line\">                &lt;version&gt;2.7&lt;/version&gt; </span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;formats&gt;</span><br><span class=\"line\">                        &lt;format&gt;html&lt;/format&gt;</span><br><span class=\"line\">                        &lt;format&gt;xml&lt;/format&gt;</span><br><span class=\"line\">                    &lt;/formats&gt;</span><br><span class=\"line\">                &lt;/configuration&gt; </span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!--编译--&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.8.0&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- javadoc文档 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.1&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;aggregate&gt;true&lt;/aggregate&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- spring boot --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;1.8&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;id&gt;copy-lib-src-webapps&lt;/id&gt;</span><br><span class=\"line\">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class=\"line\">                        &lt;configuration&gt;</span><br><span class=\"line\">                            &lt;target&gt;</span><br><span class=\"line\">                                &lt;copy todir=&quot;$&#123;project.basedir&#125;/docker&quot;&gt;</span><br><span class=\"line\">                                    &lt;fileset dir=&quot;$&#123;project.basedir&#125;/target&quot;&gt;</span><br><span class=\"line\">                                        &lt;include name=&quot;*.jar&quot; /&gt;</span><br><span class=\"line\">                                    &lt;/fileset&gt;</span><br><span class=\"line\">                                &lt;/copy&gt;</span><br><span class=\"line\">                            &lt;/target&gt;</span><br><span class=\"line\">                        &lt;/configuration&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;run&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;1.2.0&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;!-- imageName必须全为小写 --&gt;</span><br><span class=\"line\">                    &lt;imageName&gt;springboot-unit-test:1.0&lt;/imageName&gt;</span><br><span class=\"line\">                    &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/docker&lt;/dockerDirectory&gt;</span><br><span class=\"line\">                    &lt;resources&gt;</span><br><span class=\"line\">                        &lt;resource&gt;</span><br><span class=\"line\">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class=\"line\">                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class=\"line\">                            &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class=\"line\">                        &lt;/resource&gt;</span><br><span class=\"line\">                    &lt;/resources&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">      &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>\n<p>application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=springadminserver</span><br><span class=\"line\">server.port=8080</span><br><span class=\"line\">#using the info endpoint</span><br><span class=\"line\">info.tags.environment=test</span><br><span class=\"line\">#配置eureka</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=$&#123;EUREKA_SERVICEURL&#125;</span><br><span class=\"line\">eureka.instance.prefer-ip-address=true</span><br><span class=\"line\">spring.cloud.inetutils.preferredNetworks=$&#123;PREFERRED_IP_PATTERN:.*&#125;</span><br><span class=\"line\">eureka.instance.preferIpAddress=true</span><br><span class=\"line\">eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span><br><span class=\"line\">eureka.instance.leaseRenewalIntervalInSeconds=10</span><br><span class=\"line\">eureka.instance.health-check-url-path=/actuator/health</span><br><span class=\"line\">eureka.client.registryFetchIntervalSeconds=5</span><br><span class=\"line\">#公开的站点</span><br><span class=\"line\">management.endpoints.web.exposure.include=*</span><br><span class=\"line\">management.endpoints.health.show-details=ALWAYS</span><br><span class=\"line\"># 安全密码</span><br><span class=\"line\">spring.security.user.name=user</span><br><span class=\"line\">spring.security.user.password=123456</span><br></pre></td></tr></table></figure>\n<p>SpringBootAdminApplication<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.springamdinserver;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class=\"line\">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class=\"line\">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class=\"line\">import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">import de.codecentric.boot.admin.server.config.AdminServerProperties;</span><br><span class=\"line\">import de.codecentric.boot.admin.server.config.EnableAdminServer;</span><br><span class=\"line\"></span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableAutoConfiguration</span><br><span class=\"line\">@EnableAdminServer</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">public class SpringBootAdminApplication &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Configuration</span><br><span class=\"line\">    public static class SecurityPermitAllConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class=\"line\">        private final String adminContextPath;</span><br><span class=\"line\"></span><br><span class=\"line\">        public SecurityPermitAllConfig(AdminServerProperties adminServerProperties) &#123;</span><br><span class=\"line\">            this.adminContextPath = adminServerProperties.getContextPath();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class=\"line\">            // @formatter:off</span><br><span class=\"line\">            SavedRequestAwareAuthenticationSuccessHandler successHandler =</span><br><span class=\"line\">                    new SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class=\"line\">            successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            http.authorizeRequests().antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()</span><br><span class=\"line\">                    .antMatchers(adminContextPath + &quot;/login&quot;).permitAll().anyRequest().authenticated().and()</span><br><span class=\"line\">                    .formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and().logout()</span><br><span class=\"line\">                    .logoutUrl(adminContextPath + &quot;/logout&quot;).and().httpBasic().and().csrf().disable();</span><br><span class=\"line\">            // @formatter:on</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">management.endpoints.web.exposure.include=*</span><br><span class=\"line\">management.endpoints.health.show-details=ALWAYS</span><br><span class=\"line\">##日志路径</span><br><span class=\"line\">logging.path=/applog/logincenterWxBindingService</span><br></pre></td></tr></table></figure></p>\n<p>重启服务</p>\n<p>控制台：<br><a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a><br><img src=\"/2019/05/29/pring-admin配置/1.png\" alt=\"logo\"><br>eurka上服务<br><img src=\"/2019/05/29/pring-admin配置/2.png\" alt=\"logo\"><br>每个服务 内存情况<br><img src=\"/2019/05/29/pring-admin配置/3.png\" alt=\"logo\"><br>查看日志<br><img src=\"/2019/05/29/pring-admin配置/4.png\" alt=\"logo\"><br>流量情况：<br><img src=\"/2019/05/29/pring-admin配置/5.png\" alt=\"logo\"></p>\n<p>参考：<a href=\"https://github.com/codecentric/spring-boot-admin\" target=\"_blank\" rel=\"noopener\">https://github.com/codecentric/spring-boot-admin</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>spring admin 接入 eureka</p>\n<p>pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;groupId&gt;com.test.springcloud&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;springamdinserver&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;2.1&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;name&gt;基础设施:springamdinserver&lt;/name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;parent&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;properties&gt;</span><br><span class=\"line\">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class=\"line\">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class=\"line\">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class=\"line\">  &lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.1.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;Finchley.RELEASE&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br><span class=\"line\">  &lt;build&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">     &lt;!-- 源码格式 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;  </span><br><span class=\"line\">                &lt;groupId&gt;com.googlecode.maven-java-formatter-plugin&lt;/groupId&gt;  </span><br><span class=\"line\">                &lt;artifactId&gt;maven-java-formatter-plugin&lt;/artifactId&gt;  </span><br><span class=\"line\">                &lt;version&gt;0.4&lt;/version&gt;  </span><br><span class=\"line\">                &lt;configuration&gt;  </span><br><span class=\"line\">                    &lt;configFile&gt;$&#123;project.basedir&#125;/code-style.xml&lt;/configFile&gt;  </span><br><span class=\"line\">                &lt;/configuration&gt;  </span><br><span class=\"line\">                &lt;executions&gt;  </span><br><span class=\"line\">                    &lt;!--                 \t&lt;execution&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                     \t&lt;goals&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                         \t&lt;goal&gt;format&lt;/goal&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                         &lt;/goals&gt;   --&gt;</span><br><span class=\"line\">                    &lt;!--                     &lt;/execution&gt;   --&gt;</span><br><span class=\"line\">                &lt;/executions&gt;  </span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- 单元测试与覆盖率 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.22.1&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;dependencies&gt;</span><br><span class=\"line\">                    &lt;dependency&gt;</span><br><span class=\"line\">                        &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt;</span><br><span class=\"line\">                        &lt;artifactId&gt;surefire-junit47&lt;/artifactId&gt;</span><br><span class=\"line\">                        &lt;version&gt;2.21.0&lt;/version&gt;</span><br><span class=\"line\">                    &lt;/dependency&gt;</span><br><span class=\"line\">                &lt;/dependencies&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;skip&gt;true&lt;/skip&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-report-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.21.0&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;includes&gt;</span><br><span class=\"line\">                        &lt;include&gt;**/*Test.java&lt;/include&gt;</span><br><span class=\"line\">                    &lt;/includes&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;  </span><br><span class=\"line\">                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;  </span><br><span class=\"line\">                &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt;  </span><br><span class=\"line\">                &lt;version&gt;2.7&lt;/version&gt; </span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;formats&gt;</span><br><span class=\"line\">                        &lt;format&gt;html&lt;/format&gt;</span><br><span class=\"line\">                        &lt;format&gt;xml&lt;/format&gt;</span><br><span class=\"line\">                    &lt;/formats&gt;</span><br><span class=\"line\">                &lt;/configuration&gt; </span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!--编译--&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.8.0&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- javadoc文档 --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.1&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;aggregate&gt;true&lt;/aggregate&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- spring boot --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;1.8&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;id&gt;copy-lib-src-webapps&lt;/id&gt;</span><br><span class=\"line\">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class=\"line\">                        &lt;configuration&gt;</span><br><span class=\"line\">                            &lt;target&gt;</span><br><span class=\"line\">                                &lt;copy todir=&quot;$&#123;project.basedir&#125;/docker&quot;&gt;</span><br><span class=\"line\">                                    &lt;fileset dir=&quot;$&#123;project.basedir&#125;/target&quot;&gt;</span><br><span class=\"line\">                                        &lt;include name=&quot;*.jar&quot; /&gt;</span><br><span class=\"line\">                                    &lt;/fileset&gt;</span><br><span class=\"line\">                                &lt;/copy&gt;</span><br><span class=\"line\">                            &lt;/target&gt;</span><br><span class=\"line\">                        &lt;/configuration&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;run&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;1.2.0&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;!-- imageName必须全为小写 --&gt;</span><br><span class=\"line\">                    &lt;imageName&gt;springboot-unit-test:1.0&lt;/imageName&gt;</span><br><span class=\"line\">                    &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/docker&lt;/dockerDirectory&gt;</span><br><span class=\"line\">                    &lt;resources&gt;</span><br><span class=\"line\">                        &lt;resource&gt;</span><br><span class=\"line\">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class=\"line\">                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class=\"line\">                            &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class=\"line\">                        &lt;/resource&gt;</span><br><span class=\"line\">                    &lt;/resources&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">      &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>\n<p>application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=springadminserver</span><br><span class=\"line\">server.port=8080</span><br><span class=\"line\">#using the info endpoint</span><br><span class=\"line\">info.tags.environment=test</span><br><span class=\"line\">#配置eureka</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=$&#123;EUREKA_SERVICEURL&#125;</span><br><span class=\"line\">eureka.instance.prefer-ip-address=true</span><br><span class=\"line\">spring.cloud.inetutils.preferredNetworks=$&#123;PREFERRED_IP_PATTERN:.*&#125;</span><br><span class=\"line\">eureka.instance.preferIpAddress=true</span><br><span class=\"line\">eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span><br><span class=\"line\">eureka.instance.leaseRenewalIntervalInSeconds=10</span><br><span class=\"line\">eureka.instance.health-check-url-path=/actuator/health</span><br><span class=\"line\">eureka.client.registryFetchIntervalSeconds=5</span><br><span class=\"line\">#公开的站点</span><br><span class=\"line\">management.endpoints.web.exposure.include=*</span><br><span class=\"line\">management.endpoints.health.show-details=ALWAYS</span><br><span class=\"line\"># 安全密码</span><br><span class=\"line\">spring.security.user.name=user</span><br><span class=\"line\">spring.security.user.password=123456</span><br></pre></td></tr></table></figure>\n<p>SpringBootAdminApplication<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.springamdinserver;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class=\"line\">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class=\"line\">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class=\"line\">import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">import de.codecentric.boot.admin.server.config.AdminServerProperties;</span><br><span class=\"line\">import de.codecentric.boot.admin.server.config.EnableAdminServer;</span><br><span class=\"line\"></span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableAutoConfiguration</span><br><span class=\"line\">@EnableAdminServer</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">public class SpringBootAdminApplication &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Configuration</span><br><span class=\"line\">    public static class SecurityPermitAllConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class=\"line\">        private final String adminContextPath;</span><br><span class=\"line\"></span><br><span class=\"line\">        public SecurityPermitAllConfig(AdminServerProperties adminServerProperties) &#123;</span><br><span class=\"line\">            this.adminContextPath = adminServerProperties.getContextPath();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class=\"line\">            // @formatter:off</span><br><span class=\"line\">            SavedRequestAwareAuthenticationSuccessHandler successHandler =</span><br><span class=\"line\">                    new SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class=\"line\">            successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            http.authorizeRequests().antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()</span><br><span class=\"line\">                    .antMatchers(adminContextPath + &quot;/login&quot;).permitAll().anyRequest().authenticated().and()</span><br><span class=\"line\">                    .formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and().logout()</span><br><span class=\"line\">                    .logoutUrl(adminContextPath + &quot;/logout&quot;).and().httpBasic().and().csrf().disable();</span><br><span class=\"line\">            // @formatter:on</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">management.endpoints.web.exposure.include=*</span><br><span class=\"line\">management.endpoints.health.show-details=ALWAYS</span><br><span class=\"line\">##日志路径</span><br><span class=\"line\">logging.path=/applog/logincenterWxBindingService</span><br></pre></td></tr></table></figure></p>\n<p>重启服务</p>\n<p>控制台：<br><a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a><br><img src=\"/2019/05/29/pring-admin配置/1.png\" alt=\"logo\"><br>eurka上服务<br><img src=\"/2019/05/29/pring-admin配置/2.png\" alt=\"logo\"><br>每个服务 内存情况<br><img src=\"/2019/05/29/pring-admin配置/3.png\" alt=\"logo\"><br>查看日志<br><img src=\"/2019/05/29/pring-admin配置/4.png\" alt=\"logo\"><br>流量情况：<br><img src=\"/2019/05/29/pring-admin配置/5.png\" alt=\"logo\"></p>\n<p>参考：<a href=\"https://github.com/codecentric/spring-boot-admin\" target=\"_blank\" rel=\"noopener\">https://github.com/codecentric/spring-boot-admin</a></p>\n"},{"title":"查询rabbitmq 队列信息","author":"wen","date":"2019-05-29T08:48:00.000Z","_content":"最近需要做mq 消息预警，消息一旦堆积某个数量就报警。\n\nRabbitMQ自己就提供了HTTP API手册，比如我本地的API手册地址为：http://localhost:15672/api\n\nhttp://localhost:15672/api/queues/%2F/soaSyncPwdQueue\n可以看到队列相关的所有信息都有记录。\n```\n{\n  \"consumer_details\": [\n    {\n      \"arguments\": {\n        \n      },\n      \"channel_details\": {\n        \"connection_name\": \"10.143.172.86:35833 -> 10.210.93.176:5672\",\n        \"name\": \"10.143.172.86:35833 -> 10.210.93.176:5672 (1)\",\n        \"node\": \"rabbit@CNQLS03247\",\n        \"number\": 1,\n        \"peer_host\": \"10.143.172.86\",\n        \"peer_port\": 35833,\n        \"user\": \"logincenter\"\n      },\n      \"ack_required\": true,\n      \"consumer_tag\": \"amq.ctag-Gvgmd8yxscKvBkBiGp3J3g\",\n      \"exclusive\": false,\n      \"prefetch_count\": 0,\n      \"queue\": {\n        \"name\": \"soaSyncPwdQueue\",\n        \"vhost\": \"/\"\n      }\n    }\n  ],\n  \"arguments\": {\n    \"x-dead-letter-exchange\": \"\",\n    \"x-dead-letter-routing-key\": \"DL_soaSyncPwdQueue\"\n  },\n  \"auto_delete\": false,\n  \"backing_queue_status\": {\n    \"avg_ack_egress_rate\": 0.00021645676867156752,\n    \"avg_ack_ingress_rate\": 0.00021645676867156752,\n    \"avg_egress_rate\": 0.00021645676867156752,\n    \"avg_ingress_rate\": 0.00021645676867156752,\n    \"delta\": [\n      \"delta\",\n      \"undefined\",\n      0,\n      0,\n      \"undefined\"\n    ],\n    \"len\": 0,\n    \"mode\": \"default\",\n    \"next_seq_id\": 2177,\n    \"q1\": 0,\n    \"q2\": 0,\n    \"q3\": 0,\n    \"q4\": 0,\n    \"target_ram_count\": \"infinity\"\n  },\n  \"consumer_utilisation\": null,\n  \"consumers\": 1,\n  \"deliveries\": [\n    \n  ],\n  \"durable\": true,\n  \"effective_policy_definition\": [\n    \n  ],\n  \"exclusive\": false,\n  \"exclusive_consumer_tag\": null,\n  \"garbage_collection\": {\n    \"fullsweep_after\": 65535,\n    \"max_heap_size\": 0,\n    \"min_bin_vheap_size\": 46422,\n    \"min_heap_size\": 233,\n    \"minor_gcs\": 294\n  },\n  \"head_message_timestamp\": null,\n  \"idle_since\": \"2019-05-29 7:34:01\",\n  \"incoming\": [\n    \n  ],\n  \"memory\": 18808,\n  \"message_bytes\": 0,\n  \"message_bytes_paged_out\": 0,\n  \"message_bytes_persistent\": 0,\n  \"message_bytes_ram\": 0,\n  \"message_bytes_ready\": 0,\n  \"message_bytes_unacknowledged\": 0,\n  \"message_stats\": {\n    \"ack\": 2007,\n    \"ack_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver\": 2181,\n    \"deliver_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver_get\": 2181,\n    \"deliver_get_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver_no_ack\": 0,\n    \"deliver_no_ack_details\": {\n      \"rate\": 0.0\n    },\n    \"get\": 0,\n    \"get_details\": {\n      \"rate\": 0.0\n    },\n    \"get_no_ack\": 0,\n    \"get_no_ack_details\": {\n      \"rate\": 0.0\n    },\n    \"publish\": 2177,\n    \"publish_details\": {\n      \"rate\": 0.0\n    },\n    \"redeliver\": 4,\n    \"redeliver_details\": {\n      \"rate\": 0.0\n    }\n  },\n  \"messages\": 0,\n  \"messages_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_paged_out\": 0,\n  \"messages_persistent\": 0,\n  \"messages_ram\": 0,\n  \"messages_ready\": 0, //消息未消费\n  \"messages_ready_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_ready_ram\": 0,\n  \"messages_unacknowledged\": 0, //正在消费\n  \"messages_unacknowledged_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_unacknowledged_ram\": 0,\n  \"name\": \"soaSyncPwdQueue\",\n  \"node\": \"rabbit@CNQLS03247\",\n  \"operator_policy\": null,\n  \"policy\": null,\n  \"recoverable_slaves\": null,\n  \"reductions\": 23652972,\n  \"reductions_details\": {\n    \"rate\": 0.0\n  },\n  \"state\": \"running\",\n  \"vhost\": \"/\"\n}\n```\n\n注意：\n虚拟主机名Virtual host在设置的时候不要带/，不然会访问不到\n```\n{\"error\":\"Object Not Found\",\"reason\":\"\\\"Not Found\\\"\\n\"}\n```\n之前就是被这个坑了好久，明明按照API写的格式来的，就是访问不到。\njava代码：\n```\njdk 1.8\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String host = \"\";\n        String port = \"\";\n        String virtualHost = \"\";\n        String queueName = \"\";\n        // 发送一个GET请求\n        HttpURLConnection httpConn = null;\n        BufferedReader in = null;\n\n        String urlString = \"http://\" + host + \":\" + port + \"/api/queues/\" + virtualHost + \"/\" + queueName;\n        // urlString = \"http://\" + host + \":\" + port + \"/api/queues/\";\n        URL url = new URL(urlString);\n        httpConn = (HttpURLConnection) url.openConnection();\n        // 设置用户名密码\n        String user=\"\";\n        String password=\"\";\n        String auth = user + \":\" + password;\n\n        String encoding = new String(Base64.getEncoder().encode(auth.getBytes()));\n        httpConn.setDoOutput(true);\n        httpConn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        // 建立实际的连接\n        httpConn.connect();\n        // 读取响应\n        if (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            StringBuilder content = new StringBuilder();\n            String tempStr = \"\";\n            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));\n            while ((tempStr = in.readLine()) != null) {\n                content.append(tempStr);\n            }\n            in.close();\n            httpConn.disconnect();\n            System.out.println(content.toString());\n        } else {\n            System.out.println(httpConn.getResponseCode());\n            httpConn.disconnect();\n        }\n    }\n}\n\n```","source":"_posts/rabbitmq-队列信息.md","raw":"title: 查询rabbitmq 队列信息\nauthor: wen\ntags:\n  - rabbitMq\n  - spring cloud\ncategories:\n  - spring cloud\ndate: 2019-05-29 16:48:00\n---\n最近需要做mq 消息预警，消息一旦堆积某个数量就报警。\n\nRabbitMQ自己就提供了HTTP API手册，比如我本地的API手册地址为：http://localhost:15672/api\n\nhttp://localhost:15672/api/queues/%2F/soaSyncPwdQueue\n可以看到队列相关的所有信息都有记录。\n```\n{\n  \"consumer_details\": [\n    {\n      \"arguments\": {\n        \n      },\n      \"channel_details\": {\n        \"connection_name\": \"10.143.172.86:35833 -> 10.210.93.176:5672\",\n        \"name\": \"10.143.172.86:35833 -> 10.210.93.176:5672 (1)\",\n        \"node\": \"rabbit@CNQLS03247\",\n        \"number\": 1,\n        \"peer_host\": \"10.143.172.86\",\n        \"peer_port\": 35833,\n        \"user\": \"logincenter\"\n      },\n      \"ack_required\": true,\n      \"consumer_tag\": \"amq.ctag-Gvgmd8yxscKvBkBiGp3J3g\",\n      \"exclusive\": false,\n      \"prefetch_count\": 0,\n      \"queue\": {\n        \"name\": \"soaSyncPwdQueue\",\n        \"vhost\": \"/\"\n      }\n    }\n  ],\n  \"arguments\": {\n    \"x-dead-letter-exchange\": \"\",\n    \"x-dead-letter-routing-key\": \"DL_soaSyncPwdQueue\"\n  },\n  \"auto_delete\": false,\n  \"backing_queue_status\": {\n    \"avg_ack_egress_rate\": 0.00021645676867156752,\n    \"avg_ack_ingress_rate\": 0.00021645676867156752,\n    \"avg_egress_rate\": 0.00021645676867156752,\n    \"avg_ingress_rate\": 0.00021645676867156752,\n    \"delta\": [\n      \"delta\",\n      \"undefined\",\n      0,\n      0,\n      \"undefined\"\n    ],\n    \"len\": 0,\n    \"mode\": \"default\",\n    \"next_seq_id\": 2177,\n    \"q1\": 0,\n    \"q2\": 0,\n    \"q3\": 0,\n    \"q4\": 0,\n    \"target_ram_count\": \"infinity\"\n  },\n  \"consumer_utilisation\": null,\n  \"consumers\": 1,\n  \"deliveries\": [\n    \n  ],\n  \"durable\": true,\n  \"effective_policy_definition\": [\n    \n  ],\n  \"exclusive\": false,\n  \"exclusive_consumer_tag\": null,\n  \"garbage_collection\": {\n    \"fullsweep_after\": 65535,\n    \"max_heap_size\": 0,\n    \"min_bin_vheap_size\": 46422,\n    \"min_heap_size\": 233,\n    \"minor_gcs\": 294\n  },\n  \"head_message_timestamp\": null,\n  \"idle_since\": \"2019-05-29 7:34:01\",\n  \"incoming\": [\n    \n  ],\n  \"memory\": 18808,\n  \"message_bytes\": 0,\n  \"message_bytes_paged_out\": 0,\n  \"message_bytes_persistent\": 0,\n  \"message_bytes_ram\": 0,\n  \"message_bytes_ready\": 0,\n  \"message_bytes_unacknowledged\": 0,\n  \"message_stats\": {\n    \"ack\": 2007,\n    \"ack_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver\": 2181,\n    \"deliver_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver_get\": 2181,\n    \"deliver_get_details\": {\n      \"rate\": 0.0\n    },\n    \"deliver_no_ack\": 0,\n    \"deliver_no_ack_details\": {\n      \"rate\": 0.0\n    },\n    \"get\": 0,\n    \"get_details\": {\n      \"rate\": 0.0\n    },\n    \"get_no_ack\": 0,\n    \"get_no_ack_details\": {\n      \"rate\": 0.0\n    },\n    \"publish\": 2177,\n    \"publish_details\": {\n      \"rate\": 0.0\n    },\n    \"redeliver\": 4,\n    \"redeliver_details\": {\n      \"rate\": 0.0\n    }\n  },\n  \"messages\": 0,\n  \"messages_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_paged_out\": 0,\n  \"messages_persistent\": 0,\n  \"messages_ram\": 0,\n  \"messages_ready\": 0, //消息未消费\n  \"messages_ready_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_ready_ram\": 0,\n  \"messages_unacknowledged\": 0, //正在消费\n  \"messages_unacknowledged_details\": {\n    \"rate\": 0.0\n  },\n  \"messages_unacknowledged_ram\": 0,\n  \"name\": \"soaSyncPwdQueue\",\n  \"node\": \"rabbit@CNQLS03247\",\n  \"operator_policy\": null,\n  \"policy\": null,\n  \"recoverable_slaves\": null,\n  \"reductions\": 23652972,\n  \"reductions_details\": {\n    \"rate\": 0.0\n  },\n  \"state\": \"running\",\n  \"vhost\": \"/\"\n}\n```\n\n注意：\n虚拟主机名Virtual host在设置的时候不要带/，不然会访问不到\n```\n{\"error\":\"Object Not Found\",\"reason\":\"\\\"Not Found\\\"\\n\"}\n```\n之前就是被这个坑了好久，明明按照API写的格式来的，就是访问不到。\njava代码：\n```\njdk 1.8\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String host = \"\";\n        String port = \"\";\n        String virtualHost = \"\";\n        String queueName = \"\";\n        // 发送一个GET请求\n        HttpURLConnection httpConn = null;\n        BufferedReader in = null;\n\n        String urlString = \"http://\" + host + \":\" + port + \"/api/queues/\" + virtualHost + \"/\" + queueName;\n        // urlString = \"http://\" + host + \":\" + port + \"/api/queues/\";\n        URL url = new URL(urlString);\n        httpConn = (HttpURLConnection) url.openConnection();\n        // 设置用户名密码\n        String user=\"\";\n        String password=\"\";\n        String auth = user + \":\" + password;\n\n        String encoding = new String(Base64.getEncoder().encode(auth.getBytes()));\n        httpConn.setDoOutput(true);\n        httpConn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        // 建立实际的连接\n        httpConn.connect();\n        // 读取响应\n        if (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            StringBuilder content = new StringBuilder();\n            String tempStr = \"\";\n            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));\n            while ((tempStr = in.readLine()) != null) {\n                content.append(tempStr);\n            }\n            in.close();\n            httpConn.disconnect();\n            System.out.println(content.toString());\n        } else {\n            System.out.println(httpConn.getResponseCode());\n            httpConn.disconnect();\n        }\n    }\n}\n\n```","slug":"rabbitmq-队列信息","published":1,"updated":"2019-06-09T15:13:13.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce389001fn6zq0e272fq5","content":"<p>最近需要做mq 消息预警，消息一旦堆积某个数量就报警。</p>\n<p>RabbitMQ自己就提供了HTTP API手册，比如我本地的API手册地址为：<a href=\"http://localhost:15672/api\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/api</a></p>\n<p><a href=\"http://localhost:15672/api/queues/%2F/soaSyncPwdQueue\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/api/queues/%2F/soaSyncPwdQueue</a><br>可以看到队列相关的所有信息都有记录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;consumer_details&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;arguments&quot;: &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;channel_details&quot;: &#123;</span><br><span class=\"line\">        &quot;connection_name&quot;: &quot;10.143.172.86:35833 -&gt; 10.210.93.176:5672&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;10.143.172.86:35833 -&gt; 10.210.93.176:5672 (1)&quot;,</span><br><span class=\"line\">        &quot;node&quot;: &quot;rabbit@CNQLS03247&quot;,</span><br><span class=\"line\">        &quot;number&quot;: 1,</span><br><span class=\"line\">        &quot;peer_host&quot;: &quot;10.143.172.86&quot;,</span><br><span class=\"line\">        &quot;peer_port&quot;: 35833,</span><br><span class=\"line\">        &quot;user&quot;: &quot;logincenter&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;ack_required&quot;: true,</span><br><span class=\"line\">      &quot;consumer_tag&quot;: &quot;amq.ctag-Gvgmd8yxscKvBkBiGp3J3g&quot;,</span><br><span class=\"line\">      &quot;exclusive&quot;: false,</span><br><span class=\"line\">      &quot;prefetch_count&quot;: 0,</span><br><span class=\"line\">      &quot;queue&quot;: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;soaSyncPwdQueue&quot;,</span><br><span class=\"line\">        &quot;vhost&quot;: &quot;/&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;arguments&quot;: &#123;</span><br><span class=\"line\">    &quot;x-dead-letter-exchange&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;x-dead-letter-routing-key&quot;: &quot;DL_soaSyncPwdQueue&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;auto_delete&quot;: false,</span><br><span class=\"line\">  &quot;backing_queue_status&quot;: &#123;</span><br><span class=\"line\">    &quot;avg_ack_egress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_ack_ingress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_egress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_ingress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;delta&quot;: [</span><br><span class=\"line\">      &quot;delta&quot;,</span><br><span class=\"line\">      &quot;undefined&quot;,</span><br><span class=\"line\">      0,</span><br><span class=\"line\">      0,</span><br><span class=\"line\">      &quot;undefined&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;len&quot;: 0,</span><br><span class=\"line\">    &quot;mode&quot;: &quot;default&quot;,</span><br><span class=\"line\">    &quot;next_seq_id&quot;: 2177,</span><br><span class=\"line\">    &quot;q1&quot;: 0,</span><br><span class=\"line\">    &quot;q2&quot;: 0,</span><br><span class=\"line\">    &quot;q3&quot;: 0,</span><br><span class=\"line\">    &quot;q4&quot;: 0,</span><br><span class=\"line\">    &quot;target_ram_count&quot;: &quot;infinity&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;consumer_utilisation&quot;: null,</span><br><span class=\"line\">  &quot;consumers&quot;: 1,</span><br><span class=\"line\">  &quot;deliveries&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;durable&quot;: true,</span><br><span class=\"line\">  &quot;effective_policy_definition&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;exclusive&quot;: false,</span><br><span class=\"line\">  &quot;exclusive_consumer_tag&quot;: null,</span><br><span class=\"line\">  &quot;garbage_collection&quot;: &#123;</span><br><span class=\"line\">    &quot;fullsweep_after&quot;: 65535,</span><br><span class=\"line\">    &quot;max_heap_size&quot;: 0,</span><br><span class=\"line\">    &quot;min_bin_vheap_size&quot;: 46422,</span><br><span class=\"line\">    &quot;min_heap_size&quot;: 233,</span><br><span class=\"line\">    &quot;minor_gcs&quot;: 294</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;head_message_timestamp&quot;: null,</span><br><span class=\"line\">  &quot;idle_since&quot;: &quot;2019-05-29 7:34:01&quot;,</span><br><span class=\"line\">  &quot;incoming&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;memory&quot;: 18808,</span><br><span class=\"line\">  &quot;message_bytes&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_paged_out&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_persistent&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_ram&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_ready&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_unacknowledged&quot;: 0,</span><br><span class=\"line\">  &quot;message_stats&quot;: &#123;</span><br><span class=\"line\">    &quot;ack&quot;: 2007,</span><br><span class=\"line\">    &quot;ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver&quot;: 2181,</span><br><span class=\"line\">    &quot;deliver_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver_get&quot;: 2181,</span><br><span class=\"line\">    &quot;deliver_get_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver_no_ack&quot;: 0,</span><br><span class=\"line\">    &quot;deliver_no_ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;get&quot;: 0,</span><br><span class=\"line\">    &quot;get_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;get_no_ack&quot;: 0,</span><br><span class=\"line\">    &quot;get_no_ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;publish&quot;: 2177,</span><br><span class=\"line\">    &quot;publish_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;redeliver&quot;: 4,</span><br><span class=\"line\">    &quot;redeliver_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages&quot;: 0,</span><br><span class=\"line\">  &quot;messages_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_paged_out&quot;: 0,</span><br><span class=\"line\">  &quot;messages_persistent&quot;: 0,</span><br><span class=\"line\">  &quot;messages_ram&quot;: 0,</span><br><span class=\"line\">  &quot;messages_ready&quot;: 0, //消息未消费</span><br><span class=\"line\">  &quot;messages_ready_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_ready_ram&quot;: 0,</span><br><span class=\"line\">  &quot;messages_unacknowledged&quot;: 0, //正在消费</span><br><span class=\"line\">  &quot;messages_unacknowledged_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_unacknowledged_ram&quot;: 0,</span><br><span class=\"line\">  &quot;name&quot;: &quot;soaSyncPwdQueue&quot;,</span><br><span class=\"line\">  &quot;node&quot;: &quot;rabbit@CNQLS03247&quot;,</span><br><span class=\"line\">  &quot;operator_policy&quot;: null,</span><br><span class=\"line\">  &quot;policy&quot;: null,</span><br><span class=\"line\">  &quot;recoverable_slaves&quot;: null,</span><br><span class=\"line\">  &quot;reductions&quot;: 23652972,</span><br><span class=\"line\">  &quot;reductions_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;state&quot;: &quot;running&quot;,</span><br><span class=\"line\">  &quot;vhost&quot;: &quot;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>虚拟主机名Virtual host在设置的时候不要带/，不然会访问不到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;error&quot;:&quot;Object Not Found&quot;,&quot;reason&quot;:&quot;\\&quot;Not Found\\&quot;\\n&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之前就是被这个坑了好久，明明按照API写的格式来的，就是访问不到。<br>java代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdk 1.8</span><br><span class=\"line\">import java.io.BufferedReader;</span><br><span class=\"line\">import java.io.InputStreamReader;</span><br><span class=\"line\">import java.net.HttpURLConnection;</span><br><span class=\"line\">import java.net.URL;</span><br><span class=\"line\">import java.util.Base64;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        String host = &quot;&quot;;</span><br><span class=\"line\">        String port = &quot;&quot;;</span><br><span class=\"line\">        String virtualHost = &quot;&quot;;</span><br><span class=\"line\">        String queueName = &quot;&quot;;</span><br><span class=\"line\">        // 发送一个GET请求</span><br><span class=\"line\">        HttpURLConnection httpConn = null;</span><br><span class=\"line\">        BufferedReader in = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        String urlString = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/api/queues/&quot; + virtualHost + &quot;/&quot; + queueName;</span><br><span class=\"line\">        // urlString = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/api/queues/&quot;;</span><br><span class=\"line\">        URL url = new URL(urlString);</span><br><span class=\"line\">        httpConn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">        // 设置用户名密码</span><br><span class=\"line\">        String user=&quot;&quot;;</span><br><span class=\"line\">        String password=&quot;&quot;;</span><br><span class=\"line\">        String auth = user + &quot;:&quot; + password;</span><br><span class=\"line\"></span><br><span class=\"line\">        String encoding = new String(Base64.getEncoder().encode(auth.getBytes()));</span><br><span class=\"line\">        httpConn.setDoOutput(true);</span><br><span class=\"line\">        httpConn.setRequestProperty(&quot;Authorization&quot;, &quot;Basic &quot; + encoding);</span><br><span class=\"line\">        // 建立实际的连接</span><br><span class=\"line\">        httpConn.connect();</span><br><span class=\"line\">        // 读取响应</span><br><span class=\"line\">        if (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;</span><br><span class=\"line\">            StringBuilder content = new StringBuilder();</span><br><span class=\"line\">            String tempStr = &quot;&quot;;</span><br><span class=\"line\">            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));</span><br><span class=\"line\">            while ((tempStr = in.readLine()) != null) &#123;</span><br><span class=\"line\">                content.append(tempStr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            httpConn.disconnect();</span><br><span class=\"line\">            System.out.println(content.toString());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(httpConn.getResponseCode());</span><br><span class=\"line\">            httpConn.disconnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近需要做mq 消息预警，消息一旦堆积某个数量就报警。</p>\n<p>RabbitMQ自己就提供了HTTP API手册，比如我本地的API手册地址为：<a href=\"http://localhost:15672/api\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/api</a></p>\n<p><a href=\"http://localhost:15672/api/queues/%2F/soaSyncPwdQueue\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/api/queues/%2F/soaSyncPwdQueue</a><br>可以看到队列相关的所有信息都有记录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;consumer_details&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;arguments&quot;: &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;channel_details&quot;: &#123;</span><br><span class=\"line\">        &quot;connection_name&quot;: &quot;10.143.172.86:35833 -&gt; 10.210.93.176:5672&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;10.143.172.86:35833 -&gt; 10.210.93.176:5672 (1)&quot;,</span><br><span class=\"line\">        &quot;node&quot;: &quot;rabbit@CNQLS03247&quot;,</span><br><span class=\"line\">        &quot;number&quot;: 1,</span><br><span class=\"line\">        &quot;peer_host&quot;: &quot;10.143.172.86&quot;,</span><br><span class=\"line\">        &quot;peer_port&quot;: 35833,</span><br><span class=\"line\">        &quot;user&quot;: &quot;logincenter&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;ack_required&quot;: true,</span><br><span class=\"line\">      &quot;consumer_tag&quot;: &quot;amq.ctag-Gvgmd8yxscKvBkBiGp3J3g&quot;,</span><br><span class=\"line\">      &quot;exclusive&quot;: false,</span><br><span class=\"line\">      &quot;prefetch_count&quot;: 0,</span><br><span class=\"line\">      &quot;queue&quot;: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;soaSyncPwdQueue&quot;,</span><br><span class=\"line\">        &quot;vhost&quot;: &quot;/&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;arguments&quot;: &#123;</span><br><span class=\"line\">    &quot;x-dead-letter-exchange&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;x-dead-letter-routing-key&quot;: &quot;DL_soaSyncPwdQueue&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;auto_delete&quot;: false,</span><br><span class=\"line\">  &quot;backing_queue_status&quot;: &#123;</span><br><span class=\"line\">    &quot;avg_ack_egress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_ack_ingress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_egress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;avg_ingress_rate&quot;: 0.00021645676867156752,</span><br><span class=\"line\">    &quot;delta&quot;: [</span><br><span class=\"line\">      &quot;delta&quot;,</span><br><span class=\"line\">      &quot;undefined&quot;,</span><br><span class=\"line\">      0,</span><br><span class=\"line\">      0,</span><br><span class=\"line\">      &quot;undefined&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;len&quot;: 0,</span><br><span class=\"line\">    &quot;mode&quot;: &quot;default&quot;,</span><br><span class=\"line\">    &quot;next_seq_id&quot;: 2177,</span><br><span class=\"line\">    &quot;q1&quot;: 0,</span><br><span class=\"line\">    &quot;q2&quot;: 0,</span><br><span class=\"line\">    &quot;q3&quot;: 0,</span><br><span class=\"line\">    &quot;q4&quot;: 0,</span><br><span class=\"line\">    &quot;target_ram_count&quot;: &quot;infinity&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;consumer_utilisation&quot;: null,</span><br><span class=\"line\">  &quot;consumers&quot;: 1,</span><br><span class=\"line\">  &quot;deliveries&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;durable&quot;: true,</span><br><span class=\"line\">  &quot;effective_policy_definition&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;exclusive&quot;: false,</span><br><span class=\"line\">  &quot;exclusive_consumer_tag&quot;: null,</span><br><span class=\"line\">  &quot;garbage_collection&quot;: &#123;</span><br><span class=\"line\">    &quot;fullsweep_after&quot;: 65535,</span><br><span class=\"line\">    &quot;max_heap_size&quot;: 0,</span><br><span class=\"line\">    &quot;min_bin_vheap_size&quot;: 46422,</span><br><span class=\"line\">    &quot;min_heap_size&quot;: 233,</span><br><span class=\"line\">    &quot;minor_gcs&quot;: 294</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;head_message_timestamp&quot;: null,</span><br><span class=\"line\">  &quot;idle_since&quot;: &quot;2019-05-29 7:34:01&quot;,</span><br><span class=\"line\">  &quot;incoming&quot;: [</span><br><span class=\"line\">    </span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;memory&quot;: 18808,</span><br><span class=\"line\">  &quot;message_bytes&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_paged_out&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_persistent&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_ram&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_ready&quot;: 0,</span><br><span class=\"line\">  &quot;message_bytes_unacknowledged&quot;: 0,</span><br><span class=\"line\">  &quot;message_stats&quot;: &#123;</span><br><span class=\"line\">    &quot;ack&quot;: 2007,</span><br><span class=\"line\">    &quot;ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver&quot;: 2181,</span><br><span class=\"line\">    &quot;deliver_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver_get&quot;: 2181,</span><br><span class=\"line\">    &quot;deliver_get_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;deliver_no_ack&quot;: 0,</span><br><span class=\"line\">    &quot;deliver_no_ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;get&quot;: 0,</span><br><span class=\"line\">    &quot;get_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;get_no_ack&quot;: 0,</span><br><span class=\"line\">    &quot;get_no_ack_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;publish&quot;: 2177,</span><br><span class=\"line\">    &quot;publish_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;redeliver&quot;: 4,</span><br><span class=\"line\">    &quot;redeliver_details&quot;: &#123;</span><br><span class=\"line\">      &quot;rate&quot;: 0.0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages&quot;: 0,</span><br><span class=\"line\">  &quot;messages_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_paged_out&quot;: 0,</span><br><span class=\"line\">  &quot;messages_persistent&quot;: 0,</span><br><span class=\"line\">  &quot;messages_ram&quot;: 0,</span><br><span class=\"line\">  &quot;messages_ready&quot;: 0, //消息未消费</span><br><span class=\"line\">  &quot;messages_ready_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_ready_ram&quot;: 0,</span><br><span class=\"line\">  &quot;messages_unacknowledged&quot;: 0, //正在消费</span><br><span class=\"line\">  &quot;messages_unacknowledged_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;messages_unacknowledged_ram&quot;: 0,</span><br><span class=\"line\">  &quot;name&quot;: &quot;soaSyncPwdQueue&quot;,</span><br><span class=\"line\">  &quot;node&quot;: &quot;rabbit@CNQLS03247&quot;,</span><br><span class=\"line\">  &quot;operator_policy&quot;: null,</span><br><span class=\"line\">  &quot;policy&quot;: null,</span><br><span class=\"line\">  &quot;recoverable_slaves&quot;: null,</span><br><span class=\"line\">  &quot;reductions&quot;: 23652972,</span><br><span class=\"line\">  &quot;reductions_details&quot;: &#123;</span><br><span class=\"line\">    &quot;rate&quot;: 0.0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;state&quot;: &quot;running&quot;,</span><br><span class=\"line\">  &quot;vhost&quot;: &quot;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>虚拟主机名Virtual host在设置的时候不要带/，不然会访问不到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;error&quot;:&quot;Object Not Found&quot;,&quot;reason&quot;:&quot;\\&quot;Not Found\\&quot;\\n&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之前就是被这个坑了好久，明明按照API写的格式来的，就是访问不到。<br>java代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdk 1.8</span><br><span class=\"line\">import java.io.BufferedReader;</span><br><span class=\"line\">import java.io.InputStreamReader;</span><br><span class=\"line\">import java.net.HttpURLConnection;</span><br><span class=\"line\">import java.net.URL;</span><br><span class=\"line\">import java.util.Base64;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        String host = &quot;&quot;;</span><br><span class=\"line\">        String port = &quot;&quot;;</span><br><span class=\"line\">        String virtualHost = &quot;&quot;;</span><br><span class=\"line\">        String queueName = &quot;&quot;;</span><br><span class=\"line\">        // 发送一个GET请求</span><br><span class=\"line\">        HttpURLConnection httpConn = null;</span><br><span class=\"line\">        BufferedReader in = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        String urlString = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/api/queues/&quot; + virtualHost + &quot;/&quot; + queueName;</span><br><span class=\"line\">        // urlString = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/api/queues/&quot;;</span><br><span class=\"line\">        URL url = new URL(urlString);</span><br><span class=\"line\">        httpConn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">        // 设置用户名密码</span><br><span class=\"line\">        String user=&quot;&quot;;</span><br><span class=\"line\">        String password=&quot;&quot;;</span><br><span class=\"line\">        String auth = user + &quot;:&quot; + password;</span><br><span class=\"line\"></span><br><span class=\"line\">        String encoding = new String(Base64.getEncoder().encode(auth.getBytes()));</span><br><span class=\"line\">        httpConn.setDoOutput(true);</span><br><span class=\"line\">        httpConn.setRequestProperty(&quot;Authorization&quot;, &quot;Basic &quot; + encoding);</span><br><span class=\"line\">        // 建立实际的连接</span><br><span class=\"line\">        httpConn.connect();</span><br><span class=\"line\">        // 读取响应</span><br><span class=\"line\">        if (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;</span><br><span class=\"line\">            StringBuilder content = new StringBuilder();</span><br><span class=\"line\">            String tempStr = &quot;&quot;;</span><br><span class=\"line\">            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));</span><br><span class=\"line\">            while ((tempStr = in.readLine()) != null) &#123;</span><br><span class=\"line\">                content.append(tempStr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            httpConn.disconnect();</span><br><span class=\"line\">            System.out.println(content.toString());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(httpConn.getResponseCode());</span><br><span class=\"line\">            httpConn.disconnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"spring cloud+docker+git+maven+jenkins+Kubernetes 目录","author":"wen","date":"2018-05-08T09:45:58.000Z","_content":"图：\n![logo](ring-cloud-docker-git-maven-jenkins-Kubernetes-目录/11278290-faac5fbb39c76314.png)","source":"_posts/ring-cloud-docker-git-maven-jenkins-Kubernetes-目录.md","raw":"title: spring cloud+docker+git+maven+jenkins+Kubernetes 目录\nauthor: wen\ndate: 2018-05-08 17:45:58\ntags:\n---\n图：\n![logo](ring-cloud-docker-git-maven-jenkins-Kubernetes-目录/11278290-faac5fbb39c76314.png)","slug":"ring-cloud-docker-git-maven-jenkins-Kubernetes-目录","published":1,"updated":"2019-05-05T02:41:23.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38c001hn6zqpe900wbb","content":"<p>图：<br><img src=\"/2018/05/08/ring-cloud-docker-git-maven-jenkins-Kubernetes-目录/11278290-faac5fbb39c76314.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>图：<br><img src=\"/2018/05/08/ring-cloud-docker-git-maven-jenkins-Kubernetes-目录/11278290-faac5fbb39c76314.png\" alt=\"logo\"></p>\n"},{"title":"SpringSession源码（二）","author":"wen","date":"2019-11-22T07:25:00.000Z","_content":"[如何使用spring session](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)\n上一篇文章中介绍了Spring-Session的核心原理，Filter，Session，Repository等等，传送门：[SpringSession源码](https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/)\n\n这篇继上一篇的原理逐渐深入Spring-Session中的事件机制原理的探索。众所周知，Servlet规范中有对HttpSession的事件的处理，如：HttpSessionEvent/HttpSessionIdListener/HttpSessionListener，可以查看Package javax.servlet\n\n在Spring-Session中也有相应的Session事件机制实现，包括Session创建/过期/删除事件。\n本文主要从以下方面探索Spring-Session中事件机制\n\n* Session事件的抽象\n* 事件的触发机制\n# Session事件的抽象\n先来看下Session事件抽象UML类图，整体掌握事件之间的依赖关系。\n![Session事件的抽象](pringSession源码（二）/1.png)\nSession Event最顶层是ApplicationEvent，即Spring上下文事件对象。由此可以看出Spring-Session的事件机制是基于Spring上下文事件实现。\n\n抽象的AbstractSessionEvent事件对象提供了获取Session（这里的是指Spring Session的对象）和SessionId。   \n\n基于事件的类型，分类为：\n* Session创建事件\n* Session删除事件\n* Session过期事件\n事件对象只是对事件本身的抽象，描述事件的属性，如：\n\n获取事件产生的源：getSource获取事件产生源\n获取相应事件特性：getSession/getSessoinId获取时间关联的Session\n下面再深入探索以上的Session事件是如何触发，从事件源到事件监听器的链路分析事件流转过程。\n# 二.事件的触发机制\n\n\n介绍Session Event事件基于Spring的ApplicationEvent实现。先简单认识spring上下文事件机制：\n![Session事件的抽象](pringSession源码（二）/2.png)\n\n* ApplicationEventPublisher实现用于发布Spring上下文事件ApplicationEvent\n* ApplicationListener实现用于监听Spring上下文事件ApplicationEvent\n* ApplicationEvent抽象上下文事件\n\n那么在Spring-Session中必然包含事件发布者ApplicationEventPublisher发布Session事件和ApplicationListener监听Session事件。\n\n可以看出ApplicationEventPublisher发布一个事件：\n```\n@FunctionalInterface\npublic interface ApplicationEventPublisher {\n\n    /**\n     * Notify all <strong>matching</strong> listeners registered with this\n     * application of an application event. Events may be framework events\n     * (such as RequestHandledEvent) or application-specific events.\n     * @param event the event to publish\n     * @see org.springframework.web.context.support.RequestHandledEvent\n     */\n    default void publishEvent(ApplicationEvent event) {\n        publishEvent((Object) event);\n    }\n\n    /**\n     * Notify all <strong>matching</strong> listeners registered with this\n     * application of an event.\n     * <p>If the specified {@code event} is not an {@link ApplicationEvent},\n     * it is wrapped in a {@link PayloadApplicationEvent}.\n     * @param event the event to publish\n     * @since 4.2\n     * @see PayloadApplicationEvent\n     */\n    void publishEvent(Object event);\n\n}\n```\nApplicationListener用于监听相应的事件：\n```\n@FunctionalInterface\npublic interface ApplicationListener<E extends ApplicationEvent> extends EventListener {\n\n    /**\n     * Handle an application event.\n     * @param event the event to respond to\n     */\n    void onApplicationEvent(E event);\n\n}\n```\nSession事件的流程实现如下：\n![Session事件的抽象](pringSession源码（二）/3.png)\nRedisMessageListenerContainer初始化时会启动一个线程SubscriptionTask进行订阅redis信息\n\n上图展示了Spring-Session事件流程图，事件源来自于Redis键空间通知，在spring-data-redis项目中抽象MessageListener监听Redis事件源，然后将其传播至spring应用上下文发布者，由发布者发布事件。在spring上下文中的监听器Listener即可监听到Session事件。\n\n因为两者是Spring框架提供的对Spring的ApplicationEvent的支持。Session Event基于ApplicationEvent实现，必然也有其相应发布者和监听器的的实现。\n\nSpring-Session中的RedisSession的SessionRepository是RedisOperationSessionRepository。所有关于RedisSession的管理操作都是由其实现，所以Session的产生源是RedisOperationSessionRepository。\n\n在RedisOperationSessionRepository中持有ApplicationEventPublisher对象用于发布Session事件。\n```\nprivate ApplicationEventPublisher eventPublisher = new ApplicationEventPublisher() {\n    @Override\n    public void publishEvent(ApplicationEvent event) {\n    }\n    @Override\n    public void publishEvent(Object event) {\n    }\n};\n```\n但是该ApplicationEventPublisher是空实现，实际实现是在应用启动时由Spring-Session自动配置。在spring-session-data-redis模块中RedisHttpSessionConfiguration中有关于创建RedisOperationSessionRepository Bean时将调用set方法将ApplicationEventPublisher配置。\n```\n@Configuration\n@EnableScheduling\npublic class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration\n        implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware,\n        SchedulingConfigurer {\n\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Bean\n    public RedisOperationsSessionRepository sessionRepository() {\n        RedisTemplate<Object, Object> redisTemplate = createRedisTemplate();\n        RedisOperationsSessionRepository sessionRepository = new RedisOperationsSessionRepository(\n                redisTemplate);\n        // 注入依赖\n        sessionRepository.setApplicationEventPublisher(this.applicationEventPublisher);\n        if (this.defaultRedisSerializer != null) {\n            sessionRepository.setDefaultSerializer(this.defaultRedisSerializer);\n        }\n        sessionRepository\n                .setDefaultMaxInactiveInterval(this.maxInactiveIntervalInSeconds);\n        if (StringUtils.hasText(this.redisNamespace)) {\n            sessionRepository.setRedisKeyNamespace(this.redisNamespace);\n        }\n        sessionRepository.setRedisFlushMode(this.redisFlushMode);\n        return sessionRepository;\n    }\n\n    // 注入上下文中的ApplicationEventPublisher Bean\n    @Autowired\n    public void setApplicationEventPublisher(\n            ApplicationEventPublisher applicationEventPublisher) {\n        this.applicationEventPublisher = applicationEventPublisher;\n    }\n\n}\n```\n在进行自动配置时，将上下文中的ApplicationEventPublisher的注入，实际上即ApplicationContext对象。\n对于ApplicationListener是由应用开发者自行实现，注册成Bean即可。当有Session Event发布时，即可监听。\n```\n/**\n * session事件监听器\n *\n * @author huaijin\n */\n@Component\npublic class SessionEventListener implements ApplicationListener<SessionDeletedEvent> {\n\n    private static final String CURRENT_USER = \"currentUser\";\n\n    @Override\n    public void onApplicationEvent(SessionDeletedEvent event) {\n        Session session = event.getSession();\n        UserVo userVo = session.getAttribute(CURRENT_USER);\n        System.out.println(\"Current session's user:\" + userVo.toString());\n    }\n}\n```\n以上部分探索了Session事件的发布者和监听者，但是核心事件的触发发布则是由Redis的键空间通知机制触发，当有Session创建/删除/过期时，Redis键空间会通知Spring-Session应用。\n\nRedisOperationsSessionRepository实现spring-data-redis中的MessageListener接口。\n```\n/**\n * Listener of messages published in Redis.\n *\n * @author Costin Leau\n * @author Christoph Strobl\n */\npublic interface MessageListener {\n\n    /**\n     * Callback for processing received objects through Redis.\n     *\n     * @param message message must not be {@literal null}.\n     * @param pattern pattern matching the channel (if specified) - can be {@literal null}.\n     */\n    void onMessage(Message message, @Nullable byte[] pattern);\n}\n```\n该监听器即用来监听redis发布的消息。RedisOperationsSessionRepositorys实现了该Redis键空间消息通知监听器接口，实现如下：\n```\npublic class RedisOperationsSessionRepository implements\n        FindByIndexNameSessionRepository<RedisOperationsSessionRepository.RedisSession>,\n        MessageListener {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void onMessage(Message message, byte[] pattern) {\n        // 获取该消息发布的redis通道channel\n        byte[] messageChannel = message.getChannel();\n        // 获取消息体内容\n        byte[] messageBody = message.getBody();\n\n        String channel = new String(messageChannel);\n\n        // 如果是由Session创建通道发布的消息，则是Session创建事件\n        if (channel.startsWith(getSessionCreatedChannelPrefix())) {\n            // 从消息体中载入Session\n            Map<Object, Object> loaded = (Map<Object, Object>) this.defaultSerializer\n                    .deserialize(message.getBody());\n            // 发布创建事件\n            handleCreated(loaded, channel);\n            return;\n        }\n\n        // 如果消息体不是以过期键前缀，直接返回。因为spring-session在redis中的key命名规则：\n        // \"${namespace}:sessions:expires:${sessionId}\"，如：\n        // session.example:sessions:expires:a5236a19-7325-4783-b1f0-db9d4442db9a\n        // 所以判断过期或者删除的键是否为spring-session的过期键。如果不是，可能是应用中其他的键的操作，所以直接return\n        String body = new String(messageBody);\n        if (!body.startsWith(getExpiredKeyPrefix())) {\n            return;\n        }\n\n        // 根据channel判断键空间的事件类型del或者expire时间\n        boolean isDeleted = channel.endsWith(\":del\");\n        if (isDeleted || channel.endsWith(\":expired\")) {\n            int beginIndex = body.lastIndexOf(\":\") + 1;\n            int endIndex = body.length();\n            // Redis键空间消息通知内容即操作的键，spring-session键中命名规则：\n            // \"${namespace}:sessions:expires:${sessionId}\"，以下是根据规则解析sessionId\n            String sessionId = body.substring(beginIndex, endIndex);\n\n            // 根据sessionId加载session\n            RedisSession session = getSession(sessionId, true);\n\n            if (session == null) {\n                logger.warn(\"Unable to publish SessionDestroyedEvent for session \"\n                        + sessionId);\n                return;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Publishing SessionDestroyedEvent for session \" + sessionId);\n            }\n\n            cleanupPrincipalIndex(session);\n\n            // 发布Session delete事件\n            if (isDeleted) {\n                handleDeleted(session);\n            }\n            else {\n                // 否则发布Session expire事件\n                handleExpired(session);\n            }\n        }\n    }\n}\n```\n下续再深入每种事件产生的前世今生。\n\n## Session创建事件的触发\n\n![Session事件的抽象](pringSession源码（二）/4.png)\n* 由RedisOperationSessionRepository向Redis指定通道${namespace}:event:created:${sessionId}发布一个message\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道${namespace}:event:created:${sessionId}的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionCreateEvent\n* ApplicationListener监听SessionCreateEvent，执行相应逻辑\n\nRedisOperationSessionRepository中保存一个Session时，判断Session是否新创建。\n如果新创建，则向\n```\n@Override\npublic void save(RedisSession session) {\n    session.saveDelta();\n    // 判断是否为新创建的session\n    if (session.isNew()) {\n        // 获取redis指定的channel：${namespace}:event:created:${sessionId}，\n        // 如：session.example:event:created:82sdd-4123-o244-ps123\n        String sessionCreatedKey = getSessionCreatedChannel(session.getId());\n        // 向该通道发布session数据\n        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);\n        // 设置session为非新创建\n        session.setNew(false);\n    }\n}\n```\n该save方法的调用是由HttpServletResponse提交时——即返回客户端响应调用，上篇文章已经详解，这里不再赘述。关于RedisOperationSessionRepository实现MessageListener上述已经介绍，这里同样不再赘述。\n## Session删除事件的触发\n删除事件中使用到了Redis KeySpace Notification，建议先了解该技术。\n\n![Session事件的抽象](pringSession源码（二）/5.png)\n* 由RedisOperationSessionRepository删除Redis键空间中的指定Session的过期键，Redis键空间会向**__keyevent@*:del**的channel发布删除事件消息\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道**__keyevent@*:del**的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionDeleteEvent\n* ApplicationListener监听SessionDeleteEvent，执行相应逻辑\n当调用HttpSession的invalidate方法让Session失效时，即会调用RedisOperationSessionRepository的deleteById方法删除Session的过期键。\n```\n/**\n * Allows creating an HttpSession from a Session instance.\n *\n * @author Rob Winch\n * @since 1.0\n */\nprivate final class HttpSessionWrapper extends HttpSessionAdapter<S> {\n    HttpSessionWrapper(S session, ServletContext servletContext) {\n        super(session, servletContext);\n    }\n\n    @Override\n    public void invalidate() {\n        super.invalidate();\n        SessionRepositoryRequestWrapper.this.requestedSessionInvalidated = true;\n        setCurrentSession(null);\n        clearRequestedSessionCache();\n        // 调用删除方法\n        SessionRepositoryFilter.this.sessionRepository.deleteById(getId());\n    }\n}\n```\n上篇中介绍了包装Spring Session为HttpSession，这里不再赘述。这里重点分析deleteById内容：\n```\n@Override\npublic void deleteById(String sessionId) {\n    // 如果session为空则返回\n    RedisSession session = getSession(sessionId, true);\n    if (session == null) {\n        return;\n    }\n\n    cleanupPrincipalIndex(session);\n    this.expirationPolicy.onDelete(session);\n    // 获取session的过期键\n    String expireKey = getExpiredKey(session.getId());\n    // 删除过期键，redis键空间产生del事件消息，被MessageListener即\n    // RedisOperationSessionRepository监听\n    this.sessionRedisOperations.delete(expireKey);\n    session.setMaxInactiveInterval(Duration.ZERO);\n    save(session);\n}\n```\n后续流程同SessionCreateEvent流程。\n\n## Session失效事件的触发\nSession的过期事件流程比较特殊，因为Redis的键空间通知的特殊性，Redis键空间通知不能保证过期键的通知的及时性。\n![Session事件的抽象](pringSession源码（二）/6.png)\n* RedisOperationsSessionRepository中有个定时任务方法每整分运行访问整分Session过期键集合中的过期sessionId，如：spring:session:expirations:1439245080000。触发Redis键空间会向**__keyevent@*:expired**的channel发布过期事件消息\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道**__keyevent@*:expired**的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionDeleteEvent\n* ApplicationListener监听SessionDeleteEvent，执行相应逻辑\n\n```\n@Scheduled(cron = \"0 * * * * *\")\npublic void cleanupExpiredSessions() {\n    this.expirationPolicy.cleanExpiredSessions();\n}\n```\n定时任务每整分运行，执行cleanExpiredSessions方法。expirationPolicy是RedisSessionExpirationPolicy实例，是RedisSession过期策略。\n```\npublic void cleanExpiredSessions() {\n    // 获取当前时间戳\n    long now = System.currentTimeMillis();\n    // 时间滚动至整分，去掉秒和毫秒部分\n    long prevMin = roundDownMinute(now);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Cleaning up sessions expiring at \" + new Date(prevMin));\n    }\n    // 根据整分时间获取过期键集合，如：spring:session:expirations:1439245080000\n    String expirationKey = getExpirationKey(prevMin);\n    // 获取所有的所有的过期session\n    Set<Object> sessionsToExpire = this.redis.boundSetOps(expirationKey).members();\n    // 删除过期Session键集合\n    this.redis.delete(expirationKey);\n    // touch访问所有已经过期的session，触发Redis键空间通知消息\n    for (Object session : sessionsToExpire) {\n        String sessionKey = getSessionKey((String) session);\n        touch(sessionKey);\n    }\n}\n```\n将时间戳滚动至整分\n```\nstatic long roundDownMinute(long timeInMs) {\n    Calendar date = Calendar.getInstance();\n    date.setTimeInMillis(timeInMs);\n    // 清理时间错的秒位和毫秒位\n    date.clear(Calendar.SECOND);\n    date.clear(Calendar.MILLISECOND);\n    return date.getTimeInMillis();\n}\n```\n获取过期Session的集合\n```\nString getExpirationKey(long expires) {\n    return this.redisSession.getExpirationsKey(expires);\n}\n\n// 如：spring:session:expirations:1439245080000\nString getExpirationsKey(long expiration) {\n    return this.keyPrefix + \"expirations:\" + expiration;\n}\n```\n调用Redis的Exists命令，访问过期Session键，触发Redis键空间消息\n```\n/**\n * By trying to access the session we only trigger a deletion if it the TTL is\n * expired. This is done to handle\n * https://github.com/spring-projects/spring-session/issues/93\n *\n * @param key the key\n */\nprivate void touch(String key) {\n    this.redis.hasKey(key);\n}\n```\n总结\n至此Spring-Session的Session事件通知模块就已经很清晰：\n\n* Redis键空间Session事件源：Session创建通道/Session删除通道/Session过期通道\n* Spring-Session中的RedisOperationsSessionRepository消息监听器监听Redis的事件类型\n* RedisOperationsSessionRepository负责将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher将其包装成ApplicationEvent类型的Session Event发布\n* ApplicationListener监听Session Event，处理相应逻辑\n\n\n","source":"_posts/pringSession源码（二）.md","raw":"title: SpringSession源码（二）\nauthor: wen\ntags:\n  - springsession\ncategories:\n  - springsession\ndate: 2019-11-22 15:25:00\n---\n[如何使用spring session](https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/)\n上一篇文章中介绍了Spring-Session的核心原理，Filter，Session，Repository等等，传送门：[SpringSession源码](https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/)\n\n这篇继上一篇的原理逐渐深入Spring-Session中的事件机制原理的探索。众所周知，Servlet规范中有对HttpSession的事件的处理，如：HttpSessionEvent/HttpSessionIdListener/HttpSessionListener，可以查看Package javax.servlet\n\n在Spring-Session中也有相应的Session事件机制实现，包括Session创建/过期/删除事件。\n本文主要从以下方面探索Spring-Session中事件机制\n\n* Session事件的抽象\n* 事件的触发机制\n# Session事件的抽象\n先来看下Session事件抽象UML类图，整体掌握事件之间的依赖关系。\n![Session事件的抽象](pringSession源码（二）/1.png)\nSession Event最顶层是ApplicationEvent，即Spring上下文事件对象。由此可以看出Spring-Session的事件机制是基于Spring上下文事件实现。\n\n抽象的AbstractSessionEvent事件对象提供了获取Session（这里的是指Spring Session的对象）和SessionId。   \n\n基于事件的类型，分类为：\n* Session创建事件\n* Session删除事件\n* Session过期事件\n事件对象只是对事件本身的抽象，描述事件的属性，如：\n\n获取事件产生的源：getSource获取事件产生源\n获取相应事件特性：getSession/getSessoinId获取时间关联的Session\n下面再深入探索以上的Session事件是如何触发，从事件源到事件监听器的链路分析事件流转过程。\n# 二.事件的触发机制\n\n\n介绍Session Event事件基于Spring的ApplicationEvent实现。先简单认识spring上下文事件机制：\n![Session事件的抽象](pringSession源码（二）/2.png)\n\n* ApplicationEventPublisher实现用于发布Spring上下文事件ApplicationEvent\n* ApplicationListener实现用于监听Spring上下文事件ApplicationEvent\n* ApplicationEvent抽象上下文事件\n\n那么在Spring-Session中必然包含事件发布者ApplicationEventPublisher发布Session事件和ApplicationListener监听Session事件。\n\n可以看出ApplicationEventPublisher发布一个事件：\n```\n@FunctionalInterface\npublic interface ApplicationEventPublisher {\n\n    /**\n     * Notify all <strong>matching</strong> listeners registered with this\n     * application of an application event. Events may be framework events\n     * (such as RequestHandledEvent) or application-specific events.\n     * @param event the event to publish\n     * @see org.springframework.web.context.support.RequestHandledEvent\n     */\n    default void publishEvent(ApplicationEvent event) {\n        publishEvent((Object) event);\n    }\n\n    /**\n     * Notify all <strong>matching</strong> listeners registered with this\n     * application of an event.\n     * <p>If the specified {@code event} is not an {@link ApplicationEvent},\n     * it is wrapped in a {@link PayloadApplicationEvent}.\n     * @param event the event to publish\n     * @since 4.2\n     * @see PayloadApplicationEvent\n     */\n    void publishEvent(Object event);\n\n}\n```\nApplicationListener用于监听相应的事件：\n```\n@FunctionalInterface\npublic interface ApplicationListener<E extends ApplicationEvent> extends EventListener {\n\n    /**\n     * Handle an application event.\n     * @param event the event to respond to\n     */\n    void onApplicationEvent(E event);\n\n}\n```\nSession事件的流程实现如下：\n![Session事件的抽象](pringSession源码（二）/3.png)\nRedisMessageListenerContainer初始化时会启动一个线程SubscriptionTask进行订阅redis信息\n\n上图展示了Spring-Session事件流程图，事件源来自于Redis键空间通知，在spring-data-redis项目中抽象MessageListener监听Redis事件源，然后将其传播至spring应用上下文发布者，由发布者发布事件。在spring上下文中的监听器Listener即可监听到Session事件。\n\n因为两者是Spring框架提供的对Spring的ApplicationEvent的支持。Session Event基于ApplicationEvent实现，必然也有其相应发布者和监听器的的实现。\n\nSpring-Session中的RedisSession的SessionRepository是RedisOperationSessionRepository。所有关于RedisSession的管理操作都是由其实现，所以Session的产生源是RedisOperationSessionRepository。\n\n在RedisOperationSessionRepository中持有ApplicationEventPublisher对象用于发布Session事件。\n```\nprivate ApplicationEventPublisher eventPublisher = new ApplicationEventPublisher() {\n    @Override\n    public void publishEvent(ApplicationEvent event) {\n    }\n    @Override\n    public void publishEvent(Object event) {\n    }\n};\n```\n但是该ApplicationEventPublisher是空实现，实际实现是在应用启动时由Spring-Session自动配置。在spring-session-data-redis模块中RedisHttpSessionConfiguration中有关于创建RedisOperationSessionRepository Bean时将调用set方法将ApplicationEventPublisher配置。\n```\n@Configuration\n@EnableScheduling\npublic class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration\n        implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware,\n        SchedulingConfigurer {\n\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Bean\n    public RedisOperationsSessionRepository sessionRepository() {\n        RedisTemplate<Object, Object> redisTemplate = createRedisTemplate();\n        RedisOperationsSessionRepository sessionRepository = new RedisOperationsSessionRepository(\n                redisTemplate);\n        // 注入依赖\n        sessionRepository.setApplicationEventPublisher(this.applicationEventPublisher);\n        if (this.defaultRedisSerializer != null) {\n            sessionRepository.setDefaultSerializer(this.defaultRedisSerializer);\n        }\n        sessionRepository\n                .setDefaultMaxInactiveInterval(this.maxInactiveIntervalInSeconds);\n        if (StringUtils.hasText(this.redisNamespace)) {\n            sessionRepository.setRedisKeyNamespace(this.redisNamespace);\n        }\n        sessionRepository.setRedisFlushMode(this.redisFlushMode);\n        return sessionRepository;\n    }\n\n    // 注入上下文中的ApplicationEventPublisher Bean\n    @Autowired\n    public void setApplicationEventPublisher(\n            ApplicationEventPublisher applicationEventPublisher) {\n        this.applicationEventPublisher = applicationEventPublisher;\n    }\n\n}\n```\n在进行自动配置时，将上下文中的ApplicationEventPublisher的注入，实际上即ApplicationContext对象。\n对于ApplicationListener是由应用开发者自行实现，注册成Bean即可。当有Session Event发布时，即可监听。\n```\n/**\n * session事件监听器\n *\n * @author huaijin\n */\n@Component\npublic class SessionEventListener implements ApplicationListener<SessionDeletedEvent> {\n\n    private static final String CURRENT_USER = \"currentUser\";\n\n    @Override\n    public void onApplicationEvent(SessionDeletedEvent event) {\n        Session session = event.getSession();\n        UserVo userVo = session.getAttribute(CURRENT_USER);\n        System.out.println(\"Current session's user:\" + userVo.toString());\n    }\n}\n```\n以上部分探索了Session事件的发布者和监听者，但是核心事件的触发发布则是由Redis的键空间通知机制触发，当有Session创建/删除/过期时，Redis键空间会通知Spring-Session应用。\n\nRedisOperationsSessionRepository实现spring-data-redis中的MessageListener接口。\n```\n/**\n * Listener of messages published in Redis.\n *\n * @author Costin Leau\n * @author Christoph Strobl\n */\npublic interface MessageListener {\n\n    /**\n     * Callback for processing received objects through Redis.\n     *\n     * @param message message must not be {@literal null}.\n     * @param pattern pattern matching the channel (if specified) - can be {@literal null}.\n     */\n    void onMessage(Message message, @Nullable byte[] pattern);\n}\n```\n该监听器即用来监听redis发布的消息。RedisOperationsSessionRepositorys实现了该Redis键空间消息通知监听器接口，实现如下：\n```\npublic class RedisOperationsSessionRepository implements\n        FindByIndexNameSessionRepository<RedisOperationsSessionRepository.RedisSession>,\n        MessageListener {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void onMessage(Message message, byte[] pattern) {\n        // 获取该消息发布的redis通道channel\n        byte[] messageChannel = message.getChannel();\n        // 获取消息体内容\n        byte[] messageBody = message.getBody();\n\n        String channel = new String(messageChannel);\n\n        // 如果是由Session创建通道发布的消息，则是Session创建事件\n        if (channel.startsWith(getSessionCreatedChannelPrefix())) {\n            // 从消息体中载入Session\n            Map<Object, Object> loaded = (Map<Object, Object>) this.defaultSerializer\n                    .deserialize(message.getBody());\n            // 发布创建事件\n            handleCreated(loaded, channel);\n            return;\n        }\n\n        // 如果消息体不是以过期键前缀，直接返回。因为spring-session在redis中的key命名规则：\n        // \"${namespace}:sessions:expires:${sessionId}\"，如：\n        // session.example:sessions:expires:a5236a19-7325-4783-b1f0-db9d4442db9a\n        // 所以判断过期或者删除的键是否为spring-session的过期键。如果不是，可能是应用中其他的键的操作，所以直接return\n        String body = new String(messageBody);\n        if (!body.startsWith(getExpiredKeyPrefix())) {\n            return;\n        }\n\n        // 根据channel判断键空间的事件类型del或者expire时间\n        boolean isDeleted = channel.endsWith(\":del\");\n        if (isDeleted || channel.endsWith(\":expired\")) {\n            int beginIndex = body.lastIndexOf(\":\") + 1;\n            int endIndex = body.length();\n            // Redis键空间消息通知内容即操作的键，spring-session键中命名规则：\n            // \"${namespace}:sessions:expires:${sessionId}\"，以下是根据规则解析sessionId\n            String sessionId = body.substring(beginIndex, endIndex);\n\n            // 根据sessionId加载session\n            RedisSession session = getSession(sessionId, true);\n\n            if (session == null) {\n                logger.warn(\"Unable to publish SessionDestroyedEvent for session \"\n                        + sessionId);\n                return;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Publishing SessionDestroyedEvent for session \" + sessionId);\n            }\n\n            cleanupPrincipalIndex(session);\n\n            // 发布Session delete事件\n            if (isDeleted) {\n                handleDeleted(session);\n            }\n            else {\n                // 否则发布Session expire事件\n                handleExpired(session);\n            }\n        }\n    }\n}\n```\n下续再深入每种事件产生的前世今生。\n\n## Session创建事件的触发\n\n![Session事件的抽象](pringSession源码（二）/4.png)\n* 由RedisOperationSessionRepository向Redis指定通道${namespace}:event:created:${sessionId}发布一个message\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道${namespace}:event:created:${sessionId}的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionCreateEvent\n* ApplicationListener监听SessionCreateEvent，执行相应逻辑\n\nRedisOperationSessionRepository中保存一个Session时，判断Session是否新创建。\n如果新创建，则向\n```\n@Override\npublic void save(RedisSession session) {\n    session.saveDelta();\n    // 判断是否为新创建的session\n    if (session.isNew()) {\n        // 获取redis指定的channel：${namespace}:event:created:${sessionId}，\n        // 如：session.example:event:created:82sdd-4123-o244-ps123\n        String sessionCreatedKey = getSessionCreatedChannel(session.getId());\n        // 向该通道发布session数据\n        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);\n        // 设置session为非新创建\n        session.setNew(false);\n    }\n}\n```\n该save方法的调用是由HttpServletResponse提交时——即返回客户端响应调用，上篇文章已经详解，这里不再赘述。关于RedisOperationSessionRepository实现MessageListener上述已经介绍，这里同样不再赘述。\n## Session删除事件的触发\n删除事件中使用到了Redis KeySpace Notification，建议先了解该技术。\n\n![Session事件的抽象](pringSession源码（二）/5.png)\n* 由RedisOperationSessionRepository删除Redis键空间中的指定Session的过期键，Redis键空间会向**__keyevent@*:del**的channel发布删除事件消息\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道**__keyevent@*:del**的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionDeleteEvent\n* ApplicationListener监听SessionDeleteEvent，执行相应逻辑\n当调用HttpSession的invalidate方法让Session失效时，即会调用RedisOperationSessionRepository的deleteById方法删除Session的过期键。\n```\n/**\n * Allows creating an HttpSession from a Session instance.\n *\n * @author Rob Winch\n * @since 1.0\n */\nprivate final class HttpSessionWrapper extends HttpSessionAdapter<S> {\n    HttpSessionWrapper(S session, ServletContext servletContext) {\n        super(session, servletContext);\n    }\n\n    @Override\n    public void invalidate() {\n        super.invalidate();\n        SessionRepositoryRequestWrapper.this.requestedSessionInvalidated = true;\n        setCurrentSession(null);\n        clearRequestedSessionCache();\n        // 调用删除方法\n        SessionRepositoryFilter.this.sessionRepository.deleteById(getId());\n    }\n}\n```\n上篇中介绍了包装Spring Session为HttpSession，这里不再赘述。这里重点分析deleteById内容：\n```\n@Override\npublic void deleteById(String sessionId) {\n    // 如果session为空则返回\n    RedisSession session = getSession(sessionId, true);\n    if (session == null) {\n        return;\n    }\n\n    cleanupPrincipalIndex(session);\n    this.expirationPolicy.onDelete(session);\n    // 获取session的过期键\n    String expireKey = getExpiredKey(session.getId());\n    // 删除过期键，redis键空间产生del事件消息，被MessageListener即\n    // RedisOperationSessionRepository监听\n    this.sessionRedisOperations.delete(expireKey);\n    session.setMaxInactiveInterval(Duration.ZERO);\n    save(session);\n}\n```\n后续流程同SessionCreateEvent流程。\n\n## Session失效事件的触发\nSession的过期事件流程比较特殊，因为Redis的键空间通知的特殊性，Redis键空间通知不能保证过期键的通知的及时性。\n![Session事件的抽象](pringSession源码（二）/6.png)\n* RedisOperationsSessionRepository中有个定时任务方法每整分运行访问整分Session过期键集合中的过期sessionId，如：spring:session:expirations:1439245080000。触发Redis键空间会向**__keyevent@*:expired**的channel发布过期事件消息\n* MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道**__keyevent@*:expired**的消息\n* 将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher发布SessionDeleteEvent\n* ApplicationListener监听SessionDeleteEvent，执行相应逻辑\n\n```\n@Scheduled(cron = \"0 * * * * *\")\npublic void cleanupExpiredSessions() {\n    this.expirationPolicy.cleanExpiredSessions();\n}\n```\n定时任务每整分运行，执行cleanExpiredSessions方法。expirationPolicy是RedisSessionExpirationPolicy实例，是RedisSession过期策略。\n```\npublic void cleanExpiredSessions() {\n    // 获取当前时间戳\n    long now = System.currentTimeMillis();\n    // 时间滚动至整分，去掉秒和毫秒部分\n    long prevMin = roundDownMinute(now);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Cleaning up sessions expiring at \" + new Date(prevMin));\n    }\n    // 根据整分时间获取过期键集合，如：spring:session:expirations:1439245080000\n    String expirationKey = getExpirationKey(prevMin);\n    // 获取所有的所有的过期session\n    Set<Object> sessionsToExpire = this.redis.boundSetOps(expirationKey).members();\n    // 删除过期Session键集合\n    this.redis.delete(expirationKey);\n    // touch访问所有已经过期的session，触发Redis键空间通知消息\n    for (Object session : sessionsToExpire) {\n        String sessionKey = getSessionKey((String) session);\n        touch(sessionKey);\n    }\n}\n```\n将时间戳滚动至整分\n```\nstatic long roundDownMinute(long timeInMs) {\n    Calendar date = Calendar.getInstance();\n    date.setTimeInMillis(timeInMs);\n    // 清理时间错的秒位和毫秒位\n    date.clear(Calendar.SECOND);\n    date.clear(Calendar.MILLISECOND);\n    return date.getTimeInMillis();\n}\n```\n获取过期Session的集合\n```\nString getExpirationKey(long expires) {\n    return this.redisSession.getExpirationsKey(expires);\n}\n\n// 如：spring:session:expirations:1439245080000\nString getExpirationsKey(long expiration) {\n    return this.keyPrefix + \"expirations:\" + expiration;\n}\n```\n调用Redis的Exists命令，访问过期Session键，触发Redis键空间消息\n```\n/**\n * By trying to access the session we only trigger a deletion if it the TTL is\n * expired. This is done to handle\n * https://github.com/spring-projects/spring-session/issues/93\n *\n * @param key the key\n */\nprivate void touch(String key) {\n    this.redis.hasKey(key);\n}\n```\n总结\n至此Spring-Session的Session事件通知模块就已经很清晰：\n\n* Redis键空间Session事件源：Session创建通道/Session删除通道/Session过期通道\n* Spring-Session中的RedisOperationsSessionRepository消息监听器监听Redis的事件类型\n* RedisOperationsSessionRepository负责将其传播至ApplicationEventPublisher\n* ApplicationEventPublisher将其包装成ApplicationEvent类型的Session Event发布\n* ApplicationListener监听Session Event，处理相应逻辑\n\n\n","slug":"pringSession源码（二）","published":1,"updated":"2020-02-17T15:08:47.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38f001kn6zqjcas89wo","content":"<p><a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">如何使用spring session</a><br>上一篇文章中介绍了Spring-Session的核心原理，Filter，Session，Repository等等，传送门：<a href=\"https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/\" target=\"_blank\" rel=\"noopener\">SpringSession源码</a></p>\n<p>这篇继上一篇的原理逐渐深入Spring-Session中的事件机制原理的探索。众所周知，Servlet规范中有对HttpSession的事件的处理，如：HttpSessionEvent/HttpSessionIdListener/HttpSessionListener，可以查看Package javax.servlet</p>\n<p>在Spring-Session中也有相应的Session事件机制实现，包括Session创建/过期/删除事件。<br>本文主要从以下方面探索Spring-Session中事件机制</p>\n<ul>\n<li>Session事件的抽象</li>\n<li>事件的触发机制<h1 id=\"Session事件的抽象\"><a href=\"#Session事件的抽象\" class=\"headerlink\" title=\"Session事件的抽象\"></a>Session事件的抽象</h1>先来看下Session事件抽象UML类图，整体掌握事件之间的依赖关系。<br><img src=\"/2019/11/22/pringSession源码（二）/1.png\" alt=\"Session事件的抽象\"><br>Session Event最顶层是ApplicationEvent，即Spring上下文事件对象。由此可以看出Spring-Session的事件机制是基于Spring上下文事件实现。</li>\n</ul>\n<p>抽象的AbstractSessionEvent事件对象提供了获取Session（这里的是指Spring Session的对象）和SessionId。   </p>\n<p>基于事件的类型，分类为：</p>\n<ul>\n<li>Session创建事件</li>\n<li>Session删除事件</li>\n<li>Session过期事件<br>事件对象只是对事件本身的抽象，描述事件的属性，如：</li>\n</ul>\n<p>获取事件产生的源：getSource获取事件产生源<br>获取相应事件特性：getSession/getSessoinId获取时间关联的Session<br>下面再深入探索以上的Session事件是如何触发，从事件源到事件监听器的链路分析事件流转过程。</p>\n<h1 id=\"二-事件的触发机制\"><a href=\"#二-事件的触发机制\" class=\"headerlink\" title=\"二.事件的触发机制\"></a>二.事件的触发机制</h1><p>介绍Session Event事件基于Spring的ApplicationEvent实现。先简单认识spring上下文事件机制：<br><img src=\"/2019/11/22/pringSession源码（二）/2.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>ApplicationEventPublisher实现用于发布Spring上下文事件ApplicationEvent</li>\n<li>ApplicationListener实现用于监听Spring上下文事件ApplicationEvent</li>\n<li>ApplicationEvent抽象上下文事件</li>\n</ul>\n<p>那么在Spring-Session中必然包含事件发布者ApplicationEventPublisher发布Session事件和ApplicationListener监听Session事件。</p>\n<p>可以看出ApplicationEventPublisher发布一个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface ApplicationEventPublisher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this</span><br><span class=\"line\">     * application of an application event. Events may be framework events</span><br><span class=\"line\">     * (such as RequestHandledEvent) or application-specific events.</span><br><span class=\"line\">     * @param event the event to publish</span><br><span class=\"line\">     * @see org.springframework.web.context.support.RequestHandledEvent</span><br><span class=\"line\">     */</span><br><span class=\"line\">    default void publishEvent(ApplicationEvent event) &#123;</span><br><span class=\"line\">        publishEvent((Object) event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this</span><br><span class=\"line\">     * application of an event.</span><br><span class=\"line\">     * &lt;p&gt;If the specified &#123;@code event&#125; is not an &#123;@link ApplicationEvent&#125;,</span><br><span class=\"line\">     * it is wrapped in a &#123;@link PayloadApplicationEvent&#125;.</span><br><span class=\"line\">     * @param event the event to publish</span><br><span class=\"line\">     * @since 4.2</span><br><span class=\"line\">     * @see PayloadApplicationEvent</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void publishEvent(Object event);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ApplicationListener用于监听相应的事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Handle an application event.</span><br><span class=\"line\">     * @param event the event to respond to</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onApplicationEvent(E event);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Session事件的流程实现如下：<br><img src=\"/2019/11/22/pringSession源码（二）/3.png\" alt=\"Session事件的抽象\"><br>RedisMessageListenerContainer初始化时会启动一个线程SubscriptionTask进行订阅redis信息</p>\n<p>上图展示了Spring-Session事件流程图，事件源来自于Redis键空间通知，在spring-data-redis项目中抽象MessageListener监听Redis事件源，然后将其传播至spring应用上下文发布者，由发布者发布事件。在spring上下文中的监听器Listener即可监听到Session事件。</p>\n<p>因为两者是Spring框架提供的对Spring的ApplicationEvent的支持。Session Event基于ApplicationEvent实现，必然也有其相应发布者和监听器的的实现。</p>\n<p>Spring-Session中的RedisSession的SessionRepository是RedisOperationSessionRepository。所有关于RedisSession的管理操作都是由其实现，所以Session的产生源是RedisOperationSessionRepository。</p>\n<p>在RedisOperationSessionRepository中持有ApplicationEventPublisher对象用于发布Session事件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ApplicationEventPublisher eventPublisher = new ApplicationEventPublisher() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void publishEvent(ApplicationEvent event) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void publishEvent(Object event) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是该ApplicationEventPublisher是空实现，实际实现是在应用启动时由Spring-Session自动配置。在spring-session-data-redis模块中RedisHttpSessionConfiguration中有关于创建RedisOperationSessionRepository Bean时将调用set方法将ApplicationEventPublisher配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableScheduling</span><br><span class=\"line\">public class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration</span><br><span class=\"line\">        implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware,</span><br><span class=\"line\">        SchedulingConfigurer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationEventPublisher applicationEventPublisher;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RedisOperationsSessionRepository sessionRepository() &#123;</span><br><span class=\"line\">        RedisTemplate&lt;Object, Object&gt; redisTemplate = createRedisTemplate();</span><br><span class=\"line\">        RedisOperationsSessionRepository sessionRepository = new RedisOperationsSessionRepository(</span><br><span class=\"line\">                redisTemplate);</span><br><span class=\"line\">        // 注入依赖</span><br><span class=\"line\">        sessionRepository.setApplicationEventPublisher(this.applicationEventPublisher);</span><br><span class=\"line\">        if (this.defaultRedisSerializer != null) &#123;</span><br><span class=\"line\">            sessionRepository.setDefaultSerializer(this.defaultRedisSerializer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sessionRepository</span><br><span class=\"line\">                .setDefaultMaxInactiveInterval(this.maxInactiveIntervalInSeconds);</span><br><span class=\"line\">        if (StringUtils.hasText(this.redisNamespace)) &#123;</span><br><span class=\"line\">            sessionRepository.setRedisKeyNamespace(this.redisNamespace);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sessionRepository.setRedisFlushMode(this.redisFlushMode);</span><br><span class=\"line\">        return sessionRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注入上下文中的ApplicationEventPublisher Bean</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    public void setApplicationEventPublisher(</span><br><span class=\"line\">            ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class=\"line\">        this.applicationEventPublisher = applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在进行自动配置时，将上下文中的ApplicationEventPublisher的注入，实际上即ApplicationContext对象。<br>对于ApplicationListener是由应用开发者自行实现，注册成Bean即可。当有Session Event发布时，即可监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * session事件监听器</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author huaijin</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class SessionEventListener implements ApplicationListener&lt;SessionDeletedEvent&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final String CURRENT_USER = &quot;currentUser&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onApplicationEvent(SessionDeletedEvent event) &#123;</span><br><span class=\"line\">        Session session = event.getSession();</span><br><span class=\"line\">        UserVo userVo = session.getAttribute(CURRENT_USER);</span><br><span class=\"line\">        System.out.println(&quot;Current session&apos;s user:&quot; + userVo.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上部分探索了Session事件的发布者和监听者，但是核心事件的触发发布则是由Redis的键空间通知机制触发，当有Session创建/删除/过期时，Redis键空间会通知Spring-Session应用。</p>\n<p>RedisOperationsSessionRepository实现spring-data-redis中的MessageListener接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Listener of messages published in Redis.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Costin Leau</span><br><span class=\"line\"> * @author Christoph Strobl</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface MessageListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Callback for processing received objects through Redis.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param message message must not be &#123;@literal null&#125;.</span><br><span class=\"line\">     * @param pattern pattern matching the channel (if specified) - can be &#123;@literal null&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onMessage(Message message, @Nullable byte[] pattern);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该监听器即用来监听redis发布的消息。RedisOperationsSessionRepositorys实现了该Redis键空间消息通知监听器接口，实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RedisOperationsSessionRepository implements</span><br><span class=\"line\">        FindByIndexNameSessionRepository&lt;RedisOperationsSessionRepository.RedisSession&gt;,</span><br><span class=\"line\">        MessageListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">    public void onMessage(Message message, byte[] pattern) &#123;</span><br><span class=\"line\">        // 获取该消息发布的redis通道channel</span><br><span class=\"line\">        byte[] messageChannel = message.getChannel();</span><br><span class=\"line\">        // 获取消息体内容</span><br><span class=\"line\">        byte[] messageBody = message.getBody();</span><br><span class=\"line\"></span><br><span class=\"line\">        String channel = new String(messageChannel);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是由Session创建通道发布的消息，则是Session创建事件</span><br><span class=\"line\">        if (channel.startsWith(getSessionCreatedChannelPrefix())) &#123;</span><br><span class=\"line\">            // 从消息体中载入Session</span><br><span class=\"line\">            Map&lt;Object, Object&gt; loaded = (Map&lt;Object, Object&gt;) this.defaultSerializer</span><br><span class=\"line\">                    .deserialize(message.getBody());</span><br><span class=\"line\">            // 发布创建事件</span><br><span class=\"line\">            handleCreated(loaded, channel);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果消息体不是以过期键前缀，直接返回。因为spring-session在redis中的key命名规则：</span><br><span class=\"line\">        // &quot;$&#123;namespace&#125;:sessions:expires:$&#123;sessionId&#125;&quot;，如：</span><br><span class=\"line\">        // session.example:sessions:expires:a5236a19-7325-4783-b1f0-db9d4442db9a</span><br><span class=\"line\">        // 所以判断过期或者删除的键是否为spring-session的过期键。如果不是，可能是应用中其他的键的操作，所以直接return</span><br><span class=\"line\">        String body = new String(messageBody);</span><br><span class=\"line\">        if (!body.startsWith(getExpiredKeyPrefix())) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 根据channel判断键空间的事件类型del或者expire时间</span><br><span class=\"line\">        boolean isDeleted = channel.endsWith(&quot;:del&quot;);</span><br><span class=\"line\">        if (isDeleted || channel.endsWith(&quot;:expired&quot;)) &#123;</span><br><span class=\"line\">            int beginIndex = body.lastIndexOf(&quot;:&quot;) + 1;</span><br><span class=\"line\">            int endIndex = body.length();</span><br><span class=\"line\">            // Redis键空间消息通知内容即操作的键，spring-session键中命名规则：</span><br><span class=\"line\">            // &quot;$&#123;namespace&#125;:sessions:expires:$&#123;sessionId&#125;&quot;，以下是根据规则解析sessionId</span><br><span class=\"line\">            String sessionId = body.substring(beginIndex, endIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 根据sessionId加载session</span><br><span class=\"line\">            RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (session == null) &#123;</span><br><span class=\"line\">                logger.warn(&quot;Unable to publish SessionDestroyedEvent for session &quot;</span><br><span class=\"line\">                        + sessionId);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(&quot;Publishing SessionDestroyedEvent for session &quot; + sessionId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cleanupPrincipalIndex(session);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 发布Session delete事件</span><br><span class=\"line\">            if (isDeleted) &#123;</span><br><span class=\"line\">                handleDeleted(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                // 否则发布Session expire事件</span><br><span class=\"line\">                handleExpired(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下续再深入每种事件产生的前世今生。</p>\n<h2 id=\"Session创建事件的触发\"><a href=\"#Session创建事件的触发\" class=\"headerlink\" title=\"Session创建事件的触发\"></a>Session创建事件的触发</h2><p><img src=\"/2019/11/22/pringSession源码（二）/4.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>由RedisOperationSessionRepository向Redis指定通道${namespace}:event:created:${sessionId}发布一个message</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道${namespace}:event:created:${sessionId}的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionCreateEvent</li>\n<li>ApplicationListener监听SessionCreateEvent，执行相应逻辑</li>\n</ul>\n<p>RedisOperationSessionRepository中保存一个Session时，判断Session是否新创建。<br>如果新创建，则向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void save(RedisSession session) &#123;</span><br><span class=\"line\">    session.saveDelta();</span><br><span class=\"line\">    // 判断是否为新创建的session</span><br><span class=\"line\">    if (session.isNew()) &#123;</span><br><span class=\"line\">        // 获取redis指定的channel：$&#123;namespace&#125;:event:created:$&#123;sessionId&#125;，</span><br><span class=\"line\">        // 如：session.example:event:created:82sdd-4123-o244-ps123</span><br><span class=\"line\">        String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class=\"line\">        // 向该通道发布session数据</span><br><span class=\"line\">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class=\"line\">        // 设置session为非新创建</span><br><span class=\"line\">        session.setNew(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该save方法的调用是由HttpServletResponse提交时——即返回客户端响应调用，上篇文章已经详解，这里不再赘述。关于RedisOperationSessionRepository实现MessageListener上述已经介绍，这里同样不再赘述。</p>\n<h2 id=\"Session删除事件的触发\"><a href=\"#Session删除事件的触发\" class=\"headerlink\" title=\"Session删除事件的触发\"></a>Session删除事件的触发</h2><p>删除事件中使用到了Redis KeySpace Notification，建议先了解该技术。</p>\n<p><img src=\"/2019/11/22/pringSession源码（二）/5.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>由RedisOperationSessionRepository删除Redis键空间中的指定Session的过期键，Redis键空间会向<strong>__keyevent@*:del</strong>的channel发布删除事件消息</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道<strong>__keyevent@*:del</strong>的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionDeleteEvent</li>\n<li>ApplicationListener监听SessionDeleteEvent，执行相应逻辑<br>当调用HttpSession的invalidate方法让Session失效时，即会调用RedisOperationSessionRepository的deleteById方法删除Session的过期键。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows creating an HttpSession from a Session instance.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final class HttpSessionWrapper extends HttpSessionAdapter&lt;S&gt; &#123;</span><br><span class=\"line\">    HttpSessionWrapper(S session, ServletContext servletContext) &#123;</span><br><span class=\"line\">        super(session, servletContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void invalidate() &#123;</span><br><span class=\"line\">        super.invalidate();</span><br><span class=\"line\">        SessionRepositoryRequestWrapper.this.requestedSessionInvalidated = true;</span><br><span class=\"line\">        setCurrentSession(null);</span><br><span class=\"line\">        clearRequestedSessionCache();</span><br><span class=\"line\">        // 调用删除方法</span><br><span class=\"line\">        SessionRepositoryFilter.this.sessionRepository.deleteById(getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上篇中介绍了包装Spring Session为HttpSession，这里不再赘述。这里重点分析deleteById内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void deleteById(String sessionId) &#123;</span><br><span class=\"line\">    // 如果session为空则返回</span><br><span class=\"line\">    RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\">    if (session == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cleanupPrincipalIndex(session);</span><br><span class=\"line\">    this.expirationPolicy.onDelete(session);</span><br><span class=\"line\">    // 获取session的过期键</span><br><span class=\"line\">    String expireKey = getExpiredKey(session.getId());</span><br><span class=\"line\">    // 删除过期键，redis键空间产生del事件消息，被MessageListener即</span><br><span class=\"line\">    // RedisOperationSessionRepository监听</span><br><span class=\"line\">    this.sessionRedisOperations.delete(expireKey);</span><br><span class=\"line\">    session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class=\"line\">    save(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>后续流程同SessionCreateEvent流程。</p>\n<h2 id=\"Session失效事件的触发\"><a href=\"#Session失效事件的触发\" class=\"headerlink\" title=\"Session失效事件的触发\"></a>Session失效事件的触发</h2><p>Session的过期事件流程比较特殊，因为Redis的键空间通知的特殊性，Redis键空间通知不能保证过期键的通知的及时性。<br><img src=\"/2019/11/22/pringSession源码（二）/6.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>RedisOperationsSessionRepository中有个定时任务方法每整分运行访问整分Session过期键集合中的过期sessionId，如：spring:session:expirations:1439245080000。触发Redis键空间会向<strong>__keyevent@*:expired</strong>的channel发布过期事件消息</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道<strong>__keyevent@*:expired</strong>的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionDeleteEvent</li>\n<li>ApplicationListener监听SessionDeleteEvent，执行相应逻辑</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scheduled(cron = &quot;0 * * * * *&quot;)</span><br><span class=\"line\">public void cleanupExpiredSessions() &#123;</span><br><span class=\"line\">    this.expirationPolicy.cleanExpiredSessions();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定时任务每整分运行，执行cleanExpiredSessions方法。expirationPolicy是RedisSessionExpirationPolicy实例，是RedisSession过期策略。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void cleanExpiredSessions() &#123;</span><br><span class=\"line\">    // 获取当前时间戳</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 时间滚动至整分，去掉秒和毫秒部分</span><br><span class=\"line\">    long prevMin = roundDownMinute(now);</span><br><span class=\"line\">    if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(&quot;Cleaning up sessions expiring at &quot; + new Date(prevMin));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据整分时间获取过期键集合，如：spring:session:expirations:1439245080000</span><br><span class=\"line\">    String expirationKey = getExpirationKey(prevMin);</span><br><span class=\"line\">    // 获取所有的所有的过期session</span><br><span class=\"line\">    Set&lt;Object&gt; sessionsToExpire = this.redis.boundSetOps(expirationKey).members();</span><br><span class=\"line\">    // 删除过期Session键集合</span><br><span class=\"line\">    this.redis.delete(expirationKey);</span><br><span class=\"line\">    // touch访问所有已经过期的session，触发Redis键空间通知消息</span><br><span class=\"line\">    for (Object session : sessionsToExpire) &#123;</span><br><span class=\"line\">        String sessionKey = getSessionKey((String) session);</span><br><span class=\"line\">        touch(sessionKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将时间戳滚动至整分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long roundDownMinute(long timeInMs) &#123;</span><br><span class=\"line\">    Calendar date = Calendar.getInstance();</span><br><span class=\"line\">    date.setTimeInMillis(timeInMs);</span><br><span class=\"line\">    // 清理时间错的秒位和毫秒位</span><br><span class=\"line\">    date.clear(Calendar.SECOND);</span><br><span class=\"line\">    date.clear(Calendar.MILLISECOND);</span><br><span class=\"line\">    return date.getTimeInMillis();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取过期Session的集合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String getExpirationKey(long expires) &#123;</span><br><span class=\"line\">    return this.redisSession.getExpirationsKey(expires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如：spring:session:expirations:1439245080000</span><br><span class=\"line\">String getExpirationsKey(long expiration) &#123;</span><br><span class=\"line\">    return this.keyPrefix + &quot;expirations:&quot; + expiration;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用Redis的Exists命令，访问过期Session键，触发Redis键空间消息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * By trying to access the session we only trigger a deletion if it the TTL is</span><br><span class=\"line\"> * expired. This is done to handle</span><br><span class=\"line\"> * https://github.com/spring-projects/spring-session/issues/93</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param key the key</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void touch(String key) &#123;</span><br><span class=\"line\">    this.redis.hasKey(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总结<br>至此Spring-Session的Session事件通知模块就已经很清晰：</p>\n<ul>\n<li>Redis键空间Session事件源：Session创建通道/Session删除通道/Session过期通道</li>\n<li>Spring-Session中的RedisOperationsSessionRepository消息监听器监听Redis的事件类型</li>\n<li>RedisOperationsSessionRepository负责将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher将其包装成ApplicationEvent类型的Session Event发布</li>\n<li>ApplicationListener监听Session Event，处理相应逻辑</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://smallwenzi.github.io/2019/11/13/ring-session%EF%BC%881%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">如何使用spring session</a><br>上一篇文章中介绍了Spring-Session的核心原理，Filter，Session，Repository等等，传送门：<a href=\"https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/\" target=\"_blank\" rel=\"noopener\">SpringSession源码</a></p>\n<p>这篇继上一篇的原理逐渐深入Spring-Session中的事件机制原理的探索。众所周知，Servlet规范中有对HttpSession的事件的处理，如：HttpSessionEvent/HttpSessionIdListener/HttpSessionListener，可以查看Package javax.servlet</p>\n<p>在Spring-Session中也有相应的Session事件机制实现，包括Session创建/过期/删除事件。<br>本文主要从以下方面探索Spring-Session中事件机制</p>\n<ul>\n<li>Session事件的抽象</li>\n<li>事件的触发机制<h1 id=\"Session事件的抽象\"><a href=\"#Session事件的抽象\" class=\"headerlink\" title=\"Session事件的抽象\"></a>Session事件的抽象</h1>先来看下Session事件抽象UML类图，整体掌握事件之间的依赖关系。<br><img src=\"/2019/11/22/pringSession源码（二）/1.png\" alt=\"Session事件的抽象\"><br>Session Event最顶层是ApplicationEvent，即Spring上下文事件对象。由此可以看出Spring-Session的事件机制是基于Spring上下文事件实现。</li>\n</ul>\n<p>抽象的AbstractSessionEvent事件对象提供了获取Session（这里的是指Spring Session的对象）和SessionId。   </p>\n<p>基于事件的类型，分类为：</p>\n<ul>\n<li>Session创建事件</li>\n<li>Session删除事件</li>\n<li>Session过期事件<br>事件对象只是对事件本身的抽象，描述事件的属性，如：</li>\n</ul>\n<p>获取事件产生的源：getSource获取事件产生源<br>获取相应事件特性：getSession/getSessoinId获取时间关联的Session<br>下面再深入探索以上的Session事件是如何触发，从事件源到事件监听器的链路分析事件流转过程。</p>\n<h1 id=\"二-事件的触发机制\"><a href=\"#二-事件的触发机制\" class=\"headerlink\" title=\"二.事件的触发机制\"></a>二.事件的触发机制</h1><p>介绍Session Event事件基于Spring的ApplicationEvent实现。先简单认识spring上下文事件机制：<br><img src=\"/2019/11/22/pringSession源码（二）/2.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>ApplicationEventPublisher实现用于发布Spring上下文事件ApplicationEvent</li>\n<li>ApplicationListener实现用于监听Spring上下文事件ApplicationEvent</li>\n<li>ApplicationEvent抽象上下文事件</li>\n</ul>\n<p>那么在Spring-Session中必然包含事件发布者ApplicationEventPublisher发布Session事件和ApplicationListener监听Session事件。</p>\n<p>可以看出ApplicationEventPublisher发布一个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface ApplicationEventPublisher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this</span><br><span class=\"line\">     * application of an application event. Events may be framework events</span><br><span class=\"line\">     * (such as RequestHandledEvent) or application-specific events.</span><br><span class=\"line\">     * @param event the event to publish</span><br><span class=\"line\">     * @see org.springframework.web.context.support.RequestHandledEvent</span><br><span class=\"line\">     */</span><br><span class=\"line\">    default void publishEvent(ApplicationEvent event) &#123;</span><br><span class=\"line\">        publishEvent((Object) event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this</span><br><span class=\"line\">     * application of an event.</span><br><span class=\"line\">     * &lt;p&gt;If the specified &#123;@code event&#125; is not an &#123;@link ApplicationEvent&#125;,</span><br><span class=\"line\">     * it is wrapped in a &#123;@link PayloadApplicationEvent&#125;.</span><br><span class=\"line\">     * @param event the event to publish</span><br><span class=\"line\">     * @since 4.2</span><br><span class=\"line\">     * @see PayloadApplicationEvent</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void publishEvent(Object event);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ApplicationListener用于监听相应的事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Handle an application event.</span><br><span class=\"line\">     * @param event the event to respond to</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onApplicationEvent(E event);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Session事件的流程实现如下：<br><img src=\"/2019/11/22/pringSession源码（二）/3.png\" alt=\"Session事件的抽象\"><br>RedisMessageListenerContainer初始化时会启动一个线程SubscriptionTask进行订阅redis信息</p>\n<p>上图展示了Spring-Session事件流程图，事件源来自于Redis键空间通知，在spring-data-redis项目中抽象MessageListener监听Redis事件源，然后将其传播至spring应用上下文发布者，由发布者发布事件。在spring上下文中的监听器Listener即可监听到Session事件。</p>\n<p>因为两者是Spring框架提供的对Spring的ApplicationEvent的支持。Session Event基于ApplicationEvent实现，必然也有其相应发布者和监听器的的实现。</p>\n<p>Spring-Session中的RedisSession的SessionRepository是RedisOperationSessionRepository。所有关于RedisSession的管理操作都是由其实现，所以Session的产生源是RedisOperationSessionRepository。</p>\n<p>在RedisOperationSessionRepository中持有ApplicationEventPublisher对象用于发布Session事件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ApplicationEventPublisher eventPublisher = new ApplicationEventPublisher() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void publishEvent(ApplicationEvent event) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void publishEvent(Object event) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是该ApplicationEventPublisher是空实现，实际实现是在应用启动时由Spring-Session自动配置。在spring-session-data-redis模块中RedisHttpSessionConfiguration中有关于创建RedisOperationSessionRepository Bean时将调用set方法将ApplicationEventPublisher配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableScheduling</span><br><span class=\"line\">public class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration</span><br><span class=\"line\">        implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware,</span><br><span class=\"line\">        SchedulingConfigurer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ApplicationEventPublisher applicationEventPublisher;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RedisOperationsSessionRepository sessionRepository() &#123;</span><br><span class=\"line\">        RedisTemplate&lt;Object, Object&gt; redisTemplate = createRedisTemplate();</span><br><span class=\"line\">        RedisOperationsSessionRepository sessionRepository = new RedisOperationsSessionRepository(</span><br><span class=\"line\">                redisTemplate);</span><br><span class=\"line\">        // 注入依赖</span><br><span class=\"line\">        sessionRepository.setApplicationEventPublisher(this.applicationEventPublisher);</span><br><span class=\"line\">        if (this.defaultRedisSerializer != null) &#123;</span><br><span class=\"line\">            sessionRepository.setDefaultSerializer(this.defaultRedisSerializer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sessionRepository</span><br><span class=\"line\">                .setDefaultMaxInactiveInterval(this.maxInactiveIntervalInSeconds);</span><br><span class=\"line\">        if (StringUtils.hasText(this.redisNamespace)) &#123;</span><br><span class=\"line\">            sessionRepository.setRedisKeyNamespace(this.redisNamespace);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sessionRepository.setRedisFlushMode(this.redisFlushMode);</span><br><span class=\"line\">        return sessionRepository;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注入上下文中的ApplicationEventPublisher Bean</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    public void setApplicationEventPublisher(</span><br><span class=\"line\">            ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class=\"line\">        this.applicationEventPublisher = applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在进行自动配置时，将上下文中的ApplicationEventPublisher的注入，实际上即ApplicationContext对象。<br>对于ApplicationListener是由应用开发者自行实现，注册成Bean即可。当有Session Event发布时，即可监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * session事件监听器</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author huaijin</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class SessionEventListener implements ApplicationListener&lt;SessionDeletedEvent&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final String CURRENT_USER = &quot;currentUser&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onApplicationEvent(SessionDeletedEvent event) &#123;</span><br><span class=\"line\">        Session session = event.getSession();</span><br><span class=\"line\">        UserVo userVo = session.getAttribute(CURRENT_USER);</span><br><span class=\"line\">        System.out.println(&quot;Current session&apos;s user:&quot; + userVo.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上部分探索了Session事件的发布者和监听者，但是核心事件的触发发布则是由Redis的键空间通知机制触发，当有Session创建/删除/过期时，Redis键空间会通知Spring-Session应用。</p>\n<p>RedisOperationsSessionRepository实现spring-data-redis中的MessageListener接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Listener of messages published in Redis.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Costin Leau</span><br><span class=\"line\"> * @author Christoph Strobl</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface MessageListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Callback for processing received objects through Redis.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param message message must not be &#123;@literal null&#125;.</span><br><span class=\"line\">     * @param pattern pattern matching the channel (if specified) - can be &#123;@literal null&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void onMessage(Message message, @Nullable byte[] pattern);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该监听器即用来监听redis发布的消息。RedisOperationsSessionRepositorys实现了该Redis键空间消息通知监听器接口，实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RedisOperationsSessionRepository implements</span><br><span class=\"line\">        FindByIndexNameSessionRepository&lt;RedisOperationsSessionRepository.RedisSession&gt;,</span><br><span class=\"line\">        MessageListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">    public void onMessage(Message message, byte[] pattern) &#123;</span><br><span class=\"line\">        // 获取该消息发布的redis通道channel</span><br><span class=\"line\">        byte[] messageChannel = message.getChannel();</span><br><span class=\"line\">        // 获取消息体内容</span><br><span class=\"line\">        byte[] messageBody = message.getBody();</span><br><span class=\"line\"></span><br><span class=\"line\">        String channel = new String(messageChannel);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果是由Session创建通道发布的消息，则是Session创建事件</span><br><span class=\"line\">        if (channel.startsWith(getSessionCreatedChannelPrefix())) &#123;</span><br><span class=\"line\">            // 从消息体中载入Session</span><br><span class=\"line\">            Map&lt;Object, Object&gt; loaded = (Map&lt;Object, Object&gt;) this.defaultSerializer</span><br><span class=\"line\">                    .deserialize(message.getBody());</span><br><span class=\"line\">            // 发布创建事件</span><br><span class=\"line\">            handleCreated(loaded, channel);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果消息体不是以过期键前缀，直接返回。因为spring-session在redis中的key命名规则：</span><br><span class=\"line\">        // &quot;$&#123;namespace&#125;:sessions:expires:$&#123;sessionId&#125;&quot;，如：</span><br><span class=\"line\">        // session.example:sessions:expires:a5236a19-7325-4783-b1f0-db9d4442db9a</span><br><span class=\"line\">        // 所以判断过期或者删除的键是否为spring-session的过期键。如果不是，可能是应用中其他的键的操作，所以直接return</span><br><span class=\"line\">        String body = new String(messageBody);</span><br><span class=\"line\">        if (!body.startsWith(getExpiredKeyPrefix())) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 根据channel判断键空间的事件类型del或者expire时间</span><br><span class=\"line\">        boolean isDeleted = channel.endsWith(&quot;:del&quot;);</span><br><span class=\"line\">        if (isDeleted || channel.endsWith(&quot;:expired&quot;)) &#123;</span><br><span class=\"line\">            int beginIndex = body.lastIndexOf(&quot;:&quot;) + 1;</span><br><span class=\"line\">            int endIndex = body.length();</span><br><span class=\"line\">            // Redis键空间消息通知内容即操作的键，spring-session键中命名规则：</span><br><span class=\"line\">            // &quot;$&#123;namespace&#125;:sessions:expires:$&#123;sessionId&#125;&quot;，以下是根据规则解析sessionId</span><br><span class=\"line\">            String sessionId = body.substring(beginIndex, endIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 根据sessionId加载session</span><br><span class=\"line\">            RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (session == null) &#123;</span><br><span class=\"line\">                logger.warn(&quot;Unable to publish SessionDestroyedEvent for session &quot;</span><br><span class=\"line\">                        + sessionId);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(&quot;Publishing SessionDestroyedEvent for session &quot; + sessionId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cleanupPrincipalIndex(session);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 发布Session delete事件</span><br><span class=\"line\">            if (isDeleted) &#123;</span><br><span class=\"line\">                handleDeleted(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                // 否则发布Session expire事件</span><br><span class=\"line\">                handleExpired(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下续再深入每种事件产生的前世今生。</p>\n<h2 id=\"Session创建事件的触发\"><a href=\"#Session创建事件的触发\" class=\"headerlink\" title=\"Session创建事件的触发\"></a>Session创建事件的触发</h2><p><img src=\"/2019/11/22/pringSession源码（二）/4.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>由RedisOperationSessionRepository向Redis指定通道${namespace}:event:created:${sessionId}发布一个message</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道${namespace}:event:created:${sessionId}的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionCreateEvent</li>\n<li>ApplicationListener监听SessionCreateEvent，执行相应逻辑</li>\n</ul>\n<p>RedisOperationSessionRepository中保存一个Session时，判断Session是否新创建。<br>如果新创建，则向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void save(RedisSession session) &#123;</span><br><span class=\"line\">    session.saveDelta();</span><br><span class=\"line\">    // 判断是否为新创建的session</span><br><span class=\"line\">    if (session.isNew()) &#123;</span><br><span class=\"line\">        // 获取redis指定的channel：$&#123;namespace&#125;:event:created:$&#123;sessionId&#125;，</span><br><span class=\"line\">        // 如：session.example:event:created:82sdd-4123-o244-ps123</span><br><span class=\"line\">        String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class=\"line\">        // 向该通道发布session数据</span><br><span class=\"line\">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class=\"line\">        // 设置session为非新创建</span><br><span class=\"line\">        session.setNew(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该save方法的调用是由HttpServletResponse提交时——即返回客户端响应调用，上篇文章已经详解，这里不再赘述。关于RedisOperationSessionRepository实现MessageListener上述已经介绍，这里同样不再赘述。</p>\n<h2 id=\"Session删除事件的触发\"><a href=\"#Session删除事件的触发\" class=\"headerlink\" title=\"Session删除事件的触发\"></a>Session删除事件的触发</h2><p>删除事件中使用到了Redis KeySpace Notification，建议先了解该技术。</p>\n<p><img src=\"/2019/11/22/pringSession源码（二）/5.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>由RedisOperationSessionRepository删除Redis键空间中的指定Session的过期键，Redis键空间会向<strong>__keyevent@*:del</strong>的channel发布删除事件消息</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道<strong>__keyevent@*:del</strong>的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionDeleteEvent</li>\n<li>ApplicationListener监听SessionDeleteEvent，执行相应逻辑<br>当调用HttpSession的invalidate方法让Session失效时，即会调用RedisOperationSessionRepository的deleteById方法删除Session的过期键。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows creating an HttpSession from a Session instance.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Rob Winch</span><br><span class=\"line\"> * @since 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final class HttpSessionWrapper extends HttpSessionAdapter&lt;S&gt; &#123;</span><br><span class=\"line\">    HttpSessionWrapper(S session, ServletContext servletContext) &#123;</span><br><span class=\"line\">        super(session, servletContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void invalidate() &#123;</span><br><span class=\"line\">        super.invalidate();</span><br><span class=\"line\">        SessionRepositoryRequestWrapper.this.requestedSessionInvalidated = true;</span><br><span class=\"line\">        setCurrentSession(null);</span><br><span class=\"line\">        clearRequestedSessionCache();</span><br><span class=\"line\">        // 调用删除方法</span><br><span class=\"line\">        SessionRepositoryFilter.this.sessionRepository.deleteById(getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上篇中介绍了包装Spring Session为HttpSession，这里不再赘述。这里重点分析deleteById内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void deleteById(String sessionId) &#123;</span><br><span class=\"line\">    // 如果session为空则返回</span><br><span class=\"line\">    RedisSession session = getSession(sessionId, true);</span><br><span class=\"line\">    if (session == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cleanupPrincipalIndex(session);</span><br><span class=\"line\">    this.expirationPolicy.onDelete(session);</span><br><span class=\"line\">    // 获取session的过期键</span><br><span class=\"line\">    String expireKey = getExpiredKey(session.getId());</span><br><span class=\"line\">    // 删除过期键，redis键空间产生del事件消息，被MessageListener即</span><br><span class=\"line\">    // RedisOperationSessionRepository监听</span><br><span class=\"line\">    this.sessionRedisOperations.delete(expireKey);</span><br><span class=\"line\">    session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class=\"line\">    save(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>后续流程同SessionCreateEvent流程。</p>\n<h2 id=\"Session失效事件的触发\"><a href=\"#Session失效事件的触发\" class=\"headerlink\" title=\"Session失效事件的触发\"></a>Session失效事件的触发</h2><p>Session的过期事件流程比较特殊，因为Redis的键空间通知的特殊性，Redis键空间通知不能保证过期键的通知的及时性。<br><img src=\"/2019/11/22/pringSession源码（二）/6.png\" alt=\"Session事件的抽象\"></p>\n<ul>\n<li>RedisOperationsSessionRepository中有个定时任务方法每整分运行访问整分Session过期键集合中的过期sessionId，如：spring:session:expirations:1439245080000。触发Redis键空间会向<strong>__keyevent@*:expired</strong>的channel发布过期事件消息</li>\n<li>MessageListener的实现RedisOperationSessionRepository监听到Redis指定通道<strong>__keyevent@*:expired</strong>的消息</li>\n<li>将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher发布SessionDeleteEvent</li>\n<li>ApplicationListener监听SessionDeleteEvent，执行相应逻辑</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scheduled(cron = &quot;0 * * * * *&quot;)</span><br><span class=\"line\">public void cleanupExpiredSessions() &#123;</span><br><span class=\"line\">    this.expirationPolicy.cleanExpiredSessions();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定时任务每整分运行，执行cleanExpiredSessions方法。expirationPolicy是RedisSessionExpirationPolicy实例，是RedisSession过期策略。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void cleanExpiredSessions() &#123;</span><br><span class=\"line\">    // 获取当前时间戳</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 时间滚动至整分，去掉秒和毫秒部分</span><br><span class=\"line\">    long prevMin = roundDownMinute(now);</span><br><span class=\"line\">    if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(&quot;Cleaning up sessions expiring at &quot; + new Date(prevMin));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据整分时间获取过期键集合，如：spring:session:expirations:1439245080000</span><br><span class=\"line\">    String expirationKey = getExpirationKey(prevMin);</span><br><span class=\"line\">    // 获取所有的所有的过期session</span><br><span class=\"line\">    Set&lt;Object&gt; sessionsToExpire = this.redis.boundSetOps(expirationKey).members();</span><br><span class=\"line\">    // 删除过期Session键集合</span><br><span class=\"line\">    this.redis.delete(expirationKey);</span><br><span class=\"line\">    // touch访问所有已经过期的session，触发Redis键空间通知消息</span><br><span class=\"line\">    for (Object session : sessionsToExpire) &#123;</span><br><span class=\"line\">        String sessionKey = getSessionKey((String) session);</span><br><span class=\"line\">        touch(sessionKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将时间戳滚动至整分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long roundDownMinute(long timeInMs) &#123;</span><br><span class=\"line\">    Calendar date = Calendar.getInstance();</span><br><span class=\"line\">    date.setTimeInMillis(timeInMs);</span><br><span class=\"line\">    // 清理时间错的秒位和毫秒位</span><br><span class=\"line\">    date.clear(Calendar.SECOND);</span><br><span class=\"line\">    date.clear(Calendar.MILLISECOND);</span><br><span class=\"line\">    return date.getTimeInMillis();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取过期Session的集合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String getExpirationKey(long expires) &#123;</span><br><span class=\"line\">    return this.redisSession.getExpirationsKey(expires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如：spring:session:expirations:1439245080000</span><br><span class=\"line\">String getExpirationsKey(long expiration) &#123;</span><br><span class=\"line\">    return this.keyPrefix + &quot;expirations:&quot; + expiration;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用Redis的Exists命令，访问过期Session键，触发Redis键空间消息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * By trying to access the session we only trigger a deletion if it the TTL is</span><br><span class=\"line\"> * expired. This is done to handle</span><br><span class=\"line\"> * https://github.com/spring-projects/spring-session/issues/93</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param key the key</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void touch(String key) &#123;</span><br><span class=\"line\">    this.redis.hasKey(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总结<br>至此Spring-Session的Session事件通知模块就已经很清晰：</p>\n<ul>\n<li>Redis键空间Session事件源：Session创建通道/Session删除通道/Session过期通道</li>\n<li>Spring-Session中的RedisOperationsSessionRepository消息监听器监听Redis的事件类型</li>\n<li>RedisOperationsSessionRepository负责将其传播至ApplicationEventPublisher</li>\n<li>ApplicationEventPublisher将其包装成ApplicationEvent类型的Session Event发布</li>\n<li>ApplicationListener监听Session Event，处理相应逻辑</li>\n</ul>\n"},{"title":"docker -mysql","author":"wen","date":"2018-05-08T09:28:00.000Z","_content":"\n参考：\n[安装docker](/2018/05/08/（四）安装docker（root用户）/)\n\n# 下载镜像\n```\ndocker pull mysql\n```\n# 运行镜像\n```\ndocker run --name mysql -p 3306:3306 -v /app/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql\n```\n\n# 进入mysql进行设置\n```\ndocker ps -a  --获取mysql 容器的id\n\ndocker exec -it 容器id sh\n```\n\n# 进入Mysql后登录mysql\n```\nmysql -uroot -proot\n\n若报root@localhost,请试试mysql -uroot\n```\n# 创建数据库用户\n```\ncreate USER springcloud IDENTIFIED WITH mysql_native_password BY '123456';\n\ngrant all privileges on *.* to springcloud;\n\ncreate database springclouddb\n```\n\n# 报错信息\n若show databases 报错 \n若是 缺没有此mysql.infoschema用户\n则执行以下sql\n```\ncreate USER 'mysql.infoschema' IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER 'mysql.session' IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER 'mysql.sys'  IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER springcloud IDENTIFIED WITH mysql_native_password BY '123456';\n\ngrant all privileges on *.* to 'mysql.infoschema';\n\ngrant all privileges on *.* to 'mysql.session';\n\ngrant all privileges on *.* to 'mysql.sys';\n```","source":"_posts/ocker-mysql.md","raw":"title: docker -mysql\nauthor: wen\ntags:\n  - docker\n  - mysql\ncategories: []\ndate: 2018-05-08 17:28:00\n---\n\n参考：\n[安装docker](/2018/05/08/（四）安装docker（root用户）/)\n\n# 下载镜像\n```\ndocker pull mysql\n```\n# 运行镜像\n```\ndocker run --name mysql -p 3306:3306 -v /app/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql\n```\n\n# 进入mysql进行设置\n```\ndocker ps -a  --获取mysql 容器的id\n\ndocker exec -it 容器id sh\n```\n\n# 进入Mysql后登录mysql\n```\nmysql -uroot -proot\n\n若报root@localhost,请试试mysql -uroot\n```\n# 创建数据库用户\n```\ncreate USER springcloud IDENTIFIED WITH mysql_native_password BY '123456';\n\ngrant all privileges on *.* to springcloud;\n\ncreate database springclouddb\n```\n\n# 报错信息\n若show databases 报错 \n若是 缺没有此mysql.infoschema用户\n则执行以下sql\n```\ncreate USER 'mysql.infoschema' IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER 'mysql.session' IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER 'mysql.sys'  IDENTIFIED WITH mysql_native_password BY '123456';\n\ncreate USER springcloud IDENTIFIED WITH mysql_native_password BY '123456';\n\ngrant all privileges on *.* to 'mysql.infoschema';\n\ngrant all privileges on *.* to 'mysql.session';\n\ngrant all privileges on *.* to 'mysql.sys';\n```","slug":"ocker-mysql","published":1,"updated":"2019-05-05T02:41:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38g001mn6zq3q37n7iq","content":"<p>参考：<br><a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker</a></p>\n<h1 id=\"下载镜像\"><a href=\"#下载镜像\" class=\"headerlink\" title=\"下载镜像\"></a>下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql</span><br></pre></td></tr></table></figure>\n<h1 id=\"运行镜像\"><a href=\"#运行镜像\" class=\"headerlink\" title=\"运行镜像\"></a>运行镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name mysql -p 3306:3306 -v /app/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure>\n<h1 id=\"进入mysql进行设置\"><a href=\"#进入mysql进行设置\" class=\"headerlink\" title=\"进入mysql进行设置\"></a>进入mysql进行设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a  --获取mysql 容器的id</span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it 容器id sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"进入Mysql后登录mysql\"><a href=\"#进入Mysql后登录mysql\" class=\"headerlink\" title=\"进入Mysql后登录mysql\"></a>进入Mysql后登录mysql</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -proot</span><br><span class=\"line\"></span><br><span class=\"line\">若报root@localhost,请试试mysql -uroot</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建数据库用户\"><a href=\"#创建数据库用户\" class=\"headerlink\" title=\"创建数据库用户\"></a>创建数据库用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create USER springcloud IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to springcloud;</span><br><span class=\"line\"></span><br><span class=\"line\">create database springclouddb</span><br></pre></td></tr></table></figure>\n<h1 id=\"报错信息\"><a href=\"#报错信息\" class=\"headerlink\" title=\"报错信息\"></a>报错信息</h1><p>若show databases 报错<br>若是 缺没有此mysql.infoschema用户<br>则执行以下sql<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create USER &apos;mysql.infoschema&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER &apos;mysql.session&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER &apos;mysql.sys&apos;  IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER springcloud IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.infoschema&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.session&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.sys&apos;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<br><a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker</a></p>\n<h1 id=\"下载镜像\"><a href=\"#下载镜像\" class=\"headerlink\" title=\"下载镜像\"></a>下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql</span><br></pre></td></tr></table></figure>\n<h1 id=\"运行镜像\"><a href=\"#运行镜像\" class=\"headerlink\" title=\"运行镜像\"></a>运行镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name mysql -p 3306:3306 -v /app/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure>\n<h1 id=\"进入mysql进行设置\"><a href=\"#进入mysql进行设置\" class=\"headerlink\" title=\"进入mysql进行设置\"></a>进入mysql进行设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a  --获取mysql 容器的id</span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it 容器id sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"进入Mysql后登录mysql\"><a href=\"#进入Mysql后登录mysql\" class=\"headerlink\" title=\"进入Mysql后登录mysql\"></a>进入Mysql后登录mysql</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -proot</span><br><span class=\"line\"></span><br><span class=\"line\">若报root@localhost,请试试mysql -uroot</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建数据库用户\"><a href=\"#创建数据库用户\" class=\"headerlink\" title=\"创建数据库用户\"></a>创建数据库用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create USER springcloud IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to springcloud;</span><br><span class=\"line\"></span><br><span class=\"line\">create database springclouddb</span><br></pre></td></tr></table></figure>\n<h1 id=\"报错信息\"><a href=\"#报错信息\" class=\"headerlink\" title=\"报错信息\"></a>报错信息</h1><p>若show databases 报错<br>若是 缺没有此mysql.infoschema用户<br>则执行以下sql<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create USER &apos;mysql.infoschema&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER &apos;mysql.session&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER &apos;mysql.sys&apos;  IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create USER springcloud IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.infoschema&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.session&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to &apos;mysql.sys&apos;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"spring config bus","author":"wen","date":"2019-05-29T09:06:00.000Z","_content":"config pom.xml\n```\n <dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t\t</dependency>\n        <dependency>\n```\n/configuration/src/main/resources/application-native.properties\n```\nspring.cloud.bus.enabled=true\nspring.cloud.bus.trace.enabled=true\nspring.rabbitmq.addresses=${RABBITMQ_ADDRESS}\nspring.rabbitmq.username=${RABBITMQ_USERNAME}\nspring.rabbitmq.password=${RABBITMQ_PASSWORD}\nspring.rabbitmq.virtual-host=${RABBITMQ_VIRTUAL_HOST}\n## \\u5237\\u65B0\\u65F6\\uFF0C\\u5173\\u95ED\\u5B89\\u5168\\u9A8C\\u8BC1\nmanagement.security.enabled=false\nmanagement.endpoints.web.exposure.include=bus-refresh\n```\n\n刷新链接：\nhttp://ip:6081/actuator/bus-refresh\n\n\n客户端\npom.xml\n```\n<dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId></dependency>\n```\nHelloController\n```\n@RestController\n@RefreshScope\n// 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中。\nclass HelloController {\n\n    @Value(\"${business.wx.appid}\")\n    private String hello;\n\n    @RequestMapping(\"/hello\")\n    public String from() {\n        return this.hello;\n    }\n}\n```\n\n配置\n```\n######## bus-amqp\n## 刷新时，关闭安全验证\nmanagement.security.enabled=false\nmanagement.endpoints.web.exposure.include=bus-refresh\n## 开启消息跟踪\nspring.cloud.bus.enabled=true\nspring.cloud.bus.trace.enabled=true\n#mq的地址\nspring.rabbitmq.addresses=\n#mq的用户名\nspring.rabbitmq.username=\n#mq的密码\nspring.rabbitmq.password=\nspring.rabbitmq.publisherConfirms=false\nspring.rabbitmq.publisherReturns=false\nspring.rabbitmq.virtual-host=/\n\n```\n\n测试连接\n测试入口：http://ip:port/hello","source":"_posts/ring-config-bus.md","raw":"title: spring config bus\nauthor: wen\ntags:\n  - spring config\n  - spring cloud\ncategories:\n  - spring cloud\ndate: 2019-05-29 17:06:00\n---\nconfig pom.xml\n```\n <dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t\t</dependency>\n        <dependency>\n```\n/configuration/src/main/resources/application-native.properties\n```\nspring.cloud.bus.enabled=true\nspring.cloud.bus.trace.enabled=true\nspring.rabbitmq.addresses=${RABBITMQ_ADDRESS}\nspring.rabbitmq.username=${RABBITMQ_USERNAME}\nspring.rabbitmq.password=${RABBITMQ_PASSWORD}\nspring.rabbitmq.virtual-host=${RABBITMQ_VIRTUAL_HOST}\n## \\u5237\\u65B0\\u65F6\\uFF0C\\u5173\\u95ED\\u5B89\\u5168\\u9A8C\\u8BC1\nmanagement.security.enabled=false\nmanagement.endpoints.web.exposure.include=bus-refresh\n```\n\n刷新链接：\nhttp://ip:6081/actuator/bus-refresh\n\n\n客户端\npom.xml\n```\n<dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId></dependency>\n```\nHelloController\n```\n@RestController\n@RefreshScope\n// 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中。\nclass HelloController {\n\n    @Value(\"${business.wx.appid}\")\n    private String hello;\n\n    @RequestMapping(\"/hello\")\n    public String from() {\n        return this.hello;\n    }\n}\n```\n\n配置\n```\n######## bus-amqp\n## 刷新时，关闭安全验证\nmanagement.security.enabled=false\nmanagement.endpoints.web.exposure.include=bus-refresh\n## 开启消息跟踪\nspring.cloud.bus.enabled=true\nspring.cloud.bus.trace.enabled=true\n#mq的地址\nspring.rabbitmq.addresses=\n#mq的用户名\nspring.rabbitmq.username=\n#mq的密码\nspring.rabbitmq.password=\nspring.rabbitmq.publisherConfirms=false\nspring.rabbitmq.publisherReturns=false\nspring.rabbitmq.virtual-host=/\n\n```\n\n测试连接\n测试入口：http://ip:port/hello","slug":"ring-config-bus","published":1,"updated":"2019-06-09T15:13:13.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38h001on6zqt6h4y34c","content":"<p>config pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">       &lt;dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>/configuration/src/main/resources/application-native.properties<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.cloud.bus.enabled=true</span><br><span class=\"line\">spring.cloud.bus.trace.enabled=true</span><br><span class=\"line\">spring.rabbitmq.addresses=$&#123;RABBITMQ_ADDRESS&#125;</span><br><span class=\"line\">spring.rabbitmq.username=$&#123;RABBITMQ_USERNAME&#125;</span><br><span class=\"line\">spring.rabbitmq.password=$&#123;RABBITMQ_PASSWORD&#125;</span><br><span class=\"line\">spring.rabbitmq.virtual-host=$&#123;RABBITMQ_VIRTUAL_HOST&#125;</span><br><span class=\"line\">## \\u5237\\u65B0\\u65F6\\uFF0C\\u5173\\u95ED\\u5B89\\u5168\\u9A8C\\u8BC1</span><br><span class=\"line\">management.security.enabled=false</span><br><span class=\"line\">management.endpoints.web.exposure.include=bus-refresh</span><br></pre></td></tr></table></figure></p>\n<p>刷新链接：<br><a href=\"http://ip:6081/actuator/bus-refresh\" target=\"_blank\" rel=\"noopener\">http://ip:6081/actuator/bus-refresh</a></p>\n<p>客户端<br>pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>HelloController<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">@RefreshScope</span><br><span class=\"line\">// 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中。</span><br><span class=\"line\">class HelloController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;business.wx.appid&#125;&quot;)</span><br><span class=\"line\">    private String hello;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/hello&quot;)</span><br><span class=\"line\">    public String from() &#123;</span><br><span class=\"line\">        return this.hello;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">######## bus-amqp</span><br><span class=\"line\">## 刷新时，关闭安全验证</span><br><span class=\"line\">management.security.enabled=false</span><br><span class=\"line\">management.endpoints.web.exposure.include=bus-refresh</span><br><span class=\"line\">## 开启消息跟踪</span><br><span class=\"line\">spring.cloud.bus.enabled=true</span><br><span class=\"line\">spring.cloud.bus.trace.enabled=true</span><br><span class=\"line\">#mq的地址</span><br><span class=\"line\">spring.rabbitmq.addresses=</span><br><span class=\"line\">#mq的用户名</span><br><span class=\"line\">spring.rabbitmq.username=</span><br><span class=\"line\">#mq的密码</span><br><span class=\"line\">spring.rabbitmq.password=</span><br><span class=\"line\">spring.rabbitmq.publisherConfirms=false</span><br><span class=\"line\">spring.rabbitmq.publisherReturns=false</span><br><span class=\"line\">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></p>\n<p>测试连接<br>测试入口：<a href=\"http://ip:port/hello\" target=\"_blank\" rel=\"noopener\">http://ip:port/hello</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>config pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">       &lt;dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>/configuration/src/main/resources/application-native.properties<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.cloud.bus.enabled=true</span><br><span class=\"line\">spring.cloud.bus.trace.enabled=true</span><br><span class=\"line\">spring.rabbitmq.addresses=$&#123;RABBITMQ_ADDRESS&#125;</span><br><span class=\"line\">spring.rabbitmq.username=$&#123;RABBITMQ_USERNAME&#125;</span><br><span class=\"line\">spring.rabbitmq.password=$&#123;RABBITMQ_PASSWORD&#125;</span><br><span class=\"line\">spring.rabbitmq.virtual-host=$&#123;RABBITMQ_VIRTUAL_HOST&#125;</span><br><span class=\"line\">## \\u5237\\u65B0\\u65F6\\uFF0C\\u5173\\u95ED\\u5B89\\u5168\\u9A8C\\u8BC1</span><br><span class=\"line\">management.security.enabled=false</span><br><span class=\"line\">management.endpoints.web.exposure.include=bus-refresh</span><br></pre></td></tr></table></figure></p>\n<p>刷新链接：<br><a href=\"http://ip:6081/actuator/bus-refresh\" target=\"_blank\" rel=\"noopener\">http://ip:6081/actuator/bus-refresh</a></p>\n<p>客户端<br>pom.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>HelloController<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">@RefreshScope</span><br><span class=\"line\">// 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中。</span><br><span class=\"line\">class HelloController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;business.wx.appid&#125;&quot;)</span><br><span class=\"line\">    private String hello;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/hello&quot;)</span><br><span class=\"line\">    public String from() &#123;</span><br><span class=\"line\">        return this.hello;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">######## bus-amqp</span><br><span class=\"line\">## 刷新时，关闭安全验证</span><br><span class=\"line\">management.security.enabled=false</span><br><span class=\"line\">management.endpoints.web.exposure.include=bus-refresh</span><br><span class=\"line\">## 开启消息跟踪</span><br><span class=\"line\">spring.cloud.bus.enabled=true</span><br><span class=\"line\">spring.cloud.bus.trace.enabled=true</span><br><span class=\"line\">#mq的地址</span><br><span class=\"line\">spring.rabbitmq.addresses=</span><br><span class=\"line\">#mq的用户名</span><br><span class=\"line\">spring.rabbitmq.username=</span><br><span class=\"line\">#mq的密码</span><br><span class=\"line\">spring.rabbitmq.password=</span><br><span class=\"line\">spring.rabbitmq.publisherConfirms=false</span><br><span class=\"line\">spring.rabbitmq.publisherReturns=false</span><br><span class=\"line\">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></p>\n<p>测试连接<br>测试入口：<a href=\"http://ip:port/hello\" target=\"_blank\" rel=\"noopener\">http://ip:port/hello</a></p>\n"},{"title":"spring session（1）","author":"wen","date":"2019-11-13T03:54:00.000Z","_content":"# 前言\n在开始spring-session揭秘之前，先做下热脑（活动活动脑子）运动。主要从以下三个方面进行热脑：\n\n* 为什么要spring-session\n* 比较traditional-session方案和spring-session方案\n* JSR340规范与spring-session的透明继承\n# 一.为什么要spring-session\n在传统单机web应用中，一般使用tomcat/jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。\n\n但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：\n\n* 需要侵入web容器，提高问题的复杂\n* web容器之间共享session，集群机器之间势必要交互耦合\n基于这些，必须提供新的可靠的集群分布式/集群session的解决方案，突破traditional-session单机限制（即web容器session方式，下面简称traditional-session），spring-session应用而生。\n\n# 二.比较traditional-session方案和spring-session方案\n\n下图展示了traditional-session和spring-session的区别\n\n![logo](ring-session（1）/1.png)\n传统模式中，当request进入web容器，根据reqest获取session时，如果web容器中存在session则返回，如果不存在，web容器则创建一个session。然后返回response时，将sessonId作为response的head一并返回给客户端或者浏览器。\n\n但是上节中说明了traditional-session的局限性在于：单机session。在此限制的相反面，即将session从web容器中抽出来，形成独立的模块，以便分布式应用或者集群都能共享，即能解决。\n\nspring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。\n\n# JSR340规范与spring-session的透明继承\n\nJSR340是Java Servlet 3.1的规范提案，其中定义了大量的api，包括：servlet、servletRequest/HttpServletRequest/HttpServletRequestWrapper、servletResponse/HttpServletResponse/HttpServletResponseWrapper、Filter、Session等，是标准的web容器需要遵循的规约，如tomcat/jetty/weblogic等等。\n\n在日常的应用开发中，develpers也在频繁的使用servlet-api，比如：\n\n以下的方式获取请求的session：\n```\nHttpServletRequest request = ...\nHttpSession session = request.getSession(false);\n```\n其中HttpServletRequest和HttpSession都是servlet规范中定义的接口，web容器实现的标准。那如果引入spring-session，要如何获取session？\n\n* 遵循servlet规范，同样方式获取session，对应用代码无侵入且对于developers透明化\n* 全新实现一套session规范，定义一套新的api和session管理机制\n两种方案都可以实现，但是显然第一种更友好，且具有兼容性。spring-session正是第一种方案的实现。\n\n实现第一种方案的关键点在于做到透明和兼容\n\n接口适配：仍然使用HttpServletRequest获取session，获取到的session仍然是HttpSession类型——适配器模式\n类型包装增强：Session不能存储在web容器内，要外化存储——装饰模式\n让人兴奋的是，以上的需求在Servlet规范中的扩展性都是予以支持！Servlet规范中定义一系列的接口都是支持扩展，同时提供Filter支撑扩展点。\n\n# spring session入门\n主要从以下两个方面来说spring-session：\n\n* 特点\n* 工作原理\n## 一.特点\nspring-session在无需绑定web容器的情况下提供对集群session的支持。并提供对以下情况的透明集成：\n\n* HttpSession：容许替换web容器的HttpSession\n* WebSocket：使用WebSocket通信时，提供Session的活跃\n* WebSession：容许以应用中立的方式替换webflux的webSession\n\n下面以项目接入spring session redis为例\n# spring 项目\n引入spring session的jar\n代码：https://github.com/smallwenzi/testSpringSession\n## 引入:\n```\n <dependency>\n\t    \t<groupId>org.springframework.session</groupId>\n\t    \t<artifactId>spring-session</artifactId>\n\t    \t<version>1.3.0.RELEASE</version>\n\t\t</dependency>\n          <dependency>\n\t    \t<groupId>org.springframework.session</groupId>\n\t    \t<artifactId>spring-session</artifactId>\n\t    \t<version>1.3.0.RELEASE</version>\n\t\t</dependency>\n\t\t\n\t\t<!-- Spring session redis 依赖start -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.session</groupId>\n\t\t\t<artifactId>spring-session-data-redis</artifactId>\n\t\t\t<version>1.2.0.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>org.springframework.data</groupId>\n\t\t    <artifactId>spring-data-redis</artifactId>\n\t\t    <version>1.6.0.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>redis.clients</groupId>\n\t\t    <artifactId>jedis</artifactId>\n\t\t    <version>2.9.0</version>\n\t\t</dependency>\n```\n## 配置redis\napplicationContext.xml\n```\n   <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n       <property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n   </bean>   \n    <bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n        <property name=\"hostName\" value=\"${redis.hostName}\" />\n        <property name=\"port\" value=\"${redis.port}\" />\n        <property name=\"password\" value=\"${redis.password}\" />\n        <property name=\"usePool\" value=\"${redis.usePool}\" />\n        <property name=\"timeout\" value=\"${redis.timeout}\" />\n    </bean>\n```\nredis.properties（自行更改redis 配置）\n```\nredis.hostName=localhost\nredis.port=6379\nredis.password=\nredis.usePool=true\nredis.timeout=10000\n\n```\n\n## 开启spring session\n```\n@Configuration\n//redisNamespace区分每个项目spring session key唯一\n@EnableRedisHttpSession(redisNamespace = \"testSpringSession\")\npublic class SpringSessionHttpConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);\n\n\n    @Value(\"${redis.taskexecutor.corepoolsize}\")\n    private String corepoolsize;\n\n    @Value(\"${redis.taskexecutor.maxpoolsize}\")\n    private String maxpoolsize;\n\n    @Value(\"${redis.taskexecutor.keepaliveseconds}\")\n    private String keepaliveseconds;\n\n    @Value(\"${redis.taskexecutor.queuecapacity}\")\n    private String queuecapacity;\n\n    @Value(\"${redis.taskexecutor.threadnameprefix}\")\n    private String threadnameprefix;\n\n//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里test.properties\n    @Bean\n    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() {\n        logger.info(\"JedisPool注入成功！！\");\n        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();\n        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));\n        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));\n        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));\n        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));\n        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);\n        return springSessionRedisTaskExecutor;\n    }\n\n    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) {\n        try {\n            int sizeInt = Integer.parseInt(size);\n            return sizeInt;\n        } catch (Exception e) {\n            return defaultSize;\n        }\n    }\n```\n## web.xml\n```\n  <filter>\n  <!-- 必须这样命名 SpringHttpSessionConfiguration类中定义了springSessionRepositoryFilter类 -->\n\t<filter-name>springSessionRepositoryFilter</filter-name>\n\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\t\n  </filter>\n  <filter-mapping>\n\t<filter-name>springSessionRepositoryFilter</filter-name>\n    <!-- 需要spring session的访问路径 -->\n\t<url-pattern>/*</url-pattern> \n  </filter-mapping>\n\n```\n本地分别部署tomcat 进行测试http://localhost:8082/testSpringSession/testSession.do\nhttp://localhost:8080/testSpringSession/testSession.do\n输出的session id是否一致\n若一致则spring session成功\n\n\n# spring boot项目\n项目：https://github.com/smallwenzi/testSpringBootSession\n## 引入jar\n```\n\t           <dependency>\n\t    <groupId>org.springframework.session</groupId>\n\t    <artifactId>spring-session</artifactId>\n\t   </dependency>\n\t   \t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n\t </dependencies>\n```\n## 开启springsession\n```\n//redisNamespace区分每个项目spring session key唯一\n@EnableRedisHttpSession(redisNamespace = \"testSpringBootSession\")\npublic class SpringSessionHttpConfig {\n    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);\n    @Value(\"${redis.taskexecutor.corepoolsize}\")\n    private String corepoolsize;\n\n    @Value(\"${redis.taskexecutor.maxpoolsize}\")\n    private String maxpoolsize;\n\n    @Value(\"${redis.taskexecutor.keepaliveseconds}\")\n    private String keepaliveseconds;\n\n    @Value(\"${redis.taskexecutor.queuecapacity}\")\n    private String queuecapacity;\n\n    @Value(\"${redis.taskexecutor.threadnameprefix}\")\n    private String threadnameprefix;\n\n//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里application.properties\n    @Bean\n    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() {\n        logger.info(\"JedisPool注入成功！！\");\n        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();\n        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));\n        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));\n        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));\n        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));\n        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);\n        return springSessionRedisTaskExecutor;\n    }\n\n    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) {\n        try {\n            int sizeInt = Integer.parseInt(size);\n            return sizeInt;\n        } catch (Exception e) {\n            return defaultSize;\n        }\n    }\n}\n\n```\n## application.properties\n```\n#本地测试设置随机端口 （自行更改redis 配置）\nserver.port=0\n# redis start\n#spring.redis.database=0\nspring.redis.password=\nspring.redis.pool.max-idle=10\nspring.redis.pool.min-idle=0\nspring.redis.pool.max-active=100\nspring.redis.pool.max-wait=1000\nspring.redis.database=0\n# Redis\\u670D\\u52A1\\u5668\\u5730\\u5740\nspring.redis.host=localhost\n# Redis\\u670D\\u52A1\\u5668\\u8FDE\\u63A5\\u7AEF\\u53E3\nspring.redis.port=6379\n\n# redis end\n#spring session\\u4f7f\\u7528\\u5b58\\u50a8\\u7c7b\\u578b\nspring.session.store-type=redis\n\n##spring-session redis \\u7ebf\\u7a0b\\u6c60\\u914d\\u7f6e\nredis.taskexecutor.corepoolsize=16\nredis.taskexecutor.maxpoolsize=300\nredis.taskexecutor.keepaliveseconds=30\nredis.taskexecutor.queuecapacity=500\nredis.taskexecutor.threadnameprefix=testSpringBootSession-spring-session-redis-executor-thread:\n\n```\n本地分别启动 WebApplication进行测试http://localhost:port/testSession\nhttp://localhost:port/\ntestSession\n输出的session id是否一致\n若一致则spring session成功\n\n有兴趣可以读[《spring sesson源码》](https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/ \"《spring sesson源码》\")","source":"_posts/ring-session（1）.md","raw":"title: spring session（1）\nauthor: wen\ntags:\n  - spring\n  - session\ncategories:\n  - Spring\n  - Spring boot\ndate: 2019-11-13 11:54:00\n---\n# 前言\n在开始spring-session揭秘之前，先做下热脑（活动活动脑子）运动。主要从以下三个方面进行热脑：\n\n* 为什么要spring-session\n* 比较traditional-session方案和spring-session方案\n* JSR340规范与spring-session的透明继承\n# 一.为什么要spring-session\n在传统单机web应用中，一般使用tomcat/jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。\n\n但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：\n\n* 需要侵入web容器，提高问题的复杂\n* web容器之间共享session，集群机器之间势必要交互耦合\n基于这些，必须提供新的可靠的集群分布式/集群session的解决方案，突破traditional-session单机限制（即web容器session方式，下面简称traditional-session），spring-session应用而生。\n\n# 二.比较traditional-session方案和spring-session方案\n\n下图展示了traditional-session和spring-session的区别\n\n![logo](ring-session（1）/1.png)\n传统模式中，当request进入web容器，根据reqest获取session时，如果web容器中存在session则返回，如果不存在，web容器则创建一个session。然后返回response时，将sessonId作为response的head一并返回给客户端或者浏览器。\n\n但是上节中说明了traditional-session的局限性在于：单机session。在此限制的相反面，即将session从web容器中抽出来，形成独立的模块，以便分布式应用或者集群都能共享，即能解决。\n\nspring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。\n\n# JSR340规范与spring-session的透明继承\n\nJSR340是Java Servlet 3.1的规范提案，其中定义了大量的api，包括：servlet、servletRequest/HttpServletRequest/HttpServletRequestWrapper、servletResponse/HttpServletResponse/HttpServletResponseWrapper、Filter、Session等，是标准的web容器需要遵循的规约，如tomcat/jetty/weblogic等等。\n\n在日常的应用开发中，develpers也在频繁的使用servlet-api，比如：\n\n以下的方式获取请求的session：\n```\nHttpServletRequest request = ...\nHttpSession session = request.getSession(false);\n```\n其中HttpServletRequest和HttpSession都是servlet规范中定义的接口，web容器实现的标准。那如果引入spring-session，要如何获取session？\n\n* 遵循servlet规范，同样方式获取session，对应用代码无侵入且对于developers透明化\n* 全新实现一套session规范，定义一套新的api和session管理机制\n两种方案都可以实现，但是显然第一种更友好，且具有兼容性。spring-session正是第一种方案的实现。\n\n实现第一种方案的关键点在于做到透明和兼容\n\n接口适配：仍然使用HttpServletRequest获取session，获取到的session仍然是HttpSession类型——适配器模式\n类型包装增强：Session不能存储在web容器内，要外化存储——装饰模式\n让人兴奋的是，以上的需求在Servlet规范中的扩展性都是予以支持！Servlet规范中定义一系列的接口都是支持扩展，同时提供Filter支撑扩展点。\n\n# spring session入门\n主要从以下两个方面来说spring-session：\n\n* 特点\n* 工作原理\n## 一.特点\nspring-session在无需绑定web容器的情况下提供对集群session的支持。并提供对以下情况的透明集成：\n\n* HttpSession：容许替换web容器的HttpSession\n* WebSocket：使用WebSocket通信时，提供Session的活跃\n* WebSession：容许以应用中立的方式替换webflux的webSession\n\n下面以项目接入spring session redis为例\n# spring 项目\n引入spring session的jar\n代码：https://github.com/smallwenzi/testSpringSession\n## 引入:\n```\n <dependency>\n\t    \t<groupId>org.springframework.session</groupId>\n\t    \t<artifactId>spring-session</artifactId>\n\t    \t<version>1.3.0.RELEASE</version>\n\t\t</dependency>\n          <dependency>\n\t    \t<groupId>org.springframework.session</groupId>\n\t    \t<artifactId>spring-session</artifactId>\n\t    \t<version>1.3.0.RELEASE</version>\n\t\t</dependency>\n\t\t\n\t\t<!-- Spring session redis 依赖start -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.session</groupId>\n\t\t\t<artifactId>spring-session-data-redis</artifactId>\n\t\t\t<version>1.2.0.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>org.springframework.data</groupId>\n\t\t    <artifactId>spring-data-redis</artifactId>\n\t\t    <version>1.6.0.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>redis.clients</groupId>\n\t\t    <artifactId>jedis</artifactId>\n\t\t    <version>2.9.0</version>\n\t\t</dependency>\n```\n## 配置redis\napplicationContext.xml\n```\n   <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n       <property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n   </bean>   \n    <bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n        <property name=\"hostName\" value=\"${redis.hostName}\" />\n        <property name=\"port\" value=\"${redis.port}\" />\n        <property name=\"password\" value=\"${redis.password}\" />\n        <property name=\"usePool\" value=\"${redis.usePool}\" />\n        <property name=\"timeout\" value=\"${redis.timeout}\" />\n    </bean>\n```\nredis.properties（自行更改redis 配置）\n```\nredis.hostName=localhost\nredis.port=6379\nredis.password=\nredis.usePool=true\nredis.timeout=10000\n\n```\n\n## 开启spring session\n```\n@Configuration\n//redisNamespace区分每个项目spring session key唯一\n@EnableRedisHttpSession(redisNamespace = \"testSpringSession\")\npublic class SpringSessionHttpConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);\n\n\n    @Value(\"${redis.taskexecutor.corepoolsize}\")\n    private String corepoolsize;\n\n    @Value(\"${redis.taskexecutor.maxpoolsize}\")\n    private String maxpoolsize;\n\n    @Value(\"${redis.taskexecutor.keepaliveseconds}\")\n    private String keepaliveseconds;\n\n    @Value(\"${redis.taskexecutor.queuecapacity}\")\n    private String queuecapacity;\n\n    @Value(\"${redis.taskexecutor.threadnameprefix}\")\n    private String threadnameprefix;\n\n//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里test.properties\n    @Bean\n    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() {\n        logger.info(\"JedisPool注入成功！！\");\n        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();\n        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));\n        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));\n        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));\n        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));\n        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);\n        return springSessionRedisTaskExecutor;\n    }\n\n    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) {\n        try {\n            int sizeInt = Integer.parseInt(size);\n            return sizeInt;\n        } catch (Exception e) {\n            return defaultSize;\n        }\n    }\n```\n## web.xml\n```\n  <filter>\n  <!-- 必须这样命名 SpringHttpSessionConfiguration类中定义了springSessionRepositoryFilter类 -->\n\t<filter-name>springSessionRepositoryFilter</filter-name>\n\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\t\n  </filter>\n  <filter-mapping>\n\t<filter-name>springSessionRepositoryFilter</filter-name>\n    <!-- 需要spring session的访问路径 -->\n\t<url-pattern>/*</url-pattern> \n  </filter-mapping>\n\n```\n本地分别部署tomcat 进行测试http://localhost:8082/testSpringSession/testSession.do\nhttp://localhost:8080/testSpringSession/testSession.do\n输出的session id是否一致\n若一致则spring session成功\n\n\n# spring boot项目\n项目：https://github.com/smallwenzi/testSpringBootSession\n## 引入jar\n```\n\t           <dependency>\n\t    <groupId>org.springframework.session</groupId>\n\t    <artifactId>spring-session</artifactId>\n\t   </dependency>\n\t   \t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n\t </dependencies>\n```\n## 开启springsession\n```\n//redisNamespace区分每个项目spring session key唯一\n@EnableRedisHttpSession(redisNamespace = \"testSpringBootSession\")\npublic class SpringSessionHttpConfig {\n    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);\n    @Value(\"${redis.taskexecutor.corepoolsize}\")\n    private String corepoolsize;\n\n    @Value(\"${redis.taskexecutor.maxpoolsize}\")\n    private String maxpoolsize;\n\n    @Value(\"${redis.taskexecutor.keepaliveseconds}\")\n    private String keepaliveseconds;\n\n    @Value(\"${redis.taskexecutor.queuecapacity}\")\n    private String queuecapacity;\n\n    @Value(\"${redis.taskexecutor.threadnameprefix}\")\n    private String threadnameprefix;\n\n//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里application.properties\n    @Bean\n    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() {\n        logger.info(\"JedisPool注入成功！！\");\n        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();\n        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));\n        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));\n        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));\n        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));\n        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);\n        return springSessionRedisTaskExecutor;\n    }\n\n    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) {\n        try {\n            int sizeInt = Integer.parseInt(size);\n            return sizeInt;\n        } catch (Exception e) {\n            return defaultSize;\n        }\n    }\n}\n\n```\n## application.properties\n```\n#本地测试设置随机端口 （自行更改redis 配置）\nserver.port=0\n# redis start\n#spring.redis.database=0\nspring.redis.password=\nspring.redis.pool.max-idle=10\nspring.redis.pool.min-idle=0\nspring.redis.pool.max-active=100\nspring.redis.pool.max-wait=1000\nspring.redis.database=0\n# Redis\\u670D\\u52A1\\u5668\\u5730\\u5740\nspring.redis.host=localhost\n# Redis\\u670D\\u52A1\\u5668\\u8FDE\\u63A5\\u7AEF\\u53E3\nspring.redis.port=6379\n\n# redis end\n#spring session\\u4f7f\\u7528\\u5b58\\u50a8\\u7c7b\\u578b\nspring.session.store-type=redis\n\n##spring-session redis \\u7ebf\\u7a0b\\u6c60\\u914d\\u7f6e\nredis.taskexecutor.corepoolsize=16\nredis.taskexecutor.maxpoolsize=300\nredis.taskexecutor.keepaliveseconds=30\nredis.taskexecutor.queuecapacity=500\nredis.taskexecutor.threadnameprefix=testSpringBootSession-spring-session-redis-executor-thread:\n\n```\n本地分别启动 WebApplication进行测试http://localhost:port/testSession\nhttp://localhost:port/\ntestSession\n输出的session id是否一致\n若一致则spring session成功\n\n有兴趣可以读[《spring sesson源码》](https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/ \"《spring sesson源码》\")","slug":"ring-session（1）","published":1,"updated":"2020-02-17T15:08:47.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38k001tn6zqz3ttmd0r","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开始spring-session揭秘之前，先做下热脑（活动活动脑子）运动。主要从以下三个方面进行热脑：</p>\n<ul>\n<li>为什么要spring-session</li>\n<li>比较traditional-session方案和spring-session方案</li>\n<li>JSR340规范与spring-session的透明继承<h1 id=\"一-为什么要spring-session\"><a href=\"#一-为什么要spring-session\" class=\"headerlink\" title=\"一.为什么要spring-session\"></a>一.为什么要spring-session</h1>在传统单机web应用中，一般使用tomcat/jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。</li>\n</ul>\n<p>但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：</p>\n<ul>\n<li>需要侵入web容器，提高问题的复杂</li>\n<li>web容器之间共享session，集群机器之间势必要交互耦合<br>基于这些，必须提供新的可靠的集群分布式/集群session的解决方案，突破traditional-session单机限制（即web容器session方式，下面简称traditional-session），spring-session应用而生。</li>\n</ul>\n<h1 id=\"二-比较traditional-session方案和spring-session方案\"><a href=\"#二-比较traditional-session方案和spring-session方案\" class=\"headerlink\" title=\"二.比较traditional-session方案和spring-session方案\"></a>二.比较traditional-session方案和spring-session方案</h1><p>下图展示了traditional-session和spring-session的区别</p>\n<p><img src=\"/2019/11/13/ring-session（1）/1.png\" alt=\"logo\"><br>传统模式中，当request进入web容器，根据reqest获取session时，如果web容器中存在session则返回，如果不存在，web容器则创建一个session。然后返回response时，将sessonId作为response的head一并返回给客户端或者浏览器。</p>\n<p>但是上节中说明了traditional-session的局限性在于：单机session。在此限制的相反面，即将session从web容器中抽出来，形成独立的模块，以便分布式应用或者集群都能共享，即能解决。</p>\n<p>spring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。</p>\n<h1 id=\"JSR340规范与spring-session的透明继承\"><a href=\"#JSR340规范与spring-session的透明继承\" class=\"headerlink\" title=\"JSR340规范与spring-session的透明继承\"></a>JSR340规范与spring-session的透明继承</h1><p>JSR340是Java Servlet 3.1的规范提案，其中定义了大量的api，包括：servlet、servletRequest/HttpServletRequest/HttpServletRequestWrapper、servletResponse/HttpServletResponse/HttpServletResponseWrapper、Filter、Session等，是标准的web容器需要遵循的规约，如tomcat/jetty/weblogic等等。</p>\n<p>在日常的应用开发中，develpers也在频繁的使用servlet-api，比如：</p>\n<p>以下的方式获取请求的session：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest request = ...</span><br><span class=\"line\">HttpSession session = request.getSession(false);</span><br></pre></td></tr></table></figure></p>\n<p>其中HttpServletRequest和HttpSession都是servlet规范中定义的接口，web容器实现的标准。那如果引入spring-session，要如何获取session？</p>\n<ul>\n<li>遵循servlet规范，同样方式获取session，对应用代码无侵入且对于developers透明化</li>\n<li>全新实现一套session规范，定义一套新的api和session管理机制<br>两种方案都可以实现，但是显然第一种更友好，且具有兼容性。spring-session正是第一种方案的实现。</li>\n</ul>\n<p>实现第一种方案的关键点在于做到透明和兼容</p>\n<p>接口适配：仍然使用HttpServletRequest获取session，获取到的session仍然是HttpSession类型——适配器模式<br>类型包装增强：Session不能存储在web容器内，要外化存储——装饰模式<br>让人兴奋的是，以上的需求在Servlet规范中的扩展性都是予以支持！Servlet规范中定义一系列的接口都是支持扩展，同时提供Filter支撑扩展点。</p>\n<h1 id=\"spring-session入门\"><a href=\"#spring-session入门\" class=\"headerlink\" title=\"spring session入门\"></a>spring session入门</h1><p>主要从以下两个方面来说spring-session：</p>\n<ul>\n<li>特点</li>\n<li><p>工作原理</p>\n<h2 id=\"一-特点\"><a href=\"#一-特点\" class=\"headerlink\" title=\"一.特点\"></a>一.特点</h2><p>spring-session在无需绑定web容器的情况下提供对集群session的支持。并提供对以下情况的透明集成：</p>\n</li>\n<li><p>HttpSession：容许替换web容器的HttpSession</p>\n</li>\n<li>WebSocket：使用WebSocket通信时，提供Session的活跃</li>\n<li>WebSession：容许以应用中立的方式替换webflux的webSession</li>\n</ul>\n<p>下面以项目接入spring session redis为例</p>\n<h1 id=\"spring-项目\"><a href=\"#spring-项目\" class=\"headerlink\" title=\"spring 项目\"></a>spring 项目</h1><p>引入spring session的jar<br>代码：<a href=\"https://github.com/smallwenzi/testSpringSession\" target=\"_blank\" rel=\"noopener\">https://github.com/smallwenzi/testSpringSession</a></p>\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入:\"></a>引入:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    \t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">    \t&lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">    \t&lt;version&gt;1.3.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">    \t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">    \t&lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">    \t&lt;version&gt;1.3.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- Spring session redis 依赖start --&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t&lt;version&gt;1.2.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class=\"line\">\t    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">\t    &lt;version&gt;1.6.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">\t    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">\t    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置redis\"><a href=\"#配置redis\" class=\"headerlink\" title=\"配置redis\"></a>配置redis</h2><p>applicationContext.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;   </span><br><span class=\"line\"> &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;</span><br><span class=\"line\">     &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.hostName&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;usePool&quot; value=&quot;$&#123;redis.usePool&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;timeout&quot; value=&quot;$&#123;redis.timeout&#125;&quot; /&gt;</span><br><span class=\"line\"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>\n<p>redis.properties（自行更改redis 配置）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.hostName=localhost</span><br><span class=\"line\">redis.port=6379</span><br><span class=\"line\">redis.password=</span><br><span class=\"line\">redis.usePool=true</span><br><span class=\"line\">redis.timeout=10000</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开启spring-session\"><a href=\"#开启spring-session\" class=\"headerlink\" title=\"开启spring session\"></a>开启spring session</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">//redisNamespace区分每个项目spring session key唯一</span><br><span class=\"line\">@EnableRedisHttpSession(redisNamespace = &quot;testSpringSession&quot;)</span><br><span class=\"line\">public class SpringSessionHttpConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.corepoolsize&#125;&quot;)</span><br><span class=\"line\">    private String corepoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.maxpoolsize&#125;&quot;)</span><br><span class=\"line\">    private String maxpoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.keepaliveseconds&#125;&quot;)</span><br><span class=\"line\">    private String keepaliveseconds;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.queuecapacity&#125;&quot;)</span><br><span class=\"line\">    private String queuecapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.threadnameprefix&#125;&quot;)</span><br><span class=\"line\">    private String threadnameprefix;</span><br><span class=\"line\"></span><br><span class=\"line\">//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里test.properties</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() &#123;</span><br><span class=\"line\">        logger.info(&quot;JedisPool注入成功！！&quot;);</span><br><span class=\"line\">        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);</span><br><span class=\"line\">        return springSessionRedisTaskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            int sizeInt = Integer.parseInt(size);</span><br><span class=\"line\">            return sizeInt;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return defaultSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;filter&gt;</span><br><span class=\"line\"> &lt;!-- 必须这样命名 SpringHttpSessionConfiguration类中定义了springSessionRepositoryFilter类 --&gt;</span><br><span class=\"line\">&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class=\"line\">&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;\t</span><br><span class=\"line\"> &lt;/filter&gt;</span><br><span class=\"line\"> &lt;filter-mapping&gt;</span><br><span class=\"line\">&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class=\"line\">   &lt;!-- 需要spring session的访问路径 --&gt;</span><br><span class=\"line\">&lt;url-pattern&gt;/*&lt;/url-pattern&gt; </span><br><span class=\"line\"> &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>\n<p>本地分别部署tomcat 进行测试<a href=\"http://localhost:8082/testSpringSession/testSession.do\" target=\"_blank\" rel=\"noopener\">http://localhost:8082/testSpringSession/testSession.do</a><br><a href=\"http://localhost:8080/testSpringSession/testSession.do\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/testSpringSession/testSession.do</a><br>输出的session id是否一致<br>若一致则spring session成功</p>\n<h1 id=\"spring-boot项目\"><a href=\"#spring-boot项目\" class=\"headerlink\" title=\"spring boot项目\"></a>spring boot项目</h1><p>项目：<a href=\"https://github.com/smallwenzi/testSpringBootSession\" target=\"_blank\" rel=\"noopener\">https://github.com/smallwenzi/testSpringBootSession</a></p>\n<h2 id=\"引入jar\"><a href=\"#引入jar\" class=\"headerlink\" title=\"引入jar\"></a>引入jar</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          &lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  \t&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启springsession\"><a href=\"#开启springsession\" class=\"headerlink\" title=\"开启springsession\"></a>开启springsession</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//redisNamespace区分每个项目spring session key唯一</span><br><span class=\"line\">@EnableRedisHttpSession(redisNamespace = &quot;testSpringBootSession&quot;)</span><br><span class=\"line\">public class SpringSessionHttpConfig &#123;</span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);</span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.corepoolsize&#125;&quot;)</span><br><span class=\"line\">    private String corepoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.maxpoolsize&#125;&quot;)</span><br><span class=\"line\">    private String maxpoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.keepaliveseconds&#125;&quot;)</span><br><span class=\"line\">    private String keepaliveseconds;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.queuecapacity&#125;&quot;)</span><br><span class=\"line\">    private String queuecapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.threadnameprefix&#125;&quot;)</span><br><span class=\"line\">    private String threadnameprefix;</span><br><span class=\"line\"></span><br><span class=\"line\">//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里application.properties</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() &#123;</span><br><span class=\"line\">        logger.info(&quot;JedisPool注入成功！！&quot;);</span><br><span class=\"line\">        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);</span><br><span class=\"line\">        return springSessionRedisTaskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            int sizeInt = Integer.parseInt(size);</span><br><span class=\"line\">            return sizeInt;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return defaultSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"application-properties\"><a href=\"#application-properties\" class=\"headerlink\" title=\"application.properties\"></a>application.properties</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#本地测试设置随机端口 （自行更改redis 配置）</span><br><span class=\"line\">server.port=0</span><br><span class=\"line\"># redis start</span><br><span class=\"line\">#spring.redis.database=0</span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\">spring.redis.pool.max-idle=10</span><br><span class=\"line\">spring.redis.pool.min-idle=0</span><br><span class=\"line\">spring.redis.pool.max-active=100</span><br><span class=\"line\">spring.redis.pool.max-wait=1000</span><br><span class=\"line\">spring.redis.database=0</span><br><span class=\"line\"># Redis\\u670D\\u52A1\\u5668\\u5730\\u5740</span><br><span class=\"line\">spring.redis.host=localhost</span><br><span class=\"line\"># Redis\\u670D\\u52A1\\u5668\\u8FDE\\u63A5\\u7AEF\\u53E3</span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\"></span><br><span class=\"line\"># redis end</span><br><span class=\"line\">#spring session\\u4f7f\\u7528\\u5b58\\u50a8\\u7c7b\\u578b</span><br><span class=\"line\">spring.session.store-type=redis</span><br><span class=\"line\"></span><br><span class=\"line\">##spring-session redis \\u7ebf\\u7a0b\\u6c60\\u914d\\u7f6e</span><br><span class=\"line\">redis.taskexecutor.corepoolsize=16</span><br><span class=\"line\">redis.taskexecutor.maxpoolsize=300</span><br><span class=\"line\">redis.taskexecutor.keepaliveseconds=30</span><br><span class=\"line\">redis.taskexecutor.queuecapacity=500</span><br><span class=\"line\">redis.taskexecutor.threadnameprefix=testSpringBootSession-spring-session-redis-executor-thread:</span><br></pre></td></tr></table></figure>\n<p>本地分别启动 WebApplication进行测试<a href=\"http://localhost:port/testSession\" target=\"_blank\" rel=\"noopener\">http://localhost:port/testSession</a><br><a href=\"http://localhost:port/\" target=\"_blank\" rel=\"noopener\">http://localhost:port/</a><br>testSession<br>输出的session id是否一致<br>若一致则spring session成功</p>\n<p>有兴趣可以读<a href=\"https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/\" title=\"《spring sesson源码》\" target=\"_blank\" rel=\"noopener\">《spring sesson源码》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开始spring-session揭秘之前，先做下热脑（活动活动脑子）运动。主要从以下三个方面进行热脑：</p>\n<ul>\n<li>为什么要spring-session</li>\n<li>比较traditional-session方案和spring-session方案</li>\n<li>JSR340规范与spring-session的透明继承<h1 id=\"一-为什么要spring-session\"><a href=\"#一-为什么要spring-session\" class=\"headerlink\" title=\"一.为什么要spring-session\"></a>一.为什么要spring-session</h1>在传统单机web应用中，一般使用tomcat/jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。</li>\n</ul>\n<p>但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：</p>\n<ul>\n<li>需要侵入web容器，提高问题的复杂</li>\n<li>web容器之间共享session，集群机器之间势必要交互耦合<br>基于这些，必须提供新的可靠的集群分布式/集群session的解决方案，突破traditional-session单机限制（即web容器session方式，下面简称traditional-session），spring-session应用而生。</li>\n</ul>\n<h1 id=\"二-比较traditional-session方案和spring-session方案\"><a href=\"#二-比较traditional-session方案和spring-session方案\" class=\"headerlink\" title=\"二.比较traditional-session方案和spring-session方案\"></a>二.比较traditional-session方案和spring-session方案</h1><p>下图展示了traditional-session和spring-session的区别</p>\n<p><img src=\"/2019/11/13/ring-session（1）/1.png\" alt=\"logo\"><br>传统模式中，当request进入web容器，根据reqest获取session时，如果web容器中存在session则返回，如果不存在，web容器则创建一个session。然后返回response时，将sessonId作为response的head一并返回给客户端或者浏览器。</p>\n<p>但是上节中说明了traditional-session的局限性在于：单机session。在此限制的相反面，即将session从web容器中抽出来，形成独立的模块，以便分布式应用或者集群都能共享，即能解决。</p>\n<p>spring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。</p>\n<h1 id=\"JSR340规范与spring-session的透明继承\"><a href=\"#JSR340规范与spring-session的透明继承\" class=\"headerlink\" title=\"JSR340规范与spring-session的透明继承\"></a>JSR340规范与spring-session的透明继承</h1><p>JSR340是Java Servlet 3.1的规范提案，其中定义了大量的api，包括：servlet、servletRequest/HttpServletRequest/HttpServletRequestWrapper、servletResponse/HttpServletResponse/HttpServletResponseWrapper、Filter、Session等，是标准的web容器需要遵循的规约，如tomcat/jetty/weblogic等等。</p>\n<p>在日常的应用开发中，develpers也在频繁的使用servlet-api，比如：</p>\n<p>以下的方式获取请求的session：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest request = ...</span><br><span class=\"line\">HttpSession session = request.getSession(false);</span><br></pre></td></tr></table></figure></p>\n<p>其中HttpServletRequest和HttpSession都是servlet规范中定义的接口，web容器实现的标准。那如果引入spring-session，要如何获取session？</p>\n<ul>\n<li>遵循servlet规范，同样方式获取session，对应用代码无侵入且对于developers透明化</li>\n<li>全新实现一套session规范，定义一套新的api和session管理机制<br>两种方案都可以实现，但是显然第一种更友好，且具有兼容性。spring-session正是第一种方案的实现。</li>\n</ul>\n<p>实现第一种方案的关键点在于做到透明和兼容</p>\n<p>接口适配：仍然使用HttpServletRequest获取session，获取到的session仍然是HttpSession类型——适配器模式<br>类型包装增强：Session不能存储在web容器内，要外化存储——装饰模式<br>让人兴奋的是，以上的需求在Servlet规范中的扩展性都是予以支持！Servlet规范中定义一系列的接口都是支持扩展，同时提供Filter支撑扩展点。</p>\n<h1 id=\"spring-session入门\"><a href=\"#spring-session入门\" class=\"headerlink\" title=\"spring session入门\"></a>spring session入门</h1><p>主要从以下两个方面来说spring-session：</p>\n<ul>\n<li>特点</li>\n<li><p>工作原理</p>\n<h2 id=\"一-特点\"><a href=\"#一-特点\" class=\"headerlink\" title=\"一.特点\"></a>一.特点</h2><p>spring-session在无需绑定web容器的情况下提供对集群session的支持。并提供对以下情况的透明集成：</p>\n</li>\n<li><p>HttpSession：容许替换web容器的HttpSession</p>\n</li>\n<li>WebSocket：使用WebSocket通信时，提供Session的活跃</li>\n<li>WebSession：容许以应用中立的方式替换webflux的webSession</li>\n</ul>\n<p>下面以项目接入spring session redis为例</p>\n<h1 id=\"spring-项目\"><a href=\"#spring-项目\" class=\"headerlink\" title=\"spring 项目\"></a>spring 项目</h1><p>引入spring session的jar<br>代码：<a href=\"https://github.com/smallwenzi/testSpringSession\" target=\"_blank\" rel=\"noopener\">https://github.com/smallwenzi/testSpringSession</a></p>\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入:\"></a>引入:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    \t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">    \t&lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">    \t&lt;version&gt;1.3.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">    \t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">    \t&lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">    \t&lt;version&gt;1.3.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- Spring session redis 依赖start --&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t&lt;version&gt;1.2.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class=\"line\">\t    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">\t    &lt;version&gt;1.6.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">\t    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">\t    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置redis\"><a href=\"#配置redis\" class=\"headerlink\" title=\"配置redis\"></a>配置redis</h2><p>applicationContext.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;   </span><br><span class=\"line\"> &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;</span><br><span class=\"line\">     &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.hostName&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;usePool&quot; value=&quot;$&#123;redis.usePool&#125;&quot; /&gt;</span><br><span class=\"line\">     &lt;property name=&quot;timeout&quot; value=&quot;$&#123;redis.timeout&#125;&quot; /&gt;</span><br><span class=\"line\"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>\n<p>redis.properties（自行更改redis 配置）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.hostName=localhost</span><br><span class=\"line\">redis.port=6379</span><br><span class=\"line\">redis.password=</span><br><span class=\"line\">redis.usePool=true</span><br><span class=\"line\">redis.timeout=10000</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开启spring-session\"><a href=\"#开启spring-session\" class=\"headerlink\" title=\"开启spring session\"></a>开启spring session</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">//redisNamespace区分每个项目spring session key唯一</span><br><span class=\"line\">@EnableRedisHttpSession(redisNamespace = &quot;testSpringSession&quot;)</span><br><span class=\"line\">public class SpringSessionHttpConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.corepoolsize&#125;&quot;)</span><br><span class=\"line\">    private String corepoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.maxpoolsize&#125;&quot;)</span><br><span class=\"line\">    private String maxpoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.keepaliveseconds&#125;&quot;)</span><br><span class=\"line\">    private String keepaliveseconds;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.queuecapacity&#125;&quot;)</span><br><span class=\"line\">    private String queuecapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.threadnameprefix&#125;&quot;)</span><br><span class=\"line\">    private String threadnameprefix;</span><br><span class=\"line\"></span><br><span class=\"line\">//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里test.properties</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() &#123;</span><br><span class=\"line\">        logger.info(&quot;JedisPool注入成功！！&quot;);</span><br><span class=\"line\">        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);</span><br><span class=\"line\">        return springSessionRedisTaskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            int sizeInt = Integer.parseInt(size);</span><br><span class=\"line\">            return sizeInt;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return defaultSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;filter&gt;</span><br><span class=\"line\"> &lt;!-- 必须这样命名 SpringHttpSessionConfiguration类中定义了springSessionRepositoryFilter类 --&gt;</span><br><span class=\"line\">&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class=\"line\">&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;\t</span><br><span class=\"line\"> &lt;/filter&gt;</span><br><span class=\"line\"> &lt;filter-mapping&gt;</span><br><span class=\"line\">&lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class=\"line\">   &lt;!-- 需要spring session的访问路径 --&gt;</span><br><span class=\"line\">&lt;url-pattern&gt;/*&lt;/url-pattern&gt; </span><br><span class=\"line\"> &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>\n<p>本地分别部署tomcat 进行测试<a href=\"http://localhost:8082/testSpringSession/testSession.do\" target=\"_blank\" rel=\"noopener\">http://localhost:8082/testSpringSession/testSession.do</a><br><a href=\"http://localhost:8080/testSpringSession/testSession.do\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/testSpringSession/testSession.do</a><br>输出的session id是否一致<br>若一致则spring session成功</p>\n<h1 id=\"spring-boot项目\"><a href=\"#spring-boot项目\" class=\"headerlink\" title=\"spring boot项目\"></a>spring boot项目</h1><p>项目：<a href=\"https://github.com/smallwenzi/testSpringBootSession\" target=\"_blank\" rel=\"noopener\">https://github.com/smallwenzi/testSpringBootSession</a></p>\n<h2 id=\"引入jar\"><a href=\"#引入jar\" class=\"headerlink\" title=\"引入jar\"></a>引入jar</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          &lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  \t&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启springsession\"><a href=\"#开启springsession\" class=\"headerlink\" title=\"开启springsession\"></a>开启springsession</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//redisNamespace区分每个项目spring session key唯一</span><br><span class=\"line\">@EnableRedisHttpSession(redisNamespace = &quot;testSpringBootSession&quot;)</span><br><span class=\"line\">public class SpringSessionHttpConfig &#123;</span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(SpringSessionHttpConfig.class);</span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.corepoolsize&#125;&quot;)</span><br><span class=\"line\">    private String corepoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.maxpoolsize&#125;&quot;)</span><br><span class=\"line\">    private String maxpoolsize;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.keepaliveseconds&#125;&quot;)</span><br><span class=\"line\">    private String keepaliveseconds;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.queuecapacity&#125;&quot;)</span><br><span class=\"line\">    private String queuecapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;redis.taskexecutor.threadnameprefix&#125;&quot;)</span><br><span class=\"line\">    private String threadnameprefix;</span><br><span class=\"line\"></span><br><span class=\"line\">//控制springsession 线程池 否则线程会无限制创建 导致oom 线程配置详细看看项目里application.properties</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ThreadPoolTaskExecutor springSessionRedisTaskExecutor() &#123;</span><br><span class=\"line\">        logger.info(&quot;JedisPool注入成功！！&quot;);</span><br><span class=\"line\">        ThreadPoolTaskExecutor springSessionRedisTaskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setCorePoolSize(getRedisTaskexecutorStrToInt(this.corepoolsize, 16));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setMaxPoolSize(getRedisTaskexecutorStrToInt(this.maxpoolsize, 300));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setKeepAliveSeconds(getRedisTaskexecutorStrToInt(this.keepaliveseconds, 30));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setQueueCapacity(getRedisTaskexecutorStrToInt(this.queuecapacity, 500));</span><br><span class=\"line\">        springSessionRedisTaskExecutor.setThreadNamePrefix(this.threadnameprefix);</span><br><span class=\"line\">        return springSessionRedisTaskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int getRedisTaskexecutorStrToInt(String size, int defaultSize) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            int sizeInt = Integer.parseInt(size);</span><br><span class=\"line\">            return sizeInt;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return defaultSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"application-properties\"><a href=\"#application-properties\" class=\"headerlink\" title=\"application.properties\"></a>application.properties</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#本地测试设置随机端口 （自行更改redis 配置）</span><br><span class=\"line\">server.port=0</span><br><span class=\"line\"># redis start</span><br><span class=\"line\">#spring.redis.database=0</span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\">spring.redis.pool.max-idle=10</span><br><span class=\"line\">spring.redis.pool.min-idle=0</span><br><span class=\"line\">spring.redis.pool.max-active=100</span><br><span class=\"line\">spring.redis.pool.max-wait=1000</span><br><span class=\"line\">spring.redis.database=0</span><br><span class=\"line\"># Redis\\u670D\\u52A1\\u5668\\u5730\\u5740</span><br><span class=\"line\">spring.redis.host=localhost</span><br><span class=\"line\"># Redis\\u670D\\u52A1\\u5668\\u8FDE\\u63A5\\u7AEF\\u53E3</span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\"></span><br><span class=\"line\"># redis end</span><br><span class=\"line\">#spring session\\u4f7f\\u7528\\u5b58\\u50a8\\u7c7b\\u578b</span><br><span class=\"line\">spring.session.store-type=redis</span><br><span class=\"line\"></span><br><span class=\"line\">##spring-session redis \\u7ebf\\u7a0b\\u6c60\\u914d\\u7f6e</span><br><span class=\"line\">redis.taskexecutor.corepoolsize=16</span><br><span class=\"line\">redis.taskexecutor.maxpoolsize=300</span><br><span class=\"line\">redis.taskexecutor.keepaliveseconds=30</span><br><span class=\"line\">redis.taskexecutor.queuecapacity=500</span><br><span class=\"line\">redis.taskexecutor.threadnameprefix=testSpringBootSession-spring-session-redis-executor-thread:</span><br></pre></td></tr></table></figure>\n<p>本地分别启动 WebApplication进行测试<a href=\"http://localhost:port/testSession\" target=\"_blank\" rel=\"noopener\">http://localhost:port/testSession</a><br><a href=\"http://localhost:port/\" target=\"_blank\" rel=\"noopener\">http://localhost:port/</a><br>testSession<br>输出的session id是否一致<br>若一致则spring session成功</p>\n<p>有兴趣可以读<a href=\"https://smallwenzi.github.io/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/\" title=\"《spring sesson源码》\" target=\"_blank\" rel=\"noopener\">《spring sesson源码》</a></p>\n"},{"title":"springFramework源码编译","author":"wen","date":"2020-08-07T08:02:00.000Z","_content":"# 安装环境配套\nGradle 5.6.2 +java version \"1.8.0_251\"+idea+spring framework5.1.x\n* Spring framework下载：https://github.com/spring-projects/spring-framework/tree/5.1.x\n* Gradle 6.5.1下载:https://gradle.org/next-steps/?version=5.6.2&format=bin\n\n# 配置gradle环境\n  配置gradle环境变量 新建GRADLE_HOME，path中增加%GRADLE_HOME%/bin;即可\n  ![gradle](spring源码编译/1.png)\n  ![gradle](spring源码编译/2.png)\n  配置完成以后win+r，输入cmd进入dos界面，键入命令gradle -v，若如下图正确输出版本信息即可\n    ![gradle](spring源码编译/3.png)\n  配置gradle默认的本地仓库，gradle和maven类似，工作时也需要一个本地仓库，管理工程jar包，可做如下配置，新增GRADLE_USER_HOME\n     ![gradle](spring源码编译/4.png)\n # Git 下载代码\nGi地址：https://github.com/spring-projects/spring-framework.git\n ![gradle](spring源码编译/5.png)\n 下载完成切换分支5.1.x\n  ![gradle](spring源码编译/6.png)\n  在import-into-idea.md 你编译spring work源码之前你需要spring-core和spring-oxm\n  ![gradle](spring源码编译/7.png)\n  \n gradle 添加aliyun maven仓库(根目录的build.gradle)\n ```\n 在文件中找到以下（）\n repositories {\n\t\t    maven { url \"http://maven.aliyun.com/nexus/content/groups/public/\" }\n\t\t\tmavenCentral()\n\t\t\tmaven { url \"https://repo.spring.io/libs-spring-framework-build\" }\n\t\t\tmaven { url \"https://repo.spring.io/snapshot\" }  // Reactor Dysprosium snapshots\n\t\t}\n ```\n  # 注意\n  注意几点：\n * a，因为其他项目需要依赖spring-core和spring-orm，所以我们导入后需要先编译这两个包 （在cmd 命令下执行gradle build -x test ）,需要\n  等候一定时间(我这边花了1小时时间)，保证网络稳定\n ![gradle](spring源码编译/8.png)\n  ![gradle](spring源码编译/9.png)\n\n成功截图： 显示Build successful\n ![gradle](spring源码编译/10.png)\n\n*  b，spring-aspects需要依赖三方jar（精通aop的应该知道spring-aop和aspectj的关系，在使用注解方式实现spring-aop的时候，需要导入aspectj的jar，有兴趣的可以去查阅下官方文档aop相关文档），这里编译可能会报错，不影响我们编译使用，我们先不处理\n  \n* c，使用工具编译时，可能会出现内存溢出情况，这里我们编译时需要增加相关参数\n ```\n         -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m\n         ```\n* d) 以上工作完成之后，我们可以开始导入编辑编译配置了，如下图（需要注意的地方已在图中标注）\n\n# idea使用导入springframework项目\n ![gradle](spring源码编译/11.png)\n 点击 import project\n![gradle](spring源码编译/12.png)\n使用gradle导入项目\n![gradle](spring源码编译/13.png)\n最后点击finish （需要从gradle仓库下载所需依赖包 这个过程可能比较久 决定因素是 网络环境及机器环境 ）\n\n\n导入成功：\n![gradle](spring源码编译/15.png)\n\n# 常见问题：\n\n* 导入项目的时候还需要下载gradle 软件\nSetting--》gradle 选择gradle软件目录\n\n![gradle](spring源码编译/16.png)\n\n* 可能由于网络原因构建失败 在gradle窗口选择spring项目右击 菜单选择refreshGradle dependencies\n\n![gradle](spring源码编译/17.png)\n\n# 新建Model\n![gradle](spring源码编译/18.png)\n选择Gradle项目 next\n\n![gradle](spring源码编译/19.png)\n输入项目名称\n![gradle](spring源码编译/20.png)\n确认项目存储路径 最后点击finish\n![gradle](spring源码编译/21.png)\n新建完成：\n![gradle](spring源码编译/22.png)\n编辑build.gradle\ncompile(project(\":spring-context\"))\n![gradle](spring源码编译/23.png)\n\n新增AppConfig.java和MemberService\n```\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n\n```\n运行Appconfig main方法\n\n![gradle](spring源码编译/25.png)","source":"_posts/spring源码编译.md","raw":"title: springFramework源码编译\nauthor: wen\ntags:\n  - 源码\ncategories:\n  - spring\n  - springFramework\ndate: 2020-08-07 16:02:00\n---\n# 安装环境配套\nGradle 5.6.2 +java version \"1.8.0_251\"+idea+spring framework5.1.x\n* Spring framework下载：https://github.com/spring-projects/spring-framework/tree/5.1.x\n* Gradle 6.5.1下载:https://gradle.org/next-steps/?version=5.6.2&format=bin\n\n# 配置gradle环境\n  配置gradle环境变量 新建GRADLE_HOME，path中增加%GRADLE_HOME%/bin;即可\n  ![gradle](spring源码编译/1.png)\n  ![gradle](spring源码编译/2.png)\n  配置完成以后win+r，输入cmd进入dos界面，键入命令gradle -v，若如下图正确输出版本信息即可\n    ![gradle](spring源码编译/3.png)\n  配置gradle默认的本地仓库，gradle和maven类似，工作时也需要一个本地仓库，管理工程jar包，可做如下配置，新增GRADLE_USER_HOME\n     ![gradle](spring源码编译/4.png)\n # Git 下载代码\nGi地址：https://github.com/spring-projects/spring-framework.git\n ![gradle](spring源码编译/5.png)\n 下载完成切换分支5.1.x\n  ![gradle](spring源码编译/6.png)\n  在import-into-idea.md 你编译spring work源码之前你需要spring-core和spring-oxm\n  ![gradle](spring源码编译/7.png)\n  \n gradle 添加aliyun maven仓库(根目录的build.gradle)\n ```\n 在文件中找到以下（）\n repositories {\n\t\t    maven { url \"http://maven.aliyun.com/nexus/content/groups/public/\" }\n\t\t\tmavenCentral()\n\t\t\tmaven { url \"https://repo.spring.io/libs-spring-framework-build\" }\n\t\t\tmaven { url \"https://repo.spring.io/snapshot\" }  // Reactor Dysprosium snapshots\n\t\t}\n ```\n  # 注意\n  注意几点：\n * a，因为其他项目需要依赖spring-core和spring-orm，所以我们导入后需要先编译这两个包 （在cmd 命令下执行gradle build -x test ）,需要\n  等候一定时间(我这边花了1小时时间)，保证网络稳定\n ![gradle](spring源码编译/8.png)\n  ![gradle](spring源码编译/9.png)\n\n成功截图： 显示Build successful\n ![gradle](spring源码编译/10.png)\n\n*  b，spring-aspects需要依赖三方jar（精通aop的应该知道spring-aop和aspectj的关系，在使用注解方式实现spring-aop的时候，需要导入aspectj的jar，有兴趣的可以去查阅下官方文档aop相关文档），这里编译可能会报错，不影响我们编译使用，我们先不处理\n  \n* c，使用工具编译时，可能会出现内存溢出情况，这里我们编译时需要增加相关参数\n ```\n         -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m\n         ```\n* d) 以上工作完成之后，我们可以开始导入编辑编译配置了，如下图（需要注意的地方已在图中标注）\n\n# idea使用导入springframework项目\n ![gradle](spring源码编译/11.png)\n 点击 import project\n![gradle](spring源码编译/12.png)\n使用gradle导入项目\n![gradle](spring源码编译/13.png)\n最后点击finish （需要从gradle仓库下载所需依赖包 这个过程可能比较久 决定因素是 网络环境及机器环境 ）\n\n\n导入成功：\n![gradle](spring源码编译/15.png)\n\n# 常见问题：\n\n* 导入项目的时候还需要下载gradle 软件\nSetting--》gradle 选择gradle软件目录\n\n![gradle](spring源码编译/16.png)\n\n* 可能由于网络原因构建失败 在gradle窗口选择spring项目右击 菜单选择refreshGradle dependencies\n\n![gradle](spring源码编译/17.png)\n\n# 新建Model\n![gradle](spring源码编译/18.png)\n选择Gradle项目 next\n\n![gradle](spring源码编译/19.png)\n输入项目名称\n![gradle](spring源码编译/20.png)\n确认项目存储路径 最后点击finish\n![gradle](spring源码编译/21.png)\n新建完成：\n![gradle](spring源码编译/22.png)\n编辑build.gradle\ncompile(project(\":spring-context\"))\n![gradle](spring源码编译/23.png)\n\n新增AppConfig.java和MemberService\n```\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n\n```\n运行Appconfig main方法\n\n![gradle](spring源码编译/25.png)","slug":"spring源码编译","published":1,"updated":"2020-08-18T02:55:01.997Z","_id":"ckdzce38m001wn6zqr0mk8pf0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"安装环境配套\"><a href=\"#安装环境配套\" class=\"headerlink\" title=\"安装环境配套\"></a>安装环境配套</h1><p>Gradle 5.6.2 +java version “1.8.0_251”+idea+spring framework5.1.x</p>\n<ul>\n<li>Spring framework下载：<a href=\"https://github.com/spring-projects/spring-framework/tree/5.1.x\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework/tree/5.1.x</a></li>\n<li>Gradle 6.5.1下载:<a href=\"https://gradle.org/next-steps/?version=5.6.2&amp;format=bin\" target=\"_blank\" rel=\"noopener\">https://gradle.org/next-steps/?version=5.6.2&amp;format=bin</a></li>\n</ul>\n<h1 id=\"配置gradle环境\"><a href=\"#配置gradle环境\" class=\"headerlink\" title=\"配置gradle环境\"></a>配置gradle环境</h1><p>  配置gradle环境变量 新建GRADLE_HOME，path中增加%GRADLE_HOME%/bin;即可<br>  <img src=\"/2020/08/07/spring源码编译/1.png\" alt=\"gradle\"><br>  <img src=\"/2020/08/07/spring源码编译/2.png\" alt=\"gradle\"><br>  配置完成以后win+r，输入cmd进入dos界面，键入命令gradle -v，若如下图正确输出版本信息即可<br>    <img src=\"/2020/08/07/spring源码编译/3.png\" alt=\"gradle\"><br>  配置gradle默认的本地仓库，gradle和maven类似，工作时也需要一个本地仓库，管理工程jar包，可做如下配置，新增GRADLE_USER_HOME<br>     <img src=\"/2020/08/07/spring源码编译/4.png\" alt=\"gradle\"></p>\n<h1 id=\"Git-下载代码\"><a href=\"#Git-下载代码\" class=\"headerlink\" title=\"Git 下载代码\"></a>Git 下载代码</h1><p>Gi地址：<a href=\"https://github.com/spring-projects/spring-framework.git\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework.git</a><br> <img src=\"/2020/08/07/spring源码编译/5.png\" alt=\"gradle\"><br> 下载完成切换分支5.1.x<br>  <img src=\"/2020/08/07/spring源码编译/6.png\" alt=\"gradle\"><br>  在import-into-idea.md 你编译spring work源码之前你需要spring-core和spring-oxm<br>  <img src=\"/2020/08/07/spring源码编译/7.png\" alt=\"gradle\"></p>\n<p> gradle 添加aliyun maven仓库(根目录的build.gradle)<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在文件中找到以下（）</span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">\t    maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; &#125;</span><br><span class=\"line\">\t\tmavenCentral()</span><br><span class=\"line\">\t\tmaven &#123; url &quot;https://repo.spring.io/libs-spring-framework-build&quot; &#125;</span><br><span class=\"line\">\t\tmaven &#123; url &quot;https://repo.spring.io/snapshot&quot; &#125;  // Reactor Dysprosium snapshots</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>  注意几点：</p>\n<ul>\n<li>a，因为其他项目需要依赖spring-core和spring-orm，所以我们导入后需要先编译这两个包 （在cmd 命令下执行gradle build -x test ）,需要<br>等候一定时间(我这边花了1小时时间)，保证网络稳定<br><img src=\"/2020/08/07/spring源码编译/8.png\" alt=\"gradle\"><br><img src=\"/2020/08/07/spring源码编译/9.png\" alt=\"gradle\"></li>\n</ul>\n<p>成功截图： 显示Build successful<br> <img src=\"/2020/08/07/spring源码编译/10.png\" alt=\"gradle\"></p>\n<ul>\n<li><p>b，spring-aspects需要依赖三方jar（精通aop的应该知道spring-aop和aspectj的关系，在使用注解方式实现spring-aop的时候，需要导入aspectj的jar，有兴趣的可以去查阅下官方文档aop相关文档），这里编译可能会报错，不影响我们编译使用，我们先不处理</p>\n</li>\n<li><p>c，使用工具编译时，可能会出现内存溢出情况，这里我们编译时需要增加相关参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>d) 以上工作完成之后，我们可以开始导入编辑编译配置了，如下图（需要注意的地方已在图中标注）</p>\n</li>\n</ul>\n<h1 id=\"idea使用导入springframework项目\"><a href=\"#idea使用导入springframework项目\" class=\"headerlink\" title=\"idea使用导入springframework项目\"></a>idea使用导入springframework项目</h1><p> <img src=\"/2020/08/07/spring源码编译/11.png\" alt=\"gradle\"><br> 点击 import project<br><img src=\"/2020/08/07/spring源码编译/12.png\" alt=\"gradle\"><br>使用gradle导入项目<br><img src=\"/2020/08/07/spring源码编译/13.png\" alt=\"gradle\"><br>最后点击finish （需要从gradle仓库下载所需依赖包 这个过程可能比较久 决定因素是 网络环境及机器环境 ）</p>\n<p>导入成功：<br><img src=\"/2020/08/07/spring源码编译/15.png\" alt=\"gradle\"></p>\n<h1 id=\"常见问题：\"><a href=\"#常见问题：\" class=\"headerlink\" title=\"常见问题：\"></a>常见问题：</h1><ul>\n<li>导入项目的时候还需要下载gradle 软件<br>Setting–》gradle 选择gradle软件目录</li>\n</ul>\n<p><img src=\"/2020/08/07/spring源码编译/16.png\" alt=\"gradle\"></p>\n<ul>\n<li>可能由于网络原因构建失败 在gradle窗口选择spring项目右击 菜单选择refreshGradle dependencies</li>\n</ul>\n<p><img src=\"/2020/08/07/spring源码编译/17.png\" alt=\"gradle\"></p>\n<h1 id=\"新建Model\"><a href=\"#新建Model\" class=\"headerlink\" title=\"新建Model\"></a>新建Model</h1><p><img src=\"/2020/08/07/spring源码编译/18.png\" alt=\"gradle\"><br>选择Gradle项目 next</p>\n<p><img src=\"/2020/08/07/spring源码编译/19.png\" alt=\"gradle\"><br>输入项目名称<br><img src=\"/2020/08/07/spring源码编译/20.png\" alt=\"gradle\"><br>确认项目存储路径 最后点击finish<br><img src=\"/2020/08/07/spring源码编译/21.png\" alt=\"gradle\"><br>新建完成：<br><img src=\"/2020/08/07/spring源码编译/22.png\" alt=\"gradle\"><br>编辑build.gradle<br>compile(project(“:spring-context”))<br><img src=\"/2020/08/07/spring源码编译/23.png\" alt=\"gradle\"></p>\n<p>新增AppConfig.java和MemberService<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行Appconfig main方法</p>\n<p><img src=\"/2020/08/07/spring源码编译/25.png\" alt=\"gradle\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装环境配套\"><a href=\"#安装环境配套\" class=\"headerlink\" title=\"安装环境配套\"></a>安装环境配套</h1><p>Gradle 5.6.2 +java version “1.8.0_251”+idea+spring framework5.1.x</p>\n<ul>\n<li>Spring framework下载：<a href=\"https://github.com/spring-projects/spring-framework/tree/5.1.x\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework/tree/5.1.x</a></li>\n<li>Gradle 6.5.1下载:<a href=\"https://gradle.org/next-steps/?version=5.6.2&amp;format=bin\" target=\"_blank\" rel=\"noopener\">https://gradle.org/next-steps/?version=5.6.2&amp;format=bin</a></li>\n</ul>\n<h1 id=\"配置gradle环境\"><a href=\"#配置gradle环境\" class=\"headerlink\" title=\"配置gradle环境\"></a>配置gradle环境</h1><p>  配置gradle环境变量 新建GRADLE_HOME，path中增加%GRADLE_HOME%/bin;即可<br>  <img src=\"/2020/08/07/spring源码编译/1.png\" alt=\"gradle\"><br>  <img src=\"/2020/08/07/spring源码编译/2.png\" alt=\"gradle\"><br>  配置完成以后win+r，输入cmd进入dos界面，键入命令gradle -v，若如下图正确输出版本信息即可<br>    <img src=\"/2020/08/07/spring源码编译/3.png\" alt=\"gradle\"><br>  配置gradle默认的本地仓库，gradle和maven类似，工作时也需要一个本地仓库，管理工程jar包，可做如下配置，新增GRADLE_USER_HOME<br>     <img src=\"/2020/08/07/spring源码编译/4.png\" alt=\"gradle\"></p>\n<h1 id=\"Git-下载代码\"><a href=\"#Git-下载代码\" class=\"headerlink\" title=\"Git 下载代码\"></a>Git 下载代码</h1><p>Gi地址：<a href=\"https://github.com/spring-projects/spring-framework.git\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-framework.git</a><br> <img src=\"/2020/08/07/spring源码编译/5.png\" alt=\"gradle\"><br> 下载完成切换分支5.1.x<br>  <img src=\"/2020/08/07/spring源码编译/6.png\" alt=\"gradle\"><br>  在import-into-idea.md 你编译spring work源码之前你需要spring-core和spring-oxm<br>  <img src=\"/2020/08/07/spring源码编译/7.png\" alt=\"gradle\"></p>\n<p> gradle 添加aliyun maven仓库(根目录的build.gradle)<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在文件中找到以下（）</span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">\t    maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; &#125;</span><br><span class=\"line\">\t\tmavenCentral()</span><br><span class=\"line\">\t\tmaven &#123; url &quot;https://repo.spring.io/libs-spring-framework-build&quot; &#125;</span><br><span class=\"line\">\t\tmaven &#123; url &quot;https://repo.spring.io/snapshot&quot; &#125;  // Reactor Dysprosium snapshots</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>  注意几点：</p>\n<ul>\n<li>a，因为其他项目需要依赖spring-core和spring-orm，所以我们导入后需要先编译这两个包 （在cmd 命令下执行gradle build -x test ）,需要<br>等候一定时间(我这边花了1小时时间)，保证网络稳定<br><img src=\"/2020/08/07/spring源码编译/8.png\" alt=\"gradle\"><br><img src=\"/2020/08/07/spring源码编译/9.png\" alt=\"gradle\"></li>\n</ul>\n<p>成功截图： 显示Build successful<br> <img src=\"/2020/08/07/spring源码编译/10.png\" alt=\"gradle\"></p>\n<ul>\n<li><p>b，spring-aspects需要依赖三方jar（精通aop的应该知道spring-aop和aspectj的关系，在使用注解方式实现spring-aop的时候，需要导入aspectj的jar，有兴趣的可以去查阅下官方文档aop相关文档），这里编译可能会报错，不影响我们编译使用，我们先不处理</p>\n</li>\n<li><p>c，使用工具编译时，可能会出现内存溢出情况，这里我们编译时需要增加相关参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>d) 以上工作完成之后，我们可以开始导入编辑编译配置了，如下图（需要注意的地方已在图中标注）</p>\n</li>\n</ul>\n<h1 id=\"idea使用导入springframework项目\"><a href=\"#idea使用导入springframework项目\" class=\"headerlink\" title=\"idea使用导入springframework项目\"></a>idea使用导入springframework项目</h1><p> <img src=\"/2020/08/07/spring源码编译/11.png\" alt=\"gradle\"><br> 点击 import project<br><img src=\"/2020/08/07/spring源码编译/12.png\" alt=\"gradle\"><br>使用gradle导入项目<br><img src=\"/2020/08/07/spring源码编译/13.png\" alt=\"gradle\"><br>最后点击finish （需要从gradle仓库下载所需依赖包 这个过程可能比较久 决定因素是 网络环境及机器环境 ）</p>\n<p>导入成功：<br><img src=\"/2020/08/07/spring源码编译/15.png\" alt=\"gradle\"></p>\n<h1 id=\"常见问题：\"><a href=\"#常见问题：\" class=\"headerlink\" title=\"常见问题：\"></a>常见问题：</h1><ul>\n<li>导入项目的时候还需要下载gradle 软件<br>Setting–》gradle 选择gradle软件目录</li>\n</ul>\n<p><img src=\"/2020/08/07/spring源码编译/16.png\" alt=\"gradle\"></p>\n<ul>\n<li>可能由于网络原因构建失败 在gradle窗口选择spring项目右击 菜单选择refreshGradle dependencies</li>\n</ul>\n<p><img src=\"/2020/08/07/spring源码编译/17.png\" alt=\"gradle\"></p>\n<h1 id=\"新建Model\"><a href=\"#新建Model\" class=\"headerlink\" title=\"新建Model\"></a>新建Model</h1><p><img src=\"/2020/08/07/spring源码编译/18.png\" alt=\"gradle\"><br>选择Gradle项目 next</p>\n<p><img src=\"/2020/08/07/spring源码编译/19.png\" alt=\"gradle\"><br>输入项目名称<br><img src=\"/2020/08/07/spring源码编译/20.png\" alt=\"gradle\"><br>确认项目存储路径 最后点击finish<br><img src=\"/2020/08/07/spring源码编译/21.png\" alt=\"gradle\"><br>新建完成：<br><img src=\"/2020/08/07/spring源码编译/22.png\" alt=\"gradle\"><br>编辑build.gradle<br>compile(project(“:spring-context”))<br><img src=\"/2020/08/07/spring源码编译/23.png\" alt=\"gradle\"></p>\n<p>新增AppConfig.java和MemberService<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行Appconfig main方法</p>\n<p><img src=\"/2020/08/07/spring源码编译/25.png\" alt=\"gradle\"></p>\n"},{"title":"Hexo搭建githubpage博客","date":"2017-02-20T02:01:00.000Z","_content":"<Excerpt in index | 首页摘要>\n这是一篇很详尽的独立博客搭建教程 里面介绍了github、Hexo和hexo-admin设置等过程<!-- more -->\n<The rest of contents | 余下全文>\n## 系统环境配置\n要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！\n\n### 安装Node.js\n下载:[Node.js](https://nodejs.org/en/)\n参考地址：[安装Node.js](http://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n### 安装Git\n下载地址：[git](http://git-scm.com/download/)\n\n### 安装hexo\n\n``` bash\n$ cd d:/hexo\n```\n\n``` bash\n$ npm install hexo-cli -g\n```\n\n``` bash\n$ hexo init blog\n```\n\n``` bash\n$ cd blog\n```\n\n``` bash\n$ npm install\n```\n\n``` bash\n$ hexo s -g #生成预览\n```\n\n$ hexo g == hexo generate  生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\n$ hexo s == hexo server 启动本地web服务，用于博客的预览\n$ hexo d == hexo deploy 部署播客到远端（比如github, heroku等平台）\n\n现在我们打开http://localhost:4000/ 已经可以看到一篇内置的blog了。\n![logo](hexo git/1.jpeg)\n\n\n目前我安装所用的本地环境如下：(可以通过hexo -v查看)\nhexo-cli: 1.0.2\nos: Windows_NT 6.1.7601 win32 x64\nhttp_parser: 2.7.0\nnode: 7.5.0\nv8: 5.4.500.48\nuv: 1.10.2\nzlib: 1.2.8\nares: 1.10.1-DEV\nmodules: 51\nopenssl: 1.0.2k\nicu: 58.2\nunicode: 9.0\ncldr: 30.0.3\ntz: 2016j\n\n\n## Hexo主题设置\n这里以主题yilia为例进行说明。\n\n### 安装主题 (在blog目录下)\n``` bash\n$ hexo clean\n```\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n### 启用主题\n\n修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。\n\n### 更新主题\n``` bash\n$ cd themes/yilia\n```\n``` bash\n$ git pull\n```\n``` bash\n$ hexo s -g\n```\n现在打开http://localhost:4000/ ，会看到我们已经应用了一个新的主题。\n![logo](hexo git/1.jpeg)\n\n\n## Github Pages设置\n\n### 什么是Github Pages\n\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。\n\n在这里我创建了一个github repo叫做 smallwenzi.github.io. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接http://smallwenzi.github.io/ 访问了。\n\n### 配置SSHKey\n我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。\n\n#### 检查 SSH keys的设置\n首先我们需要检查你电脑上现有的 ssh key：\n~/.ssh目录是否存在\n若不存在\n```\nssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n注意 1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n注意：输入密码的时候没有 * 字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n ![logo](hexo git/5.png)\n### 添加 SSH Key 到 GitHub\n在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。\n\n1、打开本地 id_rsa.pub 文件（ 参考地址 C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n\n2、登陆 GitHub 系统。点击右上角的 Account Settings--->SSH KEY AND GPG KEY  ---> new ssh key\n3、把你本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了\n\n## 部署Hexo到Github Pages\n\n这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过http://smallwenzi.github.io/访问了。\n首先需要明白所谓部署到github的原理。\n1之前步骤中在Github上创建的那个特别的repo（smallwenzi.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接http://smallwenzi.github.io来直接访问。\n2Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。\n3需要将hexo生成的静态网站，提交(git commit)到github上。\n明白了原理，怎么做自然就清晰了。\n\n### 使用hexo deploy部署\nhexo deploy可以部署到很多平台，具体可以参考这个[链接](https://hexo.io/docs/deployment.html). 如果部署到github，需要在配置文件_config.xml中作如下修改：\ndeploy:\n  type: git\n  repo: git@github.com:smallwenzi/smallwenzi.github.io.git\n  branch: master\n  \n ![logo](hexo git/2.png)\n然后在命令行中执行 (在blog目录下)\n``` bash\n$ npm install hexo-deployer-git --save\n```\n``` bash\n$ hexo d -g\n```\n即可完成部署。现在打开https://smallwenzi.github.io/ ，\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至smallwenzi.github.io的git目录下，然后使用git commit命令提交代码到smallwenzi.github.io这个repo的master branch上。\n\n\n### Hexo 主题配置\n\n每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。\n以我们使用的yilia主题为例，其提供如下的配置项（theme\\yilia_config.yml）：\n[参考](https://github.com/litten/hexo-theme-yilia).\n\n\n## Hexo 使用本地图片\n首先确认 _config.yml 中有 post_asset_folder:true 。\n在 hexo 目录，执行\n\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n假设在\n\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n\n![logo](hexo git/3.png)\n\n## Hexo 后台管理配置\n在blog 跟目录下\n``` bash\n$ npm install --save hexo-admin \n```\n``` bash\n$ hexo server -d\n```\n如下图：\n![logo](hexo git/4.png)\n[参考](https://github.com/jaredly/hexo-admin)\n\n## github后台绑上自己的域名\n\n### 申请一个域名\n我用的新网买的域名（yanwentan.xyz），买好之后进入域名控制台可以看到自己买的域名。\n![logo](hexo git/7.png)\n设置域名解析记录，注意记录类型设置为CNAME，记录值为刚才github上仓库的名字，注意没有https://。\n![logo](hexo git/8.png)\n\n为了能够从别的域名跳转到github页面，还需要在github中进行设置：\n在博客source目录新增CNAME 文件 \n文件内容 添加自己的域名：blog.yanwentan.xyz\n\n这样 通过hexo d -g 部署 就会 设置 域名 显示\n\n## 免费申请https\nhttps://dash.cloudflare.com 注册一个账号，注册成功后\n* 新增站点yanwentan.xyz\n![logo](hexo git/10.png)\n* 修改dns映射\n![logo](hexo git/12.png)\nNS\tgemma.ns.cloudflare.com\nNS\thenrik.ns.cloudflare.com\n生效时间24-48小时 \n* 添加cname记录\n添加 blog 映射：smallwenzi.github.io\n![logo](hexo git/11.png)\n设置完成使用 https://blog.yanwentan.xyz/ 访问\n* 点击上图ssl\\TLS  设置您的 SSL/TLS 加密模式为 灵活\n![logo](hexo git/13.png)\n* 点击上图 边缘服务器 进行设置 https\n![logo](hexo git/15.png)\n* 点击 analytics 查看网站访问流量\n![logo](hexo git/16.png)\n\n\n## 注意事项（避雷）\n* 创建.cn/.com等域名可能需要进行实名认证才能正确解析，这在域名控制器中会有提示，若域名解析成功，控制器中会显示DNS服务器地址表示正常服务：\n\n\n* 在设置完成后不会立刻生效，需要等待一段时间（10~15分钟），这期间尽量不要因为无法访问而反复更改设置，会因为设置生效有时延而变得更加混乱。\n\n* 要注意浏览器自动缓存问题，在第一次输入后，如果不清除缓存，就算做了更改，浏览器还是会用上一次的DNS解析结果尽管这可能是错误的，所以如果更改设置后还是和原来一样的错误结果，可以试试清除浏览器缓存。","source":"_posts/hexo git.md","raw":"title: Hexo搭建githubpage博客\ntags:\n  - hexo\n  - githubpage\n  - hexo-admin\ncategories: hexo\ndate: 2017-02-20 10:01:00\n---\n<Excerpt in index | 首页摘要>\n这是一篇很详尽的独立博客搭建教程 里面介绍了github、Hexo和hexo-admin设置等过程<!-- more -->\n<The rest of contents | 余下全文>\n## 系统环境配置\n要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！\n\n### 安装Node.js\n下载:[Node.js](https://nodejs.org/en/)\n参考地址：[安装Node.js](http://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n### 安装Git\n下载地址：[git](http://git-scm.com/download/)\n\n### 安装hexo\n\n``` bash\n$ cd d:/hexo\n```\n\n``` bash\n$ npm install hexo-cli -g\n```\n\n``` bash\n$ hexo init blog\n```\n\n``` bash\n$ cd blog\n```\n\n``` bash\n$ npm install\n```\n\n``` bash\n$ hexo s -g #生成预览\n```\n\n$ hexo g == hexo generate  生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\n$ hexo s == hexo server 启动本地web服务，用于博客的预览\n$ hexo d == hexo deploy 部署播客到远端（比如github, heroku等平台）\n\n现在我们打开http://localhost:4000/ 已经可以看到一篇内置的blog了。\n![logo](hexo git/1.jpeg)\n\n\n目前我安装所用的本地环境如下：(可以通过hexo -v查看)\nhexo-cli: 1.0.2\nos: Windows_NT 6.1.7601 win32 x64\nhttp_parser: 2.7.0\nnode: 7.5.0\nv8: 5.4.500.48\nuv: 1.10.2\nzlib: 1.2.8\nares: 1.10.1-DEV\nmodules: 51\nopenssl: 1.0.2k\nicu: 58.2\nunicode: 9.0\ncldr: 30.0.3\ntz: 2016j\n\n\n## Hexo主题设置\n这里以主题yilia为例进行说明。\n\n### 安装主题 (在blog目录下)\n``` bash\n$ hexo clean\n```\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n### 启用主题\n\n修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。\n\n### 更新主题\n``` bash\n$ cd themes/yilia\n```\n``` bash\n$ git pull\n```\n``` bash\n$ hexo s -g\n```\n现在打开http://localhost:4000/ ，会看到我们已经应用了一个新的主题。\n![logo](hexo git/1.jpeg)\n\n\n## Github Pages设置\n\n### 什么是Github Pages\n\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。\n\n在这里我创建了一个github repo叫做 smallwenzi.github.io. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接http://smallwenzi.github.io/ 访问了。\n\n### 配置SSHKey\n我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。\n\n#### 检查 SSH keys的设置\n首先我们需要检查你电脑上现有的 ssh key：\n~/.ssh目录是否存在\n若不存在\n```\nssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n注意 1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n注意：输入密码的时候没有 * 字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n ![logo](hexo git/5.png)\n### 添加 SSH Key 到 GitHub\n在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。\n\n1、打开本地 id_rsa.pub 文件（ 参考地址 C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n\n2、登陆 GitHub 系统。点击右上角的 Account Settings--->SSH KEY AND GPG KEY  ---> new ssh key\n3、把你本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了\n\n## 部署Hexo到Github Pages\n\n这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过http://smallwenzi.github.io/访问了。\n首先需要明白所谓部署到github的原理。\n1之前步骤中在Github上创建的那个特别的repo（smallwenzi.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接http://smallwenzi.github.io来直接访问。\n2Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。\n3需要将hexo生成的静态网站，提交(git commit)到github上。\n明白了原理，怎么做自然就清晰了。\n\n### 使用hexo deploy部署\nhexo deploy可以部署到很多平台，具体可以参考这个[链接](https://hexo.io/docs/deployment.html). 如果部署到github，需要在配置文件_config.xml中作如下修改：\ndeploy:\n  type: git\n  repo: git@github.com:smallwenzi/smallwenzi.github.io.git\n  branch: master\n  \n ![logo](hexo git/2.png)\n然后在命令行中执行 (在blog目录下)\n``` bash\n$ npm install hexo-deployer-git --save\n```\n``` bash\n$ hexo d -g\n```\n即可完成部署。现在打开https://smallwenzi.github.io/ ，\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至smallwenzi.github.io的git目录下，然后使用git commit命令提交代码到smallwenzi.github.io这个repo的master branch上。\n\n\n### Hexo 主题配置\n\n每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。\n以我们使用的yilia主题为例，其提供如下的配置项（theme\\yilia_config.yml）：\n[参考](https://github.com/litten/hexo-theme-yilia).\n\n\n## Hexo 使用本地图片\n首先确认 _config.yml 中有 post_asset_folder:true 。\n在 hexo 目录，执行\n\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n假设在\n\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n\n![logo](hexo git/3.png)\n\n## Hexo 后台管理配置\n在blog 跟目录下\n``` bash\n$ npm install --save hexo-admin \n```\n``` bash\n$ hexo server -d\n```\n如下图：\n![logo](hexo git/4.png)\n[参考](https://github.com/jaredly/hexo-admin)\n\n## github后台绑上自己的域名\n\n### 申请一个域名\n我用的新网买的域名（yanwentan.xyz），买好之后进入域名控制台可以看到自己买的域名。\n![logo](hexo git/7.png)\n设置域名解析记录，注意记录类型设置为CNAME，记录值为刚才github上仓库的名字，注意没有https://。\n![logo](hexo git/8.png)\n\n为了能够从别的域名跳转到github页面，还需要在github中进行设置：\n在博客source目录新增CNAME 文件 \n文件内容 添加自己的域名：blog.yanwentan.xyz\n\n这样 通过hexo d -g 部署 就会 设置 域名 显示\n\n## 免费申请https\nhttps://dash.cloudflare.com 注册一个账号，注册成功后\n* 新增站点yanwentan.xyz\n![logo](hexo git/10.png)\n* 修改dns映射\n![logo](hexo git/12.png)\nNS\tgemma.ns.cloudflare.com\nNS\thenrik.ns.cloudflare.com\n生效时间24-48小时 \n* 添加cname记录\n添加 blog 映射：smallwenzi.github.io\n![logo](hexo git/11.png)\n设置完成使用 https://blog.yanwentan.xyz/ 访问\n* 点击上图ssl\\TLS  设置您的 SSL/TLS 加密模式为 灵活\n![logo](hexo git/13.png)\n* 点击上图 边缘服务器 进行设置 https\n![logo](hexo git/15.png)\n* 点击 analytics 查看网站访问流量\n![logo](hexo git/16.png)\n\n\n## 注意事项（避雷）\n* 创建.cn/.com等域名可能需要进行实名认证才能正确解析，这在域名控制器中会有提示，若域名解析成功，控制器中会显示DNS服务器地址表示正常服务：\n\n\n* 在设置完成后不会立刻生效，需要等待一段时间（10~15分钟），这期间尽量不要因为无法访问而反复更改设置，会因为设置生效有时延而变得更加混乱。\n\n* 要注意浏览器自动缓存问题，在第一次输入后，如果不清除缓存，就算做了更改，浏览器还是会用上一次的DNS解析结果尽管这可能是错误的，所以如果更改设置后还是和原来一样的错误结果，可以试试清除浏览器缓存。","slug":"hexo git","published":1,"updated":"2020-08-08T05:06:13.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38o0021n6zqhrfhy0wm","content":"<p><excerpt in index | 首页摘要><br>这是一篇很详尽的独立博客搭建教程 里面介绍了github、Hexo和hexo-admin设置等过程<a id=\"more\"></a></excerpt></p>\n<p><the rest of contents | 余下全文></the></p>\n<h2 id=\"系统环境配置\"><a href=\"#系统环境配置\" class=\"headerlink\" title=\"系统环境配置\"></a>系统环境配置</h2><p>要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>下载:<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a><br>参考地址：<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\" target=\"_blank\" rel=\"noopener\">安装Node.js</a></p>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>下载地址：<a href=\"http://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">git</a></p>\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> d:/hexo</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -g <span class=\"comment\">#生成预览</span></span><br></pre></td></tr></table></figure>\n<p>$ hexo g == hexo generate  生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>$ hexo s == hexo server 启动本地web服务，用于博客的预览<br>$ hexo d == hexo deploy 部署播客到远端（比如github, heroku等平台）</p>\n<p>现在我们打开<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> 已经可以看到一篇内置的blog了。<br><img src=\"/2017/02/20/hexo git/1.jpeg\" alt=\"logo\"></p>\n<p>目前我安装所用的本地环境如下：(可以通过hexo -v查看)<br>hexo-cli: 1.0.2<br>os: Windows_NT 6.1.7601 win32 x64<br>http_parser: 2.7.0<br>node: 7.5.0<br>v8: 5.4.500.48<br>uv: 1.10.2<br>zlib: 1.2.8<br>ares: 1.10.1-DEV<br>modules: 51<br>openssl: 1.0.2k<br>icu: 58.2<br>unicode: 9.0<br>cldr: 30.0.3<br>tz: 2016j</p>\n<h2 id=\"Hexo主题设置\"><a href=\"#Hexo主题设置\" class=\"headerlink\" title=\"Hexo主题设置\"></a>Hexo主题设置</h2><p>这里以主题yilia为例进行说明。</p>\n<h3 id=\"安装主题-在blog目录下\"><a href=\"#安装主题-在blog目录下\" class=\"headerlink\" title=\"安装主题 (在blog目录下)\"></a>安装主题 (在blog目录下)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<h3 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h3><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。</p>\n<h3 id=\"更新主题\"><a href=\"#更新主题\" class=\"headerlink\" title=\"更新主题\"></a>更新主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/yilia</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -g</span><br></pre></td></tr></table></figure>\n<p>现在打开<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。<br><img src=\"/2017/02/20/hexo git/1.jpeg\" alt=\"logo\"></p>\n<h2 id=\"Github-Pages设置\"><a href=\"#Github-Pages设置\" class=\"headerlink\" title=\"Github Pages设置\"></a>Github Pages设置</h2><h3 id=\"什么是Github-Pages\"><a href=\"#什么是Github-Pages\" class=\"headerlink\" title=\"什么是Github Pages\"></a>什么是Github Pages</h3><p>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。<br>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。<br>这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。</p>\n<p>在这里我创建了一个github repo叫做 smallwenzi.github.io. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接<a href=\"http://smallwenzi.github.io/\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io/</a> 访问了。</p>\n<h3 id=\"配置SSHKey\"><a href=\"#配置SSHKey\" class=\"headerlink\" title=\"配置SSHKey\"></a>配置SSHKey</h3><p>我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。</p>\n<h4 id=\"检查-SSH-keys的设置\"><a href=\"#检查-SSH-keys的设置\" class=\"headerlink\" title=\"检查 SSH keys的设置\"></a>检查 SSH keys的设置</h4><p>首先我们需要检查你电脑上现有的 ssh key：<br>~/.ssh目录是否存在<br>若不存在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">注意 1: 此处的邮箱地址，你可以输入自己的邮箱地址；</span><br><span class=\"line\">注意2: 此处的「-C」的是大写的「C」</span><br><span class=\"line\">然后系统会要你输入密码：</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</span><br><span class=\"line\">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br><span class=\"line\">在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</span><br><span class=\"line\">注意：输入密码的时候没有 * 字样的，你直接输入就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">最后看到这样的界面，就成功设置ssh key了：</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/2017/02/20/hexo git/5.png\" alt=\"logo\"></p>\n<h3 id=\"添加-SSH-Key-到-GitHub\"><a href=\"#添加-SSH-Key-到-GitHub\" class=\"headerlink\" title=\"添加 SSH Key 到 GitHub\"></a>添加 SSH Key 到 GitHub</h3><p>在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。</p>\n<p>1、打开本地 id_rsa.pub 文件（ 参考地址 C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</p>\n<p>2、登陆 GitHub 系统。点击右上角的 Account Settings—&gt;SSH KEY AND GPG KEY  —&gt; new ssh key<br>3、把你本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了</p>\n<h2 id=\"部署Hexo到Github-Pages\"><a href=\"#部署Hexo到Github-Pages\" class=\"headerlink\" title=\"部署Hexo到Github Pages\"></a>部署Hexo到Github Pages</h2><p>这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过<a href=\"http://smallwenzi.github.io/访问了。\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io/访问了。</a><br>首先需要明白所谓部署到github的原理。<br>1之前步骤中在Github上创建的那个特别的repo（smallwenzi.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接<a href=\"http://smallwenzi.github.io来直接访问。\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io来直接访问。</a><br>2Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。<br>3需要将hexo生成的静态网站，提交(git commit)到github上。<br>明白了原理，怎么做自然就清晰了。</p>\n<h3 id=\"使用hexo-deploy部署\"><a href=\"#使用hexo-deploy部署\" class=\"headerlink\" title=\"使用hexo deploy部署\"></a>使用hexo deploy部署</h3><p>hexo deploy可以部署到很多平台，具体可以参考这个<a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">链接</a>. 如果部署到github，需要在配置文件_config.xml中作如下修改：<br>deploy:<br>  type: git<br>  repo: <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:smallwenzi/smallwenzi.github.io.git<br>  branch: master</p>\n<p> <img src=\"/2017/02/20/hexo git/2.png\" alt=\"logo\"><br>然后在命令行中执行 (在blog目录下)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n<p>即可完成部署。现在打开<a href=\"https://smallwenzi.github.io/\" target=\"_blank\" rel=\"noopener\">https://smallwenzi.github.io/</a> ，</p>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至smallwenzi.github.io的git目录下，然后使用git commit命令提交代码到smallwenzi.github.io这个repo的master branch上。</p>\n<h3 id=\"Hexo-主题配置\"><a href=\"#Hexo-主题配置\" class=\"headerlink\" title=\"Hexo 主题配置\"></a>Hexo 主题配置</h3><p>每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。<br>以我们使用的yilia主题为例，其提供如下的配置项（theme\\yilia_config.yml）：<br><a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">参考</a>.</p>\n<h2 id=\"Hexo-使用本地图片\"><a href=\"#Hexo-使用本地图片\" class=\"headerlink\" title=\"Hexo 使用本地图片\"></a>Hexo 使用本地图片</h2><p>首先确认 _config.yml 中有 post_asset_folder:true 。<br>在 hexo 目录，执行</p>\n<p>npm install <a href=\"https://github.com/CodeFalling/hexo-asset-image\" target=\"_blank\" rel=\"noopener\">https://github.com/CodeFalling/hexo-asset-image</a> –save<br>假设在</p>\n<p>MacGesture2-Publish<br>├── apppicker.jpg<br>├── logo.jpg<br>└── rules.jpg<br>MacGesture2-Publish.md</p>\n<p><img src=\"/2017/02/20/hexo git/3.png\" alt=\"logo\"></p>\n<h2 id=\"Hexo-后台管理配置\"><a href=\"#Hexo-后台管理配置\" class=\"headerlink\" title=\"Hexo 后台管理配置\"></a>Hexo 后台管理配置</h2><p>在blog 跟目录下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server -d</span><br></pre></td></tr></table></figure>\n<p>如下图：<br><img src=\"/2017/02/20/hexo git/4.png\" alt=\"logo\"><br><a href=\"https://github.com/jaredly/hexo-admin\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"github后台绑上自己的域名\"><a href=\"#github后台绑上自己的域名\" class=\"headerlink\" title=\"github后台绑上自己的域名\"></a>github后台绑上自己的域名</h2><h3 id=\"申请一个域名\"><a href=\"#申请一个域名\" class=\"headerlink\" title=\"申请一个域名\"></a>申请一个域名</h3><p>我用的新网买的域名（yanwentan.xyz），买好之后进入域名控制台可以看到自己买的域名。<br><img src=\"/2017/02/20/hexo git/7.png\" alt=\"logo\"><br>设置域名解析记录，注意记录类型设置为CNAME，记录值为刚才github上仓库的名字，注意没有https://。<br><img src=\"/2017/02/20/hexo git/8.png\" alt=\"logo\"></p>\n<p>为了能够从别的域名跳转到github页面，还需要在github中进行设置：<br>在博客source目录新增CNAME 文件<br>文件内容 添加自己的域名：blog.yanwentan.xyz</p>\n<p>这样 通过hexo d -g 部署 就会 设置 域名 显示</p>\n<h2 id=\"免费申请https\"><a href=\"#免费申请https\" class=\"headerlink\" title=\"免费申请https\"></a>免费申请https</h2><p><a href=\"https://dash.cloudflare.com\" target=\"_blank\" rel=\"noopener\">https://dash.cloudflare.com</a> 注册一个账号，注册成功后</p>\n<ul>\n<li>新增站点yanwentan.xyz<br><img src=\"/2017/02/20/hexo git/10.png\" alt=\"logo\"></li>\n<li>修改dns映射<br><img src=\"/2017/02/20/hexo git/12.png\" alt=\"logo\"><br>NS    gemma.ns.cloudflare.com<br>NS    henrik.ns.cloudflare.com<br>生效时间24-48小时 </li>\n<li>添加cname记录<br>添加 blog 映射：smallwenzi.github.io<br><img src=\"/2017/02/20/hexo git/11.png\" alt=\"logo\"><br>设置完成使用 <a href=\"https://blog.yanwentan.xyz/\">https://blog.yanwentan.xyz/</a> 访问</li>\n<li>点击上图ssl\\TLS  设置您的 SSL/TLS 加密模式为 灵活<br><img src=\"/2017/02/20/hexo git/13.png\" alt=\"logo\"></li>\n<li>点击上图 边缘服务器 进行设置 https<br><img src=\"/2017/02/20/hexo git/15.png\" alt=\"logo\"></li>\n<li>点击 analytics 查看网站访问流量<br><img src=\"/2017/02/20/hexo git/16.png\" alt=\"logo\"></li>\n</ul>\n<h2 id=\"注意事项（避雷）\"><a href=\"#注意事项（避雷）\" class=\"headerlink\" title=\"注意事项（避雷）\"></a>注意事项（避雷）</h2><ul>\n<li>创建.cn/.com等域名可能需要进行实名认证才能正确解析，这在域名控制器中会有提示，若域名解析成功，控制器中会显示DNS服务器地址表示正常服务：</li>\n</ul>\n<ul>\n<li><p>在设置完成后不会立刻生效，需要等待一段时间（10~15分钟），这期间尽量不要因为无法访问而反复更改设置，会因为设置生效有时延而变得更加混乱。</p>\n</li>\n<li><p>要注意浏览器自动缓存问题，在第一次输入后，如果不清除缓存，就算做了更改，浏览器还是会用上一次的DNS解析结果尽管这可能是错误的，所以如果更改设置后还是和原来一样的错误结果，可以试试清除浏览器缓存。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><excerpt in index | 首页摘要><br>这是一篇很详尽的独立博客搭建教程 里面介绍了github、Hexo和hexo-admin设置等过程</excerpt></p>","more":"<p></p>\n<p><the rest of contents | 余下全文></the></p>\n<h2 id=\"系统环境配置\"><a href=\"#系统环境配置\" class=\"headerlink\" title=\"系统环境配置\"></a>系统环境配置</h2><p>要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>下载:<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a><br>参考地址：<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\" target=\"_blank\" rel=\"noopener\">安装Node.js</a></p>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>下载地址：<a href=\"http://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">git</a></p>\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> d:/hexo</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -g <span class=\"comment\">#生成预览</span></span><br></pre></td></tr></table></figure>\n<p>$ hexo g == hexo generate  生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>$ hexo s == hexo server 启动本地web服务，用于博客的预览<br>$ hexo d == hexo deploy 部署播客到远端（比如github, heroku等平台）</p>\n<p>现在我们打开<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> 已经可以看到一篇内置的blog了。<br><img src=\"/2017/02/20/hexo git/1.jpeg\" alt=\"logo\"></p>\n<p>目前我安装所用的本地环境如下：(可以通过hexo -v查看)<br>hexo-cli: 1.0.2<br>os: Windows_NT 6.1.7601 win32 x64<br>http_parser: 2.7.0<br>node: 7.5.0<br>v8: 5.4.500.48<br>uv: 1.10.2<br>zlib: 1.2.8<br>ares: 1.10.1-DEV<br>modules: 51<br>openssl: 1.0.2k<br>icu: 58.2<br>unicode: 9.0<br>cldr: 30.0.3<br>tz: 2016j</p>\n<h2 id=\"Hexo主题设置\"><a href=\"#Hexo主题设置\" class=\"headerlink\" title=\"Hexo主题设置\"></a>Hexo主题设置</h2><p>这里以主题yilia为例进行说明。</p>\n<h3 id=\"安装主题-在blog目录下\"><a href=\"#安装主题-在blog目录下\" class=\"headerlink\" title=\"安装主题 (在blog目录下)\"></a>安装主题 (在blog目录下)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<h3 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h3><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。</p>\n<h3 id=\"更新主题\"><a href=\"#更新主题\" class=\"headerlink\" title=\"更新主题\"></a>更新主题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/yilia</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -g</span><br></pre></td></tr></table></figure>\n<p>现在打开<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。<br><img src=\"/2017/02/20/hexo git/1.jpeg\" alt=\"logo\"></p>\n<h2 id=\"Github-Pages设置\"><a href=\"#Github-Pages设置\" class=\"headerlink\" title=\"Github Pages设置\"></a>Github Pages设置</h2><h3 id=\"什么是Github-Pages\"><a href=\"#什么是Github-Pages\" class=\"headerlink\" title=\"什么是Github Pages\"></a>什么是Github Pages</h3><p>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。<br>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。<br>这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。</p>\n<p>在这里我创建了一个github repo叫做 smallwenzi.github.io. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接<a href=\"http://smallwenzi.github.io/\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io/</a> 访问了。</p>\n<h3 id=\"配置SSHKey\"><a href=\"#配置SSHKey\" class=\"headerlink\" title=\"配置SSHKey\"></a>配置SSHKey</h3><p>我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。</p>\n<h4 id=\"检查-SSH-keys的设置\"><a href=\"#检查-SSH-keys的设置\" class=\"headerlink\" title=\"检查 SSH keys的设置\"></a>检查 SSH keys的设置</h4><p>首先我们需要检查你电脑上现有的 ssh key：<br>~/.ssh目录是否存在<br>若不存在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">注意 1: 此处的邮箱地址，你可以输入自己的邮箱地址；</span><br><span class=\"line\">注意2: 此处的「-C」的是大写的「C」</span><br><span class=\"line\">然后系统会要你输入密码：</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</span><br><span class=\"line\">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br><span class=\"line\">在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</span><br><span class=\"line\">注意：输入密码的时候没有 * 字样的，你直接输入就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">最后看到这样的界面，就成功设置ssh key了：</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/2017/02/20/hexo git/5.png\" alt=\"logo\"></p>\n<h3 id=\"添加-SSH-Key-到-GitHub\"><a href=\"#添加-SSH-Key-到-GitHub\" class=\"headerlink\" title=\"添加 SSH Key 到 GitHub\"></a>添加 SSH Key 到 GitHub</h3><p>在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。</p>\n<p>1、打开本地 id_rsa.pub 文件（ 参考地址 C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</p>\n<p>2、登陆 GitHub 系统。点击右上角的 Account Settings—&gt;SSH KEY AND GPG KEY  —&gt; new ssh key<br>3、把你本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了</p>\n<h2 id=\"部署Hexo到Github-Pages\"><a href=\"#部署Hexo到Github-Pages\" class=\"headerlink\" title=\"部署Hexo到Github Pages\"></a>部署Hexo到Github Pages</h2><p>这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过<a href=\"http://smallwenzi.github.io/访问了。\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io/访问了。</a><br>首先需要明白所谓部署到github的原理。<br>1之前步骤中在Github上创建的那个特别的repo（smallwenzi.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接<a href=\"http://smallwenzi.github.io来直接访问。\" target=\"_blank\" rel=\"noopener\">http://smallwenzi.github.io来直接访问。</a><br>2Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。<br>3需要将hexo生成的静态网站，提交(git commit)到github上。<br>明白了原理，怎么做自然就清晰了。</p>\n<h3 id=\"使用hexo-deploy部署\"><a href=\"#使用hexo-deploy部署\" class=\"headerlink\" title=\"使用hexo deploy部署\"></a>使用hexo deploy部署</h3><p>hexo deploy可以部署到很多平台，具体可以参考这个<a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">链接</a>. 如果部署到github，需要在配置文件_config.xml中作如下修改：<br>deploy:<br>  type: git<br>  repo: <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:smallwenzi/smallwenzi.github.io.git<br>  branch: master</p>\n<p> <img src=\"/2017/02/20/hexo git/2.png\" alt=\"logo\"><br>然后在命令行中执行 (在blog目录下)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n<p>即可完成部署。现在打开<a href=\"https://smallwenzi.github.io/\" target=\"_blank\" rel=\"noopener\">https://smallwenzi.github.io/</a> ，</p>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至smallwenzi.github.io的git目录下，然后使用git commit命令提交代码到smallwenzi.github.io这个repo的master branch上。</p>\n<h3 id=\"Hexo-主题配置\"><a href=\"#Hexo-主题配置\" class=\"headerlink\" title=\"Hexo 主题配置\"></a>Hexo 主题配置</h3><p>每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。<br>以我们使用的yilia主题为例，其提供如下的配置项（theme\\yilia_config.yml）：<br><a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">参考</a>.</p>\n<h2 id=\"Hexo-使用本地图片\"><a href=\"#Hexo-使用本地图片\" class=\"headerlink\" title=\"Hexo 使用本地图片\"></a>Hexo 使用本地图片</h2><p>首先确认 _config.yml 中有 post_asset_folder:true 。<br>在 hexo 目录，执行</p>\n<p>npm install <a href=\"https://github.com/CodeFalling/hexo-asset-image\" target=\"_blank\" rel=\"noopener\">https://github.com/CodeFalling/hexo-asset-image</a> –save<br>假设在</p>\n<p>MacGesture2-Publish<br>├── apppicker.jpg<br>├── logo.jpg<br>└── rules.jpg<br>MacGesture2-Publish.md</p>\n<p><img src=\"/2017/02/20/hexo git/3.png\" alt=\"logo\"></p>\n<h2 id=\"Hexo-后台管理配置\"><a href=\"#Hexo-后台管理配置\" class=\"headerlink\" title=\"Hexo 后台管理配置\"></a>Hexo 后台管理配置</h2><p>在blog 跟目录下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server -d</span><br></pre></td></tr></table></figure>\n<p>如下图：<br><img src=\"/2017/02/20/hexo git/4.png\" alt=\"logo\"><br><a href=\"https://github.com/jaredly/hexo-admin\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"github后台绑上自己的域名\"><a href=\"#github后台绑上自己的域名\" class=\"headerlink\" title=\"github后台绑上自己的域名\"></a>github后台绑上自己的域名</h2><h3 id=\"申请一个域名\"><a href=\"#申请一个域名\" class=\"headerlink\" title=\"申请一个域名\"></a>申请一个域名</h3><p>我用的新网买的域名（yanwentan.xyz），买好之后进入域名控制台可以看到自己买的域名。<br><img src=\"/2017/02/20/hexo git/7.png\" alt=\"logo\"><br>设置域名解析记录，注意记录类型设置为CNAME，记录值为刚才github上仓库的名字，注意没有https://。<br><img src=\"/2017/02/20/hexo git/8.png\" alt=\"logo\"></p>\n<p>为了能够从别的域名跳转到github页面，还需要在github中进行设置：<br>在博客source目录新增CNAME 文件<br>文件内容 添加自己的域名：blog.yanwentan.xyz</p>\n<p>这样 通过hexo d -g 部署 就会 设置 域名 显示</p>\n<h2 id=\"免费申请https\"><a href=\"#免费申请https\" class=\"headerlink\" title=\"免费申请https\"></a>免费申请https</h2><p><a href=\"https://dash.cloudflare.com\" target=\"_blank\" rel=\"noopener\">https://dash.cloudflare.com</a> 注册一个账号，注册成功后</p>\n<ul>\n<li>新增站点yanwentan.xyz<br><img src=\"/2017/02/20/hexo git/10.png\" alt=\"logo\"></li>\n<li>修改dns映射<br><img src=\"/2017/02/20/hexo git/12.png\" alt=\"logo\"><br>NS    gemma.ns.cloudflare.com<br>NS    henrik.ns.cloudflare.com<br>生效时间24-48小时 </li>\n<li>添加cname记录<br>添加 blog 映射：smallwenzi.github.io<br><img src=\"/2017/02/20/hexo git/11.png\" alt=\"logo\"><br>设置完成使用 <a href=\"https://blog.yanwentan.xyz/\">https://blog.yanwentan.xyz/</a> 访问</li>\n<li>点击上图ssl\\TLS  设置您的 SSL/TLS 加密模式为 灵活<br><img src=\"/2017/02/20/hexo git/13.png\" alt=\"logo\"></li>\n<li>点击上图 边缘服务器 进行设置 https<br><img src=\"/2017/02/20/hexo git/15.png\" alt=\"logo\"></li>\n<li>点击 analytics 查看网站访问流量<br><img src=\"/2017/02/20/hexo git/16.png\" alt=\"logo\"></li>\n</ul>\n<h2 id=\"注意事项（避雷）\"><a href=\"#注意事项（避雷）\" class=\"headerlink\" title=\"注意事项（避雷）\"></a>注意事项（避雷）</h2><ul>\n<li>创建.cn/.com等域名可能需要进行实名认证才能正确解析，这在域名控制器中会有提示，若域名解析成功，控制器中会显示DNS服务器地址表示正常服务：</li>\n</ul>\n<ul>\n<li><p>在设置完成后不会立刻生效，需要等待一段时间（10~15分钟），这期间尽量不要因为无法访问而反复更改设置，会因为设置生效有时延而变得更加混乱。</p>\n</li>\n<li><p>要注意浏览器自动缓存问题，在第一次输入后，如果不清除缓存，就算做了更改，浏览器还是会用上一次的DNS解析结果尽管这可能是错误的，所以如果更改设置后还是和原来一样的错误结果，可以试试清除浏览器缓存。</p>\n</li>\n</ul>"},{"title":"nutch 坑","author":"wen","date":"2019-11-21T02:05:00.000Z","_content":"\n每次运行nutch都会在/tmp/hadoop-aaws/mapred/staging产生一个临时目录，若不定时清理，很容易inode(在同一个路径下，一级子目录的个数是有限制的)\n\n\n# 统计当前文件夹下目录的个数:\n```\nls -l |grep \"^d\"|wc -l\n```\n\n# 统计当前文件夹下文件的个数:\n```\nls -l |grep \"^-\"|wc -l\n```\n\n#  统计当前文件夹下文件的个数，包括子文件夹里的 :\n```\nls -lR|grep \"^-\"|wc -l\n```\n\n \n# 统计文件夹下目录的个数，包括子文件夹里的:\n```\nls -lR|grep \"^d\"|wc -l\n```","source":"_posts/tch-坑.md","raw":"title: nutch 坑\nauthor: wen\ntags:\n  - nutch\ncategories: []\ndate: 2019-11-21 10:05:00\n---\n\n每次运行nutch都会在/tmp/hadoop-aaws/mapred/staging产生一个临时目录，若不定时清理，很容易inode(在同一个路径下，一级子目录的个数是有限制的)\n\n\n# 统计当前文件夹下目录的个数:\n```\nls -l |grep \"^d\"|wc -l\n```\n\n# 统计当前文件夹下文件的个数:\n```\nls -l |grep \"^-\"|wc -l\n```\n\n#  统计当前文件夹下文件的个数，包括子文件夹里的 :\n```\nls -lR|grep \"^-\"|wc -l\n```\n\n \n# 统计文件夹下目录的个数，包括子文件夹里的:\n```\nls -lR|grep \"^d\"|wc -l\n```","slug":"tch-坑","published":1,"updated":"2020-02-17T15:08:47.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce38q0024n6zqocsv3q83","content":"<p>每次运行nutch都会在/tmp/hadoop-aaws/mapred/staging产生一个临时目录，若不定时清理，很容易inode(在同一个路径下，一级子目录的个数是有限制的)</p>\n<h1 id=\"统计当前文件夹下目录的个数\"><a href=\"#统计当前文件夹下目录的个数\" class=\"headerlink\" title=\"统计当前文件夹下目录的个数:\"></a>统计当前文件夹下目录的个数:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l |grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计当前文件夹下文件的个数\"><a href=\"#统计当前文件夹下文件的个数\" class=\"headerlink\" title=\"统计当前文件夹下文件的个数:\"></a>统计当前文件夹下文件的个数:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l |grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计当前文件夹下文件的个数，包括子文件夹里的\"><a href=\"#统计当前文件夹下文件的个数，包括子文件夹里的\" class=\"headerlink\" title=\"统计当前文件夹下文件的个数，包括子文件夹里的 :\"></a>统计当前文件夹下文件的个数，包括子文件夹里的 :</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lR|grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计文件夹下目录的个数，包括子文件夹里的\"><a href=\"#统计文件夹下目录的个数，包括子文件夹里的\" class=\"headerlink\" title=\"统计文件夹下目录的个数，包括子文件夹里的:\"></a>统计文件夹下目录的个数，包括子文件夹里的:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lR|grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>每次运行nutch都会在/tmp/hadoop-aaws/mapred/staging产生一个临时目录，若不定时清理，很容易inode(在同一个路径下，一级子目录的个数是有限制的)</p>\n<h1 id=\"统计当前文件夹下目录的个数\"><a href=\"#统计当前文件夹下目录的个数\" class=\"headerlink\" title=\"统计当前文件夹下目录的个数:\"></a>统计当前文件夹下目录的个数:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l |grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计当前文件夹下文件的个数\"><a href=\"#统计当前文件夹下文件的个数\" class=\"headerlink\" title=\"统计当前文件夹下文件的个数:\"></a>统计当前文件夹下文件的个数:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l |grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计当前文件夹下文件的个数，包括子文件夹里的\"><a href=\"#统计当前文件夹下文件的个数，包括子文件夹里的\" class=\"headerlink\" title=\"统计当前文件夹下文件的个数，包括子文件夹里的 :\"></a>统计当前文件夹下文件的个数，包括子文件夹里的 :</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lR|grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计文件夹下目录的个数，包括子文件夹里的\"><a href=\"#统计文件夹下目录的个数，包括子文件夹里的\" class=\"headerlink\" title=\"统计文件夹下目录的个数，包括子文件夹里的:\"></a>统计文件夹下目录的个数，包括子文件夹里的:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lR|grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>"},{"title":"springFramework源码--IOC 容器","author":"wen","date":"2020-08-08T06:45:00.000Z","_content":"Spring framework是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等\n\nIOC容器（ Inversion of Control ）是Spring Framework 最核心部分，它管理着Spring应用中bean的创建、 配置和管理，也叫依赖注入（dependency injection ）\n\n# 什么是IOC容器\n## 没有IOC容器\n按照传统的做法，每个对象负责管理与自己相互协作的对象 \n（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代 码。\n\n我们假定一个在线书店，通过BookService获取书籍：\n```\npublic class BookService {\n    private HikariConfig config = new HikariConfig();\n    private DataSource dataSource = new HikariDataSource(config);\n\n    public Book getBook(long bookId) {\n        try (Connection conn = dataSource.getConnection()) {\n            ...\n            return book;\n        }\n    }\n}\n```\n\n* 这种方式使用new的方式创建对象，\n* 若测试BookService，是复杂的，因为必须要在真实的数据库环境下执行。\n\n* 从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n\n\n## 有IOC容器\n核心问题是：\n\n* 谁负责创建组件？\n* 谁负责根据依赖关系组装组件？\n* 销毁时，如何按依赖顺序正确销毁？\n解决这一问题的核心方案就是IoC。\n\n传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：\n\n在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。\n\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，\n例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：\n\n```\npublic class BookService { \n      private DataSource dataSource;\n    public BookService(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：\n\n* BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；\n* 测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。\n\n因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\n\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系.\n以下这种通过在JavaConfig中进行显式配置bean。 \n```\n@Configuration\npublic Class JavaBean{\n\n@Bean\n public HikariConfig hikariConfig(){\n  return new HikariConfig();\n }\n @Bean\n public DataSource dataSource(HikariConfig config){\n return new HikariDataSource(config);\n }\n @Bean\n public BookService bookService(DataSource dataSource){\n return new BookService(dataSource);\n }\n \n}\n\n```\n\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\n\n# 依赖注入的方式\n\n* 通过构造方法注入\n\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired\n    public BookService(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n* 通过方法注入\n\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired\n    public void setDataSource(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出 \n一个异常。为了避免异常的出现，你可以将@Autowired的 \nrequired属性设置为false：\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired（required=false）\n    public void setDataSource(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n将required属性设置为false时，Spring会尝试执行自动装配，但 \n是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状 \n态。但是，把required属性设置为false时，你需要谨慎对待。如 \n果在你的代码中没有进行null检查的话，这个处于未装配状态的属性 \n有可能会出现NullPointerException。\n\n如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常， \n表明没有明确指定要选择哪个bean进行自动装配\n\n* 属性注入\n\n```\npublic class BookService { \n @Autowired\n      private DataSource dataSource;\n}\n```\n\n# Spring容器是\n* 从概念上讲：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。\n* 从具象化讲：在java项目中，我们使用实现了org.springframework.context.ApplicationContext接口的实现类。\n* 从代码上讲：一个Spring容器就是某个实现了ApplicationContext接口的类的实例。也就是说，从代码层面，Spring容器其实就是一个\n\n## BeanFactory\nBeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。\n\nBeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。\n\nBeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。\nDefaultListableBeanFactory类图：\n![DefaultListableBeanFactory类图](/Spring体系结构/DefaultListableBeanFactory.png)\n\n*  1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。\n是Spring bean容器的根接口，提供获取bean，是否包含bean,是否单例与原型，获取bean类型，bean 别名的方法 。它最主要的方法就是getBean(String beanName)。\n*  2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。\n * HierarchicalBeanFactory：提供父容器的访问功能\n \n * ListableBeanFactory：提供了批量获取Bean的方法\n \n * AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管理\n\n\n* 3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry\n主要单例bean的注册，生成实例，以及统计单例bean\n\n* 4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）\n继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁…\n* 5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。\n\n* 6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory\n\n* 7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。\n\n  实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition\nBeanFactory的源码： \n```\nhttps://docs.spring.io/spring/docs/5.1.18.BUILD-SNAPSHOT/javadoc-api/\n\npackage org.springframework.beans.factory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\n\npublic interface BeanFactory {\n\n\t/**\n\t * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&a会得到那个Factory\n\t */\n\tString FACTORY_BEAN_PREFIX = \"&\";\n\t/*\n\t * 五个不同形式的getBean方法，获取实例\n\t */\n\tObject getBean(String name) throws BeansException;\n\t<T> T getBean(String name, Class<T> requiredType) throws BeansException;\n\tObject getBean(String name, Object... args) throws BeansException;\n\t<T> T getBean(Class<T> requiredType) throws BeansException;\n\t<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n\t//2个不同形式 返回指定bean的提供程序，以允许按需延迟检索实例，包括可用性和唯一性选项。\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n\t<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\n\n\t/**\n\t *  bean 是否存在\n\t */\n\tboolean containsBean(String name);\n\n\t// 是否为单实例\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\n\t// 是否为原型（多实例）\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\n\t// 2个不同形式 名称、类型是否匹配\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\tboolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n\t // 2个不同形式 获取类型\n\t@Nullable\n\tClass<?> getType(String name) throws NoSuchBeanDefinitionException;\n\t@Nullable\n\tClass<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;\n\n\t// 根据实例的名字获取实例的别名\n\tString[] getAliases(String name);\n\n}\n\n```\n具体：\n　　1、5个获取实例的方法。getBean的重载方法。\n　　2、7个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。\n　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！\n总结：\n　　这13个方法，很明显，这是一个典型的工厂模式的工厂接口。\nAnnotationConfigApplicationContext 例子\n```\n从一个或多个\n基于Java的配置类中加载Spring应用上下文\n\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n\n```\n1. 从一个或多个基于Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。\n2. 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。\n3. 对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。\n\n## ApplicationContext\n如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。\n\nBeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： \n\n* （1）MessageSource, 提供国际化的消息访问  \n* （2）资源访问，如URL和文件  \n* （3）事件传播特性，即支持aop特性\n* （4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 \n\nApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。\n![AnnotationConfigApplicationContext类图](/Spring体系结构/AnnotationConfigApplicationContext.png)\n\n### ApplicationContext常用实现类\t作用\n\n* AnnotationConfigApplicationContext\t从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。\n* ClassPathXmlApplicationContext\t从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。\n* FileSystemXmlApplicationContext\t从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。\n* AnnotationConfigWebApplicationContext\t专门为web应用准备的，适用于注解方式。\n* XmlWebApplicationContext\t从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。\n\n### 三种装配机制：\n\n* 在XMl中进行显示配置\n* 在Java中进行显示配置\n* 隐式的bean发现机制和自动装配\n\t* 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。\n\t* 自动装配（autowiring）：Spring自动满足bean之间的依赖。\n    \n（使用的优先性: 3>2>1）尽可能地使用自动配置的机制，显示配置越少越好。当必须使用显示配置bean的时候（如：有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才使用XML。\n代码示例：\n\n通过xml文件将配置加载到IOC容器中\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n     <!--若没写id，则默认为com.test.Man#0,#0为一个计数形式-->\n    <bean id=\"man\" class=\"com.test.Man\"></bean>\n</beans>\n```\n```\npublic class Test {\n    public static void main(String[] args) {\n        //加载项目中的spring配置文件到容器\n        //ApplicationContext context = new ClassPathXmlApplicationContext(\"resouces/applicationContext.xml\");\n        //加载系统盘中的配置文件到容器\n        ApplicationContext context = new FileSystemXmlApplicationContext(\"E:/Spring/applicationContext.xml\");\n        //从容器中获取对象实例\n        Man man = context.getBean(Man.class);\n        man.driveCar();\n    }\n}\n```\n通过java注解的方式将配置加载到IOC容器\n```\n//同xml一样描述bean以及bean之间的依赖关系\n@Configuration\npublic class ManConfig {\n    @Bean\n    public Man man() {\n        return new Man(car());\n    }\n    @Bean\n    public Car car() {\n        return new QQCar();\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        //从java注解的配置中加载配置到容器\n        ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class);\n        //从容器中获取对象实例\n        Man man = context.getBean(Man.class);\n        man.driveCar();\n    }\n}\n```\n隐式的bean发现机制和自动装配\n```\n/**\n * 这是一个游戏光盘的实现\n */\n//这个简单的注解表明该类回作为组件类，并告知Spring要为这个创建bean。\n@Component\npublic class GameDisc implements Disc{\n    @Override\n    public void play() {\n        System.out.println(\"我是马里奥游戏光盘。\");\n    }\n}\n```\n不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找@Component注解的类，并为其创建bean。\n```\n@Configuration\n@ComponentScan\npublic class DiscConfig {\n}\n```\n我们在DiscConfig上加了一个@ComponentScan注解表示在Spring中开启了组件扫描，默认扫描与配置类相同的包，就可以扫描到这个GameDisc的Bean了。这就是Spring的自动装配机制。\n\n由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。也可以为bean设置lazy-init属性为true，即Spring容器将不会预先初始化该bean。\n\n\n# 常用注解\n## @Configuration\n定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。\n\n## @ComponentScan\n该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <context:component-scan>。\n\n* 指定包扫描,主要扫描该包下@Controller @Service @Respsitory @Component四个注解\n```\n@ComponentScan(value=\"com.songzixian\")\n```\n* 指定排除要扫描的包\n```\n@ComponentScan(value=\"com.songzixian\",excludeFilters ={@ComponentScan.Filter (type= FilterType.ANNOTATION,classes ={Component.class,Repository.class,Controller.class,Service.class})} )\n\n```\n* 指定要扫描的包\nuseDefaultFilters = false默认是true,需要改为false该类才生效\n```\n@ComponentScan(value=\"com.songzixian\",includeFilters ={@ComponentScan.Filter (type= FilterType.ANNOTATION,classes ={Component.class,Repository.class,Controller.class,Service.class})},useDefaultFilters = false)\n```\n\n## @Bean\n注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中\n\n## @Autowired\n 注解对自动装配何时何处被实现提供了更多细粒度的控制\n \n ## @Qualifier \n自动装配，如果容器中某个bean有多个实例，想要获取指定的的实例，可以用@Qualifier\n\n## @scope\n  用来配置 spring bean 的作用域，它标识 bean 的作用域。默认值是单例\n\n  * 1、singleton:单例模式,全局有且仅有一个实例\n\n  * 2、prototype:原型模式,每次获取Bean的时候会有一个新的实例\n\n  * 3、request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效\n\n  * 4、session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效\n\n  * 5、global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。\n  \n## @Lazy\n 容器启动不创建对象，调用的时候创建对象\n \n## @Conditional（{WindowConditional.class}）\nWindowConditional 实现condition接口，返回true\n\n## @PostConstruct\n初始化 注解在初始化的方法上面\n\n##  @PreDestroy \n销毁 在容器销毁bean之前调用\n\n## @Controller\n标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.\n\n## @Service\n用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中\n\n##  @Resource\n@Resource的作用相当于@Autowired\n只不过@Autowired按byType自动注入，\n而@Resource默认按 byName自动注入\n@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略\n\n## @Component\n泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注\n\n## @RestController\nSpring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。\n\n## @RequestMapping\n类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。\n方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。\n\n## @RequestParam\n用于将请求参数区数据映射到功能处理方法的参数上\n```\n@RequestMapping(value=\"\", method=RequestMethod.POST)\n    public String postUser(@RequestParam(value=\"phoneNum\", required=true) String phoneNum ) String userName) {\n        userService.create(phoneNum, userName);\n        return \"success\";\n    }\n```\n## @Repository\n用于标注数据访问组件，即DAO组件\n\n## @Required\n适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。\n \n ## import\n  ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中\n  * 1、直接填class数组方式\n  ```\n  @Import({ 类名.class , 类名.class... })\npublic class TestDemo {\n\n}\n  ```\n  ## @PathVariable\n  映射 URL 绑定的占位符\n通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过\n\n@PathVariable(\"xxx\") 绑定到操作方法的入参中\n```\n@GetMapping(\"/users/{username}\")\npublic String userProfile(@PathVariable(\"username\") String user) {\n    return String.format(\"user %s\", user);\n}\n```\n @PathVariable和@RequestParam的区别就在于：@RequestParam用来获得静态的URL请求参数；@PathVariable用来获得动态的URL请求入参\n \n ## @ResponseBody\n 的作用其实是将java对象转为json格式的数据。\n ```\n @RequestMapping(\"/login.do\")\n@ResponseBody\npublic Object login(String name, String password, HttpSession session) {\n\tuser = userService.checkLogin(name, password);\n\tsession.setAttribute(\"user\", user);\n\treturn new JsonResult(user);\n}\n ```\n ## @RequestBody\n 是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，\n封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。\n如上面的登录后台代码可以改为：\n```\n@RequestMapping(\"/login.do\")\n@ResponseBody\npublic Object login(@RequestBody User loginUuser, HttpSession session) {\n\tuser = userService.checkLogin(loginUser);\n\tsession.setAttribute(\"user\", user);\n\treturn new JsonResult(user);\n}\n```\n## @PropertySource\n目的是加载指定的属性文件\n```\n@PropertySource(value = {\"classpath:people.properties\"},ignoreResourceNotFound = false,encoding = \"UTF-8\",name = \"people.properties\")\npublic class PeopleProperties {\n \n    private String name;\n \n    private int age;\n     public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n\n\n}\n```\npeople.properties内容如下：\n```\nage=10\nname=xiaohua\nhistory=beijing\n```\n##ConfigurationProperties\n是类级别的注解\n```\n@PropertySource(value = {\"classpath:people.properties\"},ignoreResourceNotFound = false,encoding = \"UTF-8\",name = \"people.properties\")\n@ConfigurationProperties(prefix = \"female\",ignoreUnknownFields=true,ignoreInvalidFields=true)\npublic class PeopleProperties {\n \n    private String name;\n \n    private int age;\n     public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n\n}\n```\n在PeopleProperties类中增加了ConfigurationProperties注解，并且指明了属性的前缀为female。这样Springboot在处理的时候，会去扫描当前类中的所有字段并进行属性的查找以及组装。比如我们配置的prefix = \"female\"，PeopleProperties类中有一个name字段，则female字段需要匹配的属性是prefix+字段=female.name。\n\n@ConfigurationProperties(prefix = \"female\",ignoreUnknownFields=true,ignoreInvalidFields=true)\n* ignoreUnknownFields：忽略未知的字段。\n\n* ignoreInvalidFields：是否忽略验证失败的字段。这个怎么理解呢？比如我们在配置文件中配置了一个字符串类型的变量，类中的字段是int类型，那肯定会报错的。如果出现这种情况我们可以容忍，则需要配置该属性值为true。该参数值默认为false。\n注意使用该注解，bean一定有Set与Get方法，否则取不出对应的属性值。\npeople.properties内容如下：\n```\nfemale.age=10\nfemale.name=xiaohua\nfemale.history=beijing\n```\n## @Value\n通过@Value将外部配置文件的值动态注入到Bean中。配置文件主要有两类：\n\n* application.properties。application.properties在spring boot启动时默认加载此文件\n自定义属性文件。自定义属性文件通过@PropertySource加载。* @PropertySource可以同时加载多个文件，也可以加载单个文件。如果相同第一个属性文件和第二属性文件存在相同key，则最后一个属性文件里的key启作用。加载文件的路径也可以配置变量，如下文的${anotherfile.configinject}，此值定义在第一个属性文件config.properties\n```\n@Value(\"${app.name}\")\n    private String appName; // 这里的值来自application.properties，spring boot启动时默认加载此文件\n```\n\n\n# 无侵入容器\n在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n* 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n* 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\n# 官方文档：\nhttps://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core","source":"_posts/spring源码（一）.md","raw":"title: springFramework源码--IOC 容器\nauthor: wen\ntags:\n  - IOC容器\n  - 依赖注入\n  - DI\n  - Inversion of Control\ncategories:\n  - spring\n  - SpringFramework\ndate: 2020-08-08 14:45:00\n---\nSpring framework是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等\n\nIOC容器（ Inversion of Control ）是Spring Framework 最核心部分，它管理着Spring应用中bean的创建、 配置和管理，也叫依赖注入（dependency injection ）\n\n# 什么是IOC容器\n## 没有IOC容器\n按照传统的做法，每个对象负责管理与自己相互协作的对象 \n（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代 码。\n\n我们假定一个在线书店，通过BookService获取书籍：\n```\npublic class BookService {\n    private HikariConfig config = new HikariConfig();\n    private DataSource dataSource = new HikariDataSource(config);\n\n    public Book getBook(long bookId) {\n        try (Connection conn = dataSource.getConnection()) {\n            ...\n            return book;\n        }\n    }\n}\n```\n\n* 这种方式使用new的方式创建对象，\n* 若测试BookService，是复杂的，因为必须要在真实的数据库环境下执行。\n\n* 从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n\n\n## 有IOC容器\n核心问题是：\n\n* 谁负责创建组件？\n* 谁负责根据依赖关系组装组件？\n* 销毁时，如何按依赖顺序正确销毁？\n解决这一问题的核心方案就是IoC。\n\n传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：\n\n在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。\n\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，\n例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：\n\n```\npublic class BookService { \n      private DataSource dataSource;\n    public BookService(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：\n\n* BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；\n* 测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。\n\n因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\n\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系.\n以下这种通过在JavaConfig中进行显式配置bean。 \n```\n@Configuration\npublic Class JavaBean{\n\n@Bean\n public HikariConfig hikariConfig(){\n  return new HikariConfig();\n }\n @Bean\n public DataSource dataSource(HikariConfig config){\n return new HikariDataSource(config);\n }\n @Bean\n public BookService bookService(DataSource dataSource){\n return new BookService(dataSource);\n }\n \n}\n\n```\n\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\n\n# 依赖注入的方式\n\n* 通过构造方法注入\n\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired\n    public BookService(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n* 通过方法注入\n\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired\n    public void setDataSource(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出 \n一个异常。为了避免异常的出现，你可以将@Autowired的 \nrequired属性设置为false：\n```\npublic class BookService { \n      private DataSource dataSource;\n      @Autowired（required=false）\n    public void setDataSource(DataSource dataSource){\n      this.DataSource=dataSource;\n    }\n}\n```\n将required属性设置为false时，Spring会尝试执行自动装配，但 \n是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状 \n态。但是，把required属性设置为false时，你需要谨慎对待。如 \n果在你的代码中没有进行null检查的话，这个处于未装配状态的属性 \n有可能会出现NullPointerException。\n\n如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常， \n表明没有明确指定要选择哪个bean进行自动装配\n\n* 属性注入\n\n```\npublic class BookService { \n @Autowired\n      private DataSource dataSource;\n}\n```\n\n# Spring容器是\n* 从概念上讲：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。\n* 从具象化讲：在java项目中，我们使用实现了org.springframework.context.ApplicationContext接口的实现类。\n* 从代码上讲：一个Spring容器就是某个实现了ApplicationContext接口的类的实例。也就是说，从代码层面，Spring容器其实就是一个\n\n## BeanFactory\nBeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。\n\nBeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。\n\nBeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。\nDefaultListableBeanFactory类图：\n![DefaultListableBeanFactory类图](/Spring体系结构/DefaultListableBeanFactory.png)\n\n*  1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。\n是Spring bean容器的根接口，提供获取bean，是否包含bean,是否单例与原型，获取bean类型，bean 别名的方法 。它最主要的方法就是getBean(String beanName)。\n*  2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。\n * HierarchicalBeanFactory：提供父容器的访问功能\n \n * ListableBeanFactory：提供了批量获取Bean的方法\n \n * AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管理\n\n\n* 3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry\n主要单例bean的注册，生成实例，以及统计单例bean\n\n* 4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）\n继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁…\n* 5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。\n\n* 6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory\n\n* 7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。\n\n  实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition\nBeanFactory的源码： \n```\nhttps://docs.spring.io/spring/docs/5.1.18.BUILD-SNAPSHOT/javadoc-api/\n\npackage org.springframework.beans.factory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\n\npublic interface BeanFactory {\n\n\t/**\n\t * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&a会得到那个Factory\n\t */\n\tString FACTORY_BEAN_PREFIX = \"&\";\n\t/*\n\t * 五个不同形式的getBean方法，获取实例\n\t */\n\tObject getBean(String name) throws BeansException;\n\t<T> T getBean(String name, Class<T> requiredType) throws BeansException;\n\tObject getBean(String name, Object... args) throws BeansException;\n\t<T> T getBean(Class<T> requiredType) throws BeansException;\n\t<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n\t//2个不同形式 返回指定bean的提供程序，以允许按需延迟检索实例，包括可用性和唯一性选项。\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n\t<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\n\n\t/**\n\t *  bean 是否存在\n\t */\n\tboolean containsBean(String name);\n\n\t// 是否为单实例\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\n\t// 是否为原型（多实例）\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\n\t// 2个不同形式 名称、类型是否匹配\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\tboolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n\t // 2个不同形式 获取类型\n\t@Nullable\n\tClass<?> getType(String name) throws NoSuchBeanDefinitionException;\n\t@Nullable\n\tClass<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;\n\n\t// 根据实例的名字获取实例的别名\n\tString[] getAliases(String name);\n\n}\n\n```\n具体：\n　　1、5个获取实例的方法。getBean的重载方法。\n　　2、7个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。\n　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！\n总结：\n　　这13个方法，很明显，这是一个典型的工厂模式的工厂接口。\nAnnotationConfigApplicationContext 例子\n```\n从一个或多个\n基于Java的配置类中加载Spring应用上下文\n\npackage com.yanwen.springTest;\n\nimport com.yanwen.springTest.service.MemberService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(\"com.yanwen.springTest\")\n@Configuration\npublic class AppConfig {\n   public static void main(String[] args){\n      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));\n    }\n}\n\npackage com.yanwen.springTest.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MemberService {\n}\n\n```\n1. 从一个或多个基于Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。\n2. 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。\n3. 对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。\n\n## ApplicationContext\n如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。\n\nBeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： \n\n* （1）MessageSource, 提供国际化的消息访问  \n* （2）资源访问，如URL和文件  \n* （3）事件传播特性，即支持aop特性\n* （4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 \n\nApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。\n![AnnotationConfigApplicationContext类图](/Spring体系结构/AnnotationConfigApplicationContext.png)\n\n### ApplicationContext常用实现类\t作用\n\n* AnnotationConfigApplicationContext\t从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。\n* ClassPathXmlApplicationContext\t从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。\n* FileSystemXmlApplicationContext\t从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。\n* AnnotationConfigWebApplicationContext\t专门为web应用准备的，适用于注解方式。\n* XmlWebApplicationContext\t从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。\n\n### 三种装配机制：\n\n* 在XMl中进行显示配置\n* 在Java中进行显示配置\n* 隐式的bean发现机制和自动装配\n\t* 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。\n\t* 自动装配（autowiring）：Spring自动满足bean之间的依赖。\n    \n（使用的优先性: 3>2>1）尽可能地使用自动配置的机制，显示配置越少越好。当必须使用显示配置bean的时候（如：有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才使用XML。\n代码示例：\n\n通过xml文件将配置加载到IOC容器中\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n     <!--若没写id，则默认为com.test.Man#0,#0为一个计数形式-->\n    <bean id=\"man\" class=\"com.test.Man\"></bean>\n</beans>\n```\n```\npublic class Test {\n    public static void main(String[] args) {\n        //加载项目中的spring配置文件到容器\n        //ApplicationContext context = new ClassPathXmlApplicationContext(\"resouces/applicationContext.xml\");\n        //加载系统盘中的配置文件到容器\n        ApplicationContext context = new FileSystemXmlApplicationContext(\"E:/Spring/applicationContext.xml\");\n        //从容器中获取对象实例\n        Man man = context.getBean(Man.class);\n        man.driveCar();\n    }\n}\n```\n通过java注解的方式将配置加载到IOC容器\n```\n//同xml一样描述bean以及bean之间的依赖关系\n@Configuration\npublic class ManConfig {\n    @Bean\n    public Man man() {\n        return new Man(car());\n    }\n    @Bean\n    public Car car() {\n        return new QQCar();\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        //从java注解的配置中加载配置到容器\n        ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class);\n        //从容器中获取对象实例\n        Man man = context.getBean(Man.class);\n        man.driveCar();\n    }\n}\n```\n隐式的bean发现机制和自动装配\n```\n/**\n * 这是一个游戏光盘的实现\n */\n//这个简单的注解表明该类回作为组件类，并告知Spring要为这个创建bean。\n@Component\npublic class GameDisc implements Disc{\n    @Override\n    public void play() {\n        System.out.println(\"我是马里奥游戏光盘。\");\n    }\n}\n```\n不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找@Component注解的类，并为其创建bean。\n```\n@Configuration\n@ComponentScan\npublic class DiscConfig {\n}\n```\n我们在DiscConfig上加了一个@ComponentScan注解表示在Spring中开启了组件扫描，默认扫描与配置类相同的包，就可以扫描到这个GameDisc的Bean了。这就是Spring的自动装配机制。\n\n由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。也可以为bean设置lazy-init属性为true，即Spring容器将不会预先初始化该bean。\n\n\n# 常用注解\n## @Configuration\n定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。\n\n## @ComponentScan\n该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <context:component-scan>。\n\n* 指定包扫描,主要扫描该包下@Controller @Service @Respsitory @Component四个注解\n```\n@ComponentScan(value=\"com.songzixian\")\n```\n* 指定排除要扫描的包\n```\n@ComponentScan(value=\"com.songzixian\",excludeFilters ={@ComponentScan.Filter (type= FilterType.ANNOTATION,classes ={Component.class,Repository.class,Controller.class,Service.class})} )\n\n```\n* 指定要扫描的包\nuseDefaultFilters = false默认是true,需要改为false该类才生效\n```\n@ComponentScan(value=\"com.songzixian\",includeFilters ={@ComponentScan.Filter (type= FilterType.ANNOTATION,classes ={Component.class,Repository.class,Controller.class,Service.class})},useDefaultFilters = false)\n```\n\n## @Bean\n注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中\n\n## @Autowired\n 注解对自动装配何时何处被实现提供了更多细粒度的控制\n \n ## @Qualifier \n自动装配，如果容器中某个bean有多个实例，想要获取指定的的实例，可以用@Qualifier\n\n## @scope\n  用来配置 spring bean 的作用域，它标识 bean 的作用域。默认值是单例\n\n  * 1、singleton:单例模式,全局有且仅有一个实例\n\n  * 2、prototype:原型模式,每次获取Bean的时候会有一个新的实例\n\n  * 3、request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效\n\n  * 4、session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效\n\n  * 5、global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。\n  \n## @Lazy\n 容器启动不创建对象，调用的时候创建对象\n \n## @Conditional（{WindowConditional.class}）\nWindowConditional 实现condition接口，返回true\n\n## @PostConstruct\n初始化 注解在初始化的方法上面\n\n##  @PreDestroy \n销毁 在容器销毁bean之前调用\n\n## @Controller\n标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.\n\n## @Service\n用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中\n\n##  @Resource\n@Resource的作用相当于@Autowired\n只不过@Autowired按byType自动注入，\n而@Resource默认按 byName自动注入\n@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略\n\n## @Component\n泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注\n\n## @RestController\nSpring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。\n\n## @RequestMapping\n类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。\n方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。\n\n## @RequestParam\n用于将请求参数区数据映射到功能处理方法的参数上\n```\n@RequestMapping(value=\"\", method=RequestMethod.POST)\n    public String postUser(@RequestParam(value=\"phoneNum\", required=true) String phoneNum ) String userName) {\n        userService.create(phoneNum, userName);\n        return \"success\";\n    }\n```\n## @Repository\n用于标注数据访问组件，即DAO组件\n\n## @Required\n适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。\n \n ## import\n  ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中\n  * 1、直接填class数组方式\n  ```\n  @Import({ 类名.class , 类名.class... })\npublic class TestDemo {\n\n}\n  ```\n  ## @PathVariable\n  映射 URL 绑定的占位符\n通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过\n\n@PathVariable(\"xxx\") 绑定到操作方法的入参中\n```\n@GetMapping(\"/users/{username}\")\npublic String userProfile(@PathVariable(\"username\") String user) {\n    return String.format(\"user %s\", user);\n}\n```\n @PathVariable和@RequestParam的区别就在于：@RequestParam用来获得静态的URL请求参数；@PathVariable用来获得动态的URL请求入参\n \n ## @ResponseBody\n 的作用其实是将java对象转为json格式的数据。\n ```\n @RequestMapping(\"/login.do\")\n@ResponseBody\npublic Object login(String name, String password, HttpSession session) {\n\tuser = userService.checkLogin(name, password);\n\tsession.setAttribute(\"user\", user);\n\treturn new JsonResult(user);\n}\n ```\n ## @RequestBody\n 是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，\n封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。\n如上面的登录后台代码可以改为：\n```\n@RequestMapping(\"/login.do\")\n@ResponseBody\npublic Object login(@RequestBody User loginUuser, HttpSession session) {\n\tuser = userService.checkLogin(loginUser);\n\tsession.setAttribute(\"user\", user);\n\treturn new JsonResult(user);\n}\n```\n## @PropertySource\n目的是加载指定的属性文件\n```\n@PropertySource(value = {\"classpath:people.properties\"},ignoreResourceNotFound = false,encoding = \"UTF-8\",name = \"people.properties\")\npublic class PeopleProperties {\n \n    private String name;\n \n    private int age;\n     public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n\n\n}\n```\npeople.properties内容如下：\n```\nage=10\nname=xiaohua\nhistory=beijing\n```\n##ConfigurationProperties\n是类级别的注解\n```\n@PropertySource(value = {\"classpath:people.properties\"},ignoreResourceNotFound = false,encoding = \"UTF-8\",name = \"people.properties\")\n@ConfigurationProperties(prefix = \"female\",ignoreUnknownFields=true,ignoreInvalidFields=true)\npublic class PeopleProperties {\n \n    private String name;\n \n    private int age;\n     public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n\n}\n```\n在PeopleProperties类中增加了ConfigurationProperties注解，并且指明了属性的前缀为female。这样Springboot在处理的时候，会去扫描当前类中的所有字段并进行属性的查找以及组装。比如我们配置的prefix = \"female\"，PeopleProperties类中有一个name字段，则female字段需要匹配的属性是prefix+字段=female.name。\n\n@ConfigurationProperties(prefix = \"female\",ignoreUnknownFields=true,ignoreInvalidFields=true)\n* ignoreUnknownFields：忽略未知的字段。\n\n* ignoreInvalidFields：是否忽略验证失败的字段。这个怎么理解呢？比如我们在配置文件中配置了一个字符串类型的变量，类中的字段是int类型，那肯定会报错的。如果出现这种情况我们可以容忍，则需要配置该属性值为true。该参数值默认为false。\n注意使用该注解，bean一定有Set与Get方法，否则取不出对应的属性值。\npeople.properties内容如下：\n```\nfemale.age=10\nfemale.name=xiaohua\nfemale.history=beijing\n```\n## @Value\n通过@Value将外部配置文件的值动态注入到Bean中。配置文件主要有两类：\n\n* application.properties。application.properties在spring boot启动时默认加载此文件\n自定义属性文件。自定义属性文件通过@PropertySource加载。* @PropertySource可以同时加载多个文件，也可以加载单个文件。如果相同第一个属性文件和第二属性文件存在相同key，则最后一个属性文件里的key启作用。加载文件的路径也可以配置变量，如下文的${anotherfile.configinject}，此值定义在第一个属性文件config.properties\n```\n@Value(\"${app.name}\")\n    private String appName; // 这里的值来自application.properties，spring boot启动时默认加载此文件\n```\n\n\n# 无侵入容器\n在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n* 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n* 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\n# 官方文档：\nhttps://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core","slug":"spring源码（一）","published":1,"updated":"2020-08-15T02:25:52.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce3900028n6zqz7lmexxi","content":"<p>Spring framework是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等</p>\n<p>IOC容器（ Inversion of Control ）是Spring Framework 最核心部分，它管理着Spring应用中bean的创建、 配置和管理，也叫依赖注入（dependency injection ）</p>\n<h1 id=\"什么是IOC容器\"><a href=\"#什么是IOC容器\" class=\"headerlink\" title=\"什么是IOC容器\"></a>什么是IOC容器</h1><h2 id=\"没有IOC容器\"><a href=\"#没有IOC容器\" class=\"headerlink\" title=\"没有IOC容器\"></a>没有IOC容器</h2><p>按照传统的做法，每个对象负责管理与自己相互协作的对象<br>（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代 码。</p>\n<p>我们假定一个在线书店，通过BookService获取书籍：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123;</span><br><span class=\"line\">    private HikariConfig config = new HikariConfig();</span><br><span class=\"line\">    private DataSource dataSource = new HikariDataSource(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book getBook(long bookId) &#123;</span><br><span class=\"line\">        try (Connection conn = dataSource.getConnection()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            return book;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这种方式使用new的方式创建对象，</li>\n<li><p>若测试BookService，是复杂的，因为必须要在真实的数据库环境下执行。</p>\n</li>\n<li><p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>\n</li>\n</ul>\n<h2 id=\"有IOC容器\"><a href=\"#有IOC容器\" class=\"headerlink\" title=\"有IOC容器\"></a>有IOC容器</h2><p>核心问题是：</p>\n<ul>\n<li>谁负责创建组件？</li>\n<li>谁负责根据依赖关系组装组件？</li>\n<li>销毁时，如何按依赖顺序正确销毁？<br>解决这一问题的核心方案就是IoC。</li>\n</ul>\n<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>\n<p>在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>\n<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，<br>例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">    public BookService(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：</p>\n<ul>\n<li>BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；</li>\n<li>测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。</li>\n</ul>\n<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>\n<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系.<br>以下这种通过在JavaConfig中进行显式配置bean。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public Class JavaBean&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean</span><br><span class=\"line\"> public HikariConfig hikariConfig()&#123;</span><br><span class=\"line\">  return new HikariConfig();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> @Bean</span><br><span class=\"line\"> public DataSource dataSource(HikariConfig config)&#123;</span><br><span class=\"line\"> return new HikariDataSource(config);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> @Bean</span><br><span class=\"line\"> public BookService bookService(DataSource dataSource)&#123;</span><br><span class=\"line\"> return new BookService(dataSource);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>\n<h1 id=\"依赖注入的方式\"><a href=\"#依赖注入的方式\" class=\"headerlink\" title=\"依赖注入的方式\"></a>依赖注入的方式</h1><ul>\n<li>通过构造方法注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired</span><br><span class=\"line\">    public BookService(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过方法注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired</span><br><span class=\"line\">    public void setDataSource(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出<br>一个异常。为了避免异常的出现，你可以将@Autowired的<br>required属性设置为false：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired（required=false）</span><br><span class=\"line\">    public void setDataSource(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但<br>是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状<br>态。但是，把required属性设置为false时，你需要谨慎对待。如<br>果在你的代码中没有进行null检查的话，这个处于未装配状态的属性<br>有可能会出现NullPointerException。</p>\n<p>如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，<br>表明没有明确指定要选择哪个bean进行自动装配</p>\n<ul>\n<li>属性注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\"> @Autowired</span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Spring容器是\"><a href=\"#Spring容器是\" class=\"headerlink\" title=\"Spring容器是\"></a>Spring容器是</h1><ul>\n<li>从概念上讲：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</li>\n<li>从具象化讲：在java项目中，我们使用实现了org.springframework.context.ApplicationContext接口的实现类。</li>\n<li>从代码上讲：一个Spring容器就是某个实现了ApplicationContext接口的类的实例。也就是说，从代码层面，Spring容器其实就是一个</li>\n</ul>\n<h2 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h2><p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。</p>\n<p>BeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>\n<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。<br>DefaultListableBeanFactory类图：<br><img src=\"/2020/08/08/spring源码（一）/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<ul>\n<li>1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。<br>是Spring bean容器的根接口，提供获取bean，是否包含bean,是否单例与原型，获取bean类型，bean 别名的方法 。它最主要的方法就是getBean(String beanName)。</li>\n<li>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。<ul>\n<li>HierarchicalBeanFactory：提供父容器的访问功能\n </li>\n<li>ListableBeanFactory：提供了批量获取Bean的方法\n </li>\n<li>AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管理</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>主要单例bean的注册，生成实例，以及统计单例bean</p>\n</li>\n<li><p>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁…</p>\n</li>\n<li><p>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。</p>\n</li>\n<li><p>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory</p>\n</li>\n<li><p>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。</p>\n<p>实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition<br>BeanFactory的源码： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://docs.spring.io/spring/docs/5.1.18.BUILD-SNAPSHOT/javadoc-api/</span><br><span class=\"line\"></span><br><span class=\"line\">package org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.core.ResolvableType;</span><br><span class=\"line\">import org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface BeanFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tString FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * 五个不同形式的getBean方法，获取实例</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tObject getBean(String name) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class=\"line\">\tObject getBean(String name, Object... args) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//2个不同形式 返回指定bean的提供程序，以允许按需延迟检索实例，包括可用性和唯一性选项。</span><br><span class=\"line\">\t&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);</span><br><span class=\"line\">\t&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *  bean 是否存在</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tboolean containsBean(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 是否为单实例</span><br><span class=\"line\">\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 是否为原型（多实例）</span><br><span class=\"line\">\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 2个不同形式 名称、类型是否匹配</span><br><span class=\"line\">\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\">\tboolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t // 2个不同形式 获取类型</span><br><span class=\"line\">\t@Nullable</span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\">\t@Nullable</span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 根据实例的名字获取实例的别名</span><br><span class=\"line\">\tString[] getAliases(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>具体：<br>　　1、5个获取实例的方法。getBean的重载方法。<br>　　2、7个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这13个方法，很明显，这是一个典型的工厂模式的工厂接口。<br>AnnotationConfigApplicationContext 例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从一个或多个</span><br><span class=\"line\">基于Java的配置类中加载Spring应用上下文</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>从一个或多个基于Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。</li>\n<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>\n<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>\n</ol>\n<h2 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h2><p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。</p>\n<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>\n<ul>\n<li>（1）MessageSource, 提供国际化的消息访问  </li>\n<li>（2）资源访问，如URL和文件  </li>\n<li>（3）事件传播特性，即支持aop特性</li>\n<li>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </li>\n</ul>\n<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。<br><img src=\"/2020/08/08/spring源码（一）/AnnotationConfigApplicationContext.png\" alt=\"AnnotationConfigApplicationContext类图\"></p>\n<h3 id=\"ApplicationContext常用实现类-作用\"><a href=\"#ApplicationContext常用实现类-作用\" class=\"headerlink\" title=\"ApplicationContext常用实现类    作用\"></a>ApplicationContext常用实现类    作用</h3><ul>\n<li>AnnotationConfigApplicationContext    从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。</li>\n<li>ClassPathXmlApplicationContext    从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。</li>\n<li>FileSystemXmlApplicationContext    从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。</li>\n<li>AnnotationConfigWebApplicationContext    专门为web应用准备的，适用于注解方式。</li>\n<li>XmlWebApplicationContext    从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</li>\n</ul>\n<h3 id=\"三种装配机制：\"><a href=\"#三种装配机制：\" class=\"headerlink\" title=\"三种装配机制：\"></a>三种装配机制：</h3><ul>\n<li>在XMl中进行显示配置</li>\n<li>在Java中进行显示配置</li>\n<li>隐式的bean发现机制和自动装配<ul>\n<li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li>\n<li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li>\n</ul>\n</li>\n</ul>\n<p>（使用的优先性: 3&gt;2&gt;1）尽可能地使用自动配置的机制，显示配置越少越好。当必须使用显示配置bean的时候（如：有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才使用XML。<br>代码示例：</p>\n<p>通过xml文件将配置加载到IOC容器中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">     &lt;!--若没写id，则默认为com.test.Man#0,#0为一个计数形式--&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;man&quot; class=&quot;com.test.Man&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //加载项目中的spring配置文件到容器</span><br><span class=\"line\">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;resouces/applicationContext.xml&quot;);</span><br><span class=\"line\">        //加载系统盘中的配置文件到容器</span><br><span class=\"line\">        ApplicationContext context = new FileSystemXmlApplicationContext(&quot;E:/Spring/applicationContext.xml&quot;);</span><br><span class=\"line\">        //从容器中获取对象实例</span><br><span class=\"line\">        Man man = context.getBean(Man.class);</span><br><span class=\"line\">        man.driveCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过java注解的方式将配置加载到IOC容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同xml一样描述bean以及bean之间的依赖关系</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class ManConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Man man() &#123;</span><br><span class=\"line\">        return new Man(car());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Car car() &#123;</span><br><span class=\"line\">        return new QQCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //从java注解的配置中加载配置到容器</span><br><span class=\"line\">        ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class);</span><br><span class=\"line\">        //从容器中获取对象实例</span><br><span class=\"line\">        Man man = context.getBean(Man.class);</span><br><span class=\"line\">        man.driveCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>隐式的bean发现机制和自动装配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 这是一个游戏光盘的实现</span><br><span class=\"line\"> */</span><br><span class=\"line\">//这个简单的注解表明该类回作为组件类，并告知Spring要为这个创建bean。</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class GameDisc implements Disc&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是马里奥游戏光盘。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找@Component注解的类，并为其创建bean。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\">public class DiscConfig &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在DiscConfig上加了一个@ComponentScan注解表示在Spring中开启了组件扫描，默认扫描与配置类相同的包，就可以扫描到这个GameDisc的Bean了。这就是Spring的自动装配机制。</p>\n<p>由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。也可以为bean设置lazy-init属性为true，即Spring容器将不会预先初始化该bean。</p>\n<h1 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h1><h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h2><p>定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p>\n<h2 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h2><p>该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <a href=\"context:component-scan\" target=\"_blank\" rel=\"noopener\">context:component-scan</a>。</p>\n<ul>\n<li><p>指定包扫描,主要扫描该包下@Controller @Service @Respsitory @Component四个注解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定排除要扫描的包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;,excludeFilters =&#123;@ComponentScan.Filter (type= FilterType.ANNOTATION,classes =&#123;Component.class,Repository.class,Controller.class,Service.class&#125;)&#125; )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定要扫描的包<br>useDefaultFilters = false默认是true,需要改为false该类才生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;,includeFilters =&#123;@ComponentScan.Filter (type= FilterType.ANNOTATION,classes =&#123;Component.class,Repository.class,Controller.class,Service.class&#125;)&#125;,useDefaultFilters = false)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h2><p>注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中</p>\n<h2 id=\"Autowired\"><a href=\"#Autowired\" class=\"headerlink\" title=\"@Autowired\"></a>@Autowired</h2><p> 注解对自动装配何时何处被实现提供了更多细粒度的控制</p>\n<h2 id=\"Qualifier\"><a href=\"#Qualifier\" class=\"headerlink\" title=\"@Qualifier\"></a>@Qualifier</h2><p>自动装配，如果容器中某个bean有多个实例，想要获取指定的的实例，可以用@Qualifier</p>\n<h2 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"@scope\"></a>@scope</h2><p>  用来配置 spring bean 的作用域，它标识 bean 的作用域。默认值是单例</p>\n<ul>\n<li><p>1、singleton:单例模式,全局有且仅有一个实例</p>\n</li>\n<li><p>2、prototype:原型模式,每次获取Bean的时候会有一个新的实例</p>\n</li>\n<li><p>3、request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p>\n</li>\n<li><p>4、session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</p>\n</li>\n<li><p>5、global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。</p>\n</li>\n</ul>\n<h2 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h2><p> 容器启动不创建对象，调用的时候创建对象</p>\n<h2 id=\"Conditional（-WindowConditional-class-）\"><a href=\"#Conditional（-WindowConditional-class-）\" class=\"headerlink\" title=\"@Conditional（{WindowConditional.class}）\"></a>@Conditional（{WindowConditional.class}）</h2><p>WindowConditional 实现condition接口，返回true</p>\n<h2 id=\"PostConstruct\"><a href=\"#PostConstruct\" class=\"headerlink\" title=\"@PostConstruct\"></a>@PostConstruct</h2><p>初始化 注解在初始化的方法上面</p>\n<h2 id=\"PreDestroy\"><a href=\"#PreDestroy\" class=\"headerlink\" title=\"@PreDestroy\"></a>@PreDestroy</h2><p>销毁 在容器销毁bean之前调用</p>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"@Controller\"></a>@Controller</h2><p>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.</p>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"@Service\"></a>@Service</h2><p>用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中</p>\n<h2 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"@Resource\"></a>@Resource</h2><p>@Resource的作用相当于@Autowired<br>只不过@Autowired按byType自动注入，<br>而@Resource默认按 byName自动注入<br>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略</p>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p>\n<h2 id=\"RestController\"><a href=\"#RestController\" class=\"headerlink\" title=\"@RestController\"></a>@RestController</h2><p>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</p>\n<h2 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"@RequestMapping\"></a>@RequestMapping</h2><p>类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p>\n<h2 id=\"RequestParam\"><a href=\"#RequestParam\" class=\"headerlink\" title=\"@RequestParam\"></a>@RequestParam</h2><p>用于将请求参数区数据映射到功能处理方法的参数上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)</span><br><span class=\"line\">    public String postUser(@RequestParam(value=&quot;phoneNum&quot;, required=true) String phoneNum ) String userName) &#123;</span><br><span class=\"line\">        userService.create(phoneNum, userName);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"@Repository\"></a>@Repository</h2><p>用于标注数据访问组件，即DAO组件</p>\n<h2 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"@Required\"></a>@Required</h2><p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>  ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p>\n<ul>\n<li><p>1、直接填class数组方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  @Import(&#123; 类名.class , 类名.class... &#125;)</span><br><span class=\"line\">public class TestDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h2><p>映射 URL 绑定的占位符<br>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过</p>\n</li>\n</ul>\n<p>@PathVariable(“xxx”) 绑定到操作方法的入参中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/users/&#123;username&#125;&quot;)</span><br><span class=\"line\">public String userProfile(@PathVariable(&quot;username&quot;) String user) &#123;</span><br><span class=\"line\">    return String.format(&quot;user %s&quot;, user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> @PathVariable和@RequestParam的区别就在于：@RequestParam用来获得静态的URL请求参数；@PathVariable用来获得动态的URL请求入参</p>\n<h2 id=\"ResponseBody\"><a href=\"#ResponseBody\" class=\"headerlink\" title=\"@ResponseBody\"></a>@ResponseBody</h2><p> 的作用其实是将java对象转为json格式的数据。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @RequestMapping(&quot;/login.do&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public Object login(String name, String password, HttpSession session) &#123;</span><br><span class=\"line\">\tuser = userService.checkLogin(name, password);</span><br><span class=\"line\">\tsession.setAttribute(&quot;user&quot;, user);</span><br><span class=\"line\">\treturn new JsonResult(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><p> 是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，<br>封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。<br>如上面的登录后台代码可以改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/login.do&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public Object login(@RequestBody User loginUuser, HttpSession session) &#123;</span><br><span class=\"line\">\tuser = userService.checkLogin(loginUser);</span><br><span class=\"line\">\tsession.setAttribute(&quot;user&quot;, user);</span><br><span class=\"line\">\treturn new JsonResult(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"PropertySource\"><a href=\"#PropertySource\" class=\"headerlink\" title=\"@PropertySource\"></a>@PropertySource</h2><p>目的是加载指定的属性文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PropertySource(value = &#123;&quot;classpath:people.properties&quot;&#125;,ignoreResourceNotFound = false,encoding = &quot;UTF-8&quot;,name = &quot;people.properties&quot;)</span><br><span class=\"line\">public class PeopleProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">     public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>people.properties内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age=10</span><br><span class=\"line\">name=xiaohua</span><br><span class=\"line\">history=beijing</span><br></pre></td></tr></table></figure></p>\n<p>##ConfigurationProperties<br>是类级别的注解<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PropertySource(value = &#123;&quot;classpath:people.properties&quot;&#125;,ignoreResourceNotFound = false,encoding = &quot;UTF-8&quot;,name = &quot;people.properties&quot;)</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;female&quot;,ignoreUnknownFields=true,ignoreInvalidFields=true)</span><br><span class=\"line\">public class PeopleProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">     public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在PeopleProperties类中增加了ConfigurationProperties注解，并且指明了属性的前缀为female。这样Springboot在处理的时候，会去扫描当前类中的所有字段并进行属性的查找以及组装。比如我们配置的prefix = “female”，PeopleProperties类中有一个name字段，则female字段需要匹配的属性是prefix+字段=female.name。</p>\n<p>@ConfigurationProperties(prefix = “female”,ignoreUnknownFields=true,ignoreInvalidFields=true)</p>\n<ul>\n<li><p>ignoreUnknownFields：忽略未知的字段。</p>\n</li>\n<li><p>ignoreInvalidFields：是否忽略验证失败的字段。这个怎么理解呢？比如我们在配置文件中配置了一个字符串类型的变量，类中的字段是int类型，那肯定会报错的。如果出现这种情况我们可以容忍，则需要配置该属性值为true。该参数值默认为false。<br>注意使用该注解，bean一定有Set与Get方法，否则取不出对应的属性值。<br>people.properties内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">female.age=10</span><br><span class=\"line\">female.name=xiaohua</span><br><span class=\"line\">female.history=beijing</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a>@Value</h2><p>通过@Value将外部配置文件的值动态注入到Bean中。配置文件主要有两类：</p>\n<ul>\n<li>application.properties。application.properties在spring boot启动时默认加载此文件<br>自定义属性文件。自定义属性文件通过@PropertySource加载。* @PropertySource可以同时加载多个文件，也可以加载单个文件。如果相同第一个属性文件和第二属性文件存在相同key，则最后一个属性文件里的key启作用。加载文件的路径也可以配置变量，如下文的${anotherfile.configinject}，此值定义在第一个属性文件config.properties<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;app.name&#125;&quot;)</span><br><span class=\"line\">    private String appName; // 这里的值来自application.properties，spring boot启动时默认加载此文件</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"无侵入容器\"><a href=\"#无侵入容器\" class=\"headerlink\" title=\"无侵入容器\"></a>无侵入容器</h1><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>\n<ul>\n<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>\n<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>\n</ul>\n<h1 id=\"官方文档：\"><a href=\"#官方文档：\" class=\"headerlink\" title=\"官方文档：\"></a>官方文档：</h1><p><a href=\"https://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Spring framework是一个Spring的基础框架，提供了Spring 的核心功能，比如依赖注入、事务管理、面向方面编程等等</p>\n<p>IOC容器（ Inversion of Control ）是Spring Framework 最核心部分，它管理着Spring应用中bean的创建、 配置和管理，也叫依赖注入（dependency injection ）</p>\n<h1 id=\"什么是IOC容器\"><a href=\"#什么是IOC容器\" class=\"headerlink\" title=\"什么是IOC容器\"></a>什么是IOC容器</h1><h2 id=\"没有IOC容器\"><a href=\"#没有IOC容器\" class=\"headerlink\" title=\"没有IOC容器\"></a>没有IOC容器</h2><p>按照传统的做法，每个对象负责管理与自己相互协作的对象<br>（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代 码。</p>\n<p>我们假定一个在线书店，通过BookService获取书籍：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123;</span><br><span class=\"line\">    private HikariConfig config = new HikariConfig();</span><br><span class=\"line\">    private DataSource dataSource = new HikariDataSource(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book getBook(long bookId) &#123;</span><br><span class=\"line\">        try (Connection conn = dataSource.getConnection()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            return book;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这种方式使用new的方式创建对象，</li>\n<li><p>若测试BookService，是复杂的，因为必须要在真实的数据库环境下执行。</p>\n</li>\n<li><p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>\n</li>\n</ul>\n<h2 id=\"有IOC容器\"><a href=\"#有IOC容器\" class=\"headerlink\" title=\"有IOC容器\"></a>有IOC容器</h2><p>核心问题是：</p>\n<ul>\n<li>谁负责创建组件？</li>\n<li>谁负责根据依赖关系组装组件？</li>\n<li>销毁时，如何按依赖顺序正确销毁？<br>解决这一问题的核心方案就是IoC。</li>\n</ul>\n<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>\n<p>在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>\n<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，<br>例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">    public BookService(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：</p>\n<ul>\n<li>BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；</li>\n<li>测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。</li>\n</ul>\n<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>\n<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系.<br>以下这种通过在JavaConfig中进行显式配置bean。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public Class JavaBean&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean</span><br><span class=\"line\"> public HikariConfig hikariConfig()&#123;</span><br><span class=\"line\">  return new HikariConfig();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> @Bean</span><br><span class=\"line\"> public DataSource dataSource(HikariConfig config)&#123;</span><br><span class=\"line\"> return new HikariDataSource(config);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> @Bean</span><br><span class=\"line\"> public BookService bookService(DataSource dataSource)&#123;</span><br><span class=\"line\"> return new BookService(dataSource);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>\n<h1 id=\"依赖注入的方式\"><a href=\"#依赖注入的方式\" class=\"headerlink\" title=\"依赖注入的方式\"></a>依赖注入的方式</h1><ul>\n<li>通过构造方法注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired</span><br><span class=\"line\">    public BookService(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过方法注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired</span><br><span class=\"line\">    public void setDataSource(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出<br>一个异常。为了避免异常的出现，你可以将@Autowired的<br>required属性设置为false：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">      @Autowired（required=false）</span><br><span class=\"line\">    public void setDataSource(DataSource dataSource)&#123;</span><br><span class=\"line\">      this.DataSource=dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但<br>是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状<br>态。但是，把required属性设置为false时，你需要谨慎对待。如<br>果在你的代码中没有进行null检查的话，这个处于未装配状态的属性<br>有可能会出现NullPointerException。</p>\n<p>如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，<br>表明没有明确指定要选择哪个bean进行自动装配</p>\n<ul>\n<li>属性注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookService &#123; </span><br><span class=\"line\"> @Autowired</span><br><span class=\"line\">      private DataSource dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Spring容器是\"><a href=\"#Spring容器是\" class=\"headerlink\" title=\"Spring容器是\"></a>Spring容器是</h1><ul>\n<li>从概念上讲：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</li>\n<li>从具象化讲：在java项目中，我们使用实现了org.springframework.context.ApplicationContext接口的实现类。</li>\n<li>从代码上讲：一个Spring容器就是某个实现了ApplicationContext接口的类的实例。也就是说，从代码层面，Spring容器其实就是一个</li>\n</ul>\n<h2 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h2><p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。</p>\n<p>BeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>\n<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。<br>DefaultListableBeanFactory类图：<br><img src=\"/2020/08/08/spring源码（一）/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<ul>\n<li>1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。<br>是Spring bean容器的根接口，提供获取bean，是否包含bean,是否单例与原型，获取bean类型，bean 别名的方法 。它最主要的方法就是getBean(String beanName)。</li>\n<li>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。<ul>\n<li>HierarchicalBeanFactory：提供父容器的访问功能\n </li>\n<li>ListableBeanFactory：提供了批量获取Bean的方法\n </li>\n<li>AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管理</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>主要单例bean的注册，生成实例，以及统计单例bean</p>\n</li>\n<li><p>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁…</p>\n</li>\n<li><p>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。</p>\n</li>\n<li><p>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory</p>\n</li>\n<li><p>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。</p>\n<p>实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition<br>BeanFactory的源码： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://docs.spring.io/spring/docs/5.1.18.BUILD-SNAPSHOT/javadoc-api/</span><br><span class=\"line\"></span><br><span class=\"line\">package org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.core.ResolvableType;</span><br><span class=\"line\">import org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface BeanFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tString FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * 五个不同形式的getBean方法，获取实例</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tObject getBean(String name) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class=\"line\">\tObject getBean(String name, Object... args) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class=\"line\">\t&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//2个不同形式 返回指定bean的提供程序，以允许按需延迟检索实例，包括可用性和唯一性选项。</span><br><span class=\"line\">\t&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);</span><br><span class=\"line\">\t&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *  bean 是否存在</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tboolean containsBean(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 是否为单实例</span><br><span class=\"line\">\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 是否为原型（多实例）</span><br><span class=\"line\">\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 2个不同形式 名称、类型是否匹配</span><br><span class=\"line\">\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\">\tboolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t // 2个不同形式 获取类型</span><br><span class=\"line\">\t@Nullable</span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\">\t@Nullable</span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 根据实例的名字获取实例的别名</span><br><span class=\"line\">\tString[] getAliases(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>具体：<br>　　1、5个获取实例的方法。getBean的重载方法。<br>　　2、7个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这13个方法，很明显，这是一个典型的工厂模式的工厂接口。<br>AnnotationConfigApplicationContext 例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从一个或多个</span><br><span class=\"line\">基于Java的配置类中加载Spring应用上下文</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.yanwen.springTest.service.MemberService;</span><br><span class=\"line\">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package com.yanwen.springTest.service;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class MemberService &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>从一个或多个基于Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。</li>\n<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>\n<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>\n</ol>\n<h2 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h2><p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。</p>\n<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>\n<ul>\n<li>（1）MessageSource, 提供国际化的消息访问  </li>\n<li>（2）资源访问，如URL和文件  </li>\n<li>（3）事件传播特性，即支持aop特性</li>\n<li>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </li>\n</ul>\n<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。<br><img src=\"/2020/08/08/spring源码（一）/AnnotationConfigApplicationContext.png\" alt=\"AnnotationConfigApplicationContext类图\"></p>\n<h3 id=\"ApplicationContext常用实现类-作用\"><a href=\"#ApplicationContext常用实现类-作用\" class=\"headerlink\" title=\"ApplicationContext常用实现类    作用\"></a>ApplicationContext常用实现类    作用</h3><ul>\n<li>AnnotationConfigApplicationContext    从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。</li>\n<li>ClassPathXmlApplicationContext    从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。</li>\n<li>FileSystemXmlApplicationContext    从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。</li>\n<li>AnnotationConfigWebApplicationContext    专门为web应用准备的，适用于注解方式。</li>\n<li>XmlWebApplicationContext    从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</li>\n</ul>\n<h3 id=\"三种装配机制：\"><a href=\"#三种装配机制：\" class=\"headerlink\" title=\"三种装配机制：\"></a>三种装配机制：</h3><ul>\n<li>在XMl中进行显示配置</li>\n<li>在Java中进行显示配置</li>\n<li>隐式的bean发现机制和自动装配<ul>\n<li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li>\n<li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li>\n</ul>\n</li>\n</ul>\n<p>（使用的优先性: 3&gt;2&gt;1）尽可能地使用自动配置的机制，显示配置越少越好。当必须使用显示配置bean的时候（如：有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），推荐使用类型安全比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才使用XML。<br>代码示例：</p>\n<p>通过xml文件将配置加载到IOC容器中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class=\"line\">     &lt;!--若没写id，则默认为com.test.Man#0,#0为一个计数形式--&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;man&quot; class=&quot;com.test.Man&quot;&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //加载项目中的spring配置文件到容器</span><br><span class=\"line\">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;resouces/applicationContext.xml&quot;);</span><br><span class=\"line\">        //加载系统盘中的配置文件到容器</span><br><span class=\"line\">        ApplicationContext context = new FileSystemXmlApplicationContext(&quot;E:/Spring/applicationContext.xml&quot;);</span><br><span class=\"line\">        //从容器中获取对象实例</span><br><span class=\"line\">        Man man = context.getBean(Man.class);</span><br><span class=\"line\">        man.driveCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过java注解的方式将配置加载到IOC容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同xml一样描述bean以及bean之间的依赖关系</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class ManConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Man man() &#123;</span><br><span class=\"line\">        return new Man(car());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Car car() &#123;</span><br><span class=\"line\">        return new QQCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //从java注解的配置中加载配置到容器</span><br><span class=\"line\">        ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class);</span><br><span class=\"line\">        //从容器中获取对象实例</span><br><span class=\"line\">        Man man = context.getBean(Man.class);</span><br><span class=\"line\">        man.driveCar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>隐式的bean发现机制和自动装配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 这是一个游戏光盘的实现</span><br><span class=\"line\"> */</span><br><span class=\"line\">//这个简单的注解表明该类回作为组件类，并告知Spring要为这个创建bean。</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class GameDisc implements Disc&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是马里奥游戏光盘。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找@Component注解的类，并为其创建bean。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\">public class DiscConfig &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在DiscConfig上加了一个@ComponentScan注解表示在Spring中开启了组件扫描，默认扫描与配置类相同的包，就可以扫描到这个GameDisc的Bean了。这就是Spring的自动装配机制。</p>\n<p>由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。也可以为bean设置lazy-init属性为true，即Spring容器将不会预先初始化该bean。</p>\n<h1 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h1><h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h2><p>定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p>\n<h2 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h2><p>该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <a href=\"context:component-scan\" target=\"_blank\" rel=\"noopener\">context:component-scan</a>。</p>\n<ul>\n<li><p>指定包扫描,主要扫描该包下@Controller @Service @Respsitory @Component四个注解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定排除要扫描的包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;,excludeFilters =&#123;@ComponentScan.Filter (type= FilterType.ANNOTATION,classes =&#123;Component.class,Repository.class,Controller.class,Service.class&#125;)&#125; )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定要扫描的包<br>useDefaultFilters = false默认是true,需要改为false该类才生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(value=&quot;com.songzixian&quot;,includeFilters =&#123;@ComponentScan.Filter (type= FilterType.ANNOTATION,classes =&#123;Component.class,Repository.class,Controller.class,Service.class&#125;)&#125;,useDefaultFilters = false)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h2><p>注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中</p>\n<h2 id=\"Autowired\"><a href=\"#Autowired\" class=\"headerlink\" title=\"@Autowired\"></a>@Autowired</h2><p> 注解对自动装配何时何处被实现提供了更多细粒度的控制</p>\n<h2 id=\"Qualifier\"><a href=\"#Qualifier\" class=\"headerlink\" title=\"@Qualifier\"></a>@Qualifier</h2><p>自动装配，如果容器中某个bean有多个实例，想要获取指定的的实例，可以用@Qualifier</p>\n<h2 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"@scope\"></a>@scope</h2><p>  用来配置 spring bean 的作用域，它标识 bean 的作用域。默认值是单例</p>\n<ul>\n<li><p>1、singleton:单例模式,全局有且仅有一个实例</p>\n</li>\n<li><p>2、prototype:原型模式,每次获取Bean的时候会有一个新的实例</p>\n</li>\n<li><p>3、request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p>\n</li>\n<li><p>4、session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</p>\n</li>\n<li><p>5、global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。</p>\n</li>\n</ul>\n<h2 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h2><p> 容器启动不创建对象，调用的时候创建对象</p>\n<h2 id=\"Conditional（-WindowConditional-class-）\"><a href=\"#Conditional（-WindowConditional-class-）\" class=\"headerlink\" title=\"@Conditional（{WindowConditional.class}）\"></a>@Conditional（{WindowConditional.class}）</h2><p>WindowConditional 实现condition接口，返回true</p>\n<h2 id=\"PostConstruct\"><a href=\"#PostConstruct\" class=\"headerlink\" title=\"@PostConstruct\"></a>@PostConstruct</h2><p>初始化 注解在初始化的方法上面</p>\n<h2 id=\"PreDestroy\"><a href=\"#PreDestroy\" class=\"headerlink\" title=\"@PreDestroy\"></a>@PreDestroy</h2><p>销毁 在容器销毁bean之前调用</p>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"@Controller\"></a>@Controller</h2><p>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.</p>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"@Service\"></a>@Service</h2><p>用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中</p>\n<h2 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"@Resource\"></a>@Resource</h2><p>@Resource的作用相当于@Autowired<br>只不过@Autowired按byType自动注入，<br>而@Resource默认按 byName自动注入<br>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略</p>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p>\n<h2 id=\"RestController\"><a href=\"#RestController\" class=\"headerlink\" title=\"@RestController\"></a>@RestController</h2><p>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</p>\n<h2 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"@RequestMapping\"></a>@RequestMapping</h2><p>类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p>\n<h2 id=\"RequestParam\"><a href=\"#RequestParam\" class=\"headerlink\" title=\"@RequestParam\"></a>@RequestParam</h2><p>用于将请求参数区数据映射到功能处理方法的参数上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)</span><br><span class=\"line\">    public String postUser(@RequestParam(value=&quot;phoneNum&quot;, required=true) String phoneNum ) String userName) &#123;</span><br><span class=\"line\">        userService.create(phoneNum, userName);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"@Repository\"></a>@Repository</h2><p>用于标注数据访问组件，即DAO组件</p>\n<h2 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"@Required\"></a>@Required</h2><p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>  ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p>\n<ul>\n<li><p>1、直接填class数组方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  @Import(&#123; 类名.class , 类名.class... &#125;)</span><br><span class=\"line\">public class TestDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h2><p>映射 URL 绑定的占位符<br>通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过</p>\n</li>\n</ul>\n<p>@PathVariable(“xxx”) 绑定到操作方法的入参中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/users/&#123;username&#125;&quot;)</span><br><span class=\"line\">public String userProfile(@PathVariable(&quot;username&quot;) String user) &#123;</span><br><span class=\"line\">    return String.format(&quot;user %s&quot;, user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> @PathVariable和@RequestParam的区别就在于：@RequestParam用来获得静态的URL请求参数；@PathVariable用来获得动态的URL请求入参</p>\n<h2 id=\"ResponseBody\"><a href=\"#ResponseBody\" class=\"headerlink\" title=\"@ResponseBody\"></a>@ResponseBody</h2><p> 的作用其实是将java对象转为json格式的数据。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @RequestMapping(&quot;/login.do&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public Object login(String name, String password, HttpSession session) &#123;</span><br><span class=\"line\">\tuser = userService.checkLogin(name, password);</span><br><span class=\"line\">\tsession.setAttribute(&quot;user&quot;, user);</span><br><span class=\"line\">\treturn new JsonResult(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><p> 是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，<br>封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。<br>如上面的登录后台代码可以改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/login.do&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public Object login(@RequestBody User loginUuser, HttpSession session) &#123;</span><br><span class=\"line\">\tuser = userService.checkLogin(loginUser);</span><br><span class=\"line\">\tsession.setAttribute(&quot;user&quot;, user);</span><br><span class=\"line\">\treturn new JsonResult(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"PropertySource\"><a href=\"#PropertySource\" class=\"headerlink\" title=\"@PropertySource\"></a>@PropertySource</h2><p>目的是加载指定的属性文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PropertySource(value = &#123;&quot;classpath:people.properties&quot;&#125;,ignoreResourceNotFound = false,encoding = &quot;UTF-8&quot;,name = &quot;people.properties&quot;)</span><br><span class=\"line\">public class PeopleProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">     public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>people.properties内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age=10</span><br><span class=\"line\">name=xiaohua</span><br><span class=\"line\">history=beijing</span><br></pre></td></tr></table></figure></p>\n<p>##ConfigurationProperties<br>是类级别的注解<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PropertySource(value = &#123;&quot;classpath:people.properties&quot;&#125;,ignoreResourceNotFound = false,encoding = &quot;UTF-8&quot;,name = &quot;people.properties&quot;)</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;female&quot;,ignoreUnknownFields=true,ignoreInvalidFields=true)</span><br><span class=\"line\">public class PeopleProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">     public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在PeopleProperties类中增加了ConfigurationProperties注解，并且指明了属性的前缀为female。这样Springboot在处理的时候，会去扫描当前类中的所有字段并进行属性的查找以及组装。比如我们配置的prefix = “female”，PeopleProperties类中有一个name字段，则female字段需要匹配的属性是prefix+字段=female.name。</p>\n<p>@ConfigurationProperties(prefix = “female”,ignoreUnknownFields=true,ignoreInvalidFields=true)</p>\n<ul>\n<li><p>ignoreUnknownFields：忽略未知的字段。</p>\n</li>\n<li><p>ignoreInvalidFields：是否忽略验证失败的字段。这个怎么理解呢？比如我们在配置文件中配置了一个字符串类型的变量，类中的字段是int类型，那肯定会报错的。如果出现这种情况我们可以容忍，则需要配置该属性值为true。该参数值默认为false。<br>注意使用该注解，bean一定有Set与Get方法，否则取不出对应的属性值。<br>people.properties内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">female.age=10</span><br><span class=\"line\">female.name=xiaohua</span><br><span class=\"line\">female.history=beijing</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a>@Value</h2><p>通过@Value将外部配置文件的值动态注入到Bean中。配置文件主要有两类：</p>\n<ul>\n<li>application.properties。application.properties在spring boot启动时默认加载此文件<br>自定义属性文件。自定义属性文件通过@PropertySource加载。* @PropertySource可以同时加载多个文件，也可以加载单个文件。如果相同第一个属性文件和第二属性文件存在相同key，则最后一个属性文件里的key启作用。加载文件的路径也可以配置变量，如下文的${anotherfile.configinject}，此值定义在第一个属性文件config.properties<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;app.name&#125;&quot;)</span><br><span class=\"line\">    private String appName; // 这里的值来自application.properties，spring boot启动时默认加载此文件</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"无侵入容器\"><a href=\"#无侵入容器\" class=\"headerlink\" title=\"无侵入容器\"></a>无侵入容器</h1><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>\n<ul>\n<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>\n<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>\n</ul>\n<h1 id=\"官方文档：\"><a href=\"#官方文档：\" class=\"headerlink\" title=\"官方文档：\"></a>官方文档：</h1><p><a href=\"https://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/5.0.18.RELEASE/spring-framework-reference/core.html#spring-core</a></p>\n"},{"title":"Notepad++文本比较插件：Compare","author":"wen","date":"2017-03-06T07:26:00.000Z","_content":"<Excerpt in index | 首页摘要>\n对程序员来说，文本比较就是代码的比较，对比新老两个版本的代码的差异是经常需要做的事情，尤其是多人开发的代码尤甚，今天，一个转给了同事，然后同事请小长假，代码又回来了，首先就是要了解代码已经修改了哪些地方。<!-- more -->\n<The rest of contents | 余下全文>\n承认，现在的人越来越懒，要去下载一款专门的代码比较器太不情愿了，如果现有的工具有这个功能就好了。这还真有，我一直是用的文本编辑器Notepad++就有个插件“Compare”，可以实现对文本（代码）的比较，而且一点也不亚于专用软件。\n\nCompare插件的安装很简单，在Notepad++的“插件”菜单中选择“Plugin Manager”-》“show Plugin Manager”，然后再“Available”选项卡内找到“Compare”插件，打勾，按Install。理论上就自动下载安装完毕了。\n不过现实中经常会出现“Installation of **** failed”这样的错误，这是因为在国内访问外国网站的时候链接被重置的缘故，解决方法一：多试几次，通常像sourceforge这样的网站是间歇性不能访问，多试几下就可以了，或者在下方的详细那里复制出下载地址，然后自行通过其他方法下载该插件，然后解压到Notepad++的根目录下的plugins目录即可。\n\n\n比较的效果还是不错的。\n\n为方便大家，把该插件[链接](https://github.com/smallwenzi/software)共享给大家，下载该“ComparePlugin.dll”文件后，复制到Notepad++安装目录下的\\plugins目录即可","source":"_posts/tepad-compare.md","raw":"title: Notepad++文本比较插件：Compare\nauthor: wen\ntags:\n  - notepad\ncategories: []\ndate: 2017-03-06 15:26:00\n---\n<Excerpt in index | 首页摘要>\n对程序员来说，文本比较就是代码的比较，对比新老两个版本的代码的差异是经常需要做的事情，尤其是多人开发的代码尤甚，今天，一个转给了同事，然后同事请小长假，代码又回来了，首先就是要了解代码已经修改了哪些地方。<!-- more -->\n<The rest of contents | 余下全文>\n承认，现在的人越来越懒，要去下载一款专门的代码比较器太不情愿了，如果现有的工具有这个功能就好了。这还真有，我一直是用的文本编辑器Notepad++就有个插件“Compare”，可以实现对文本（代码）的比较，而且一点也不亚于专用软件。\n\nCompare插件的安装很简单，在Notepad++的“插件”菜单中选择“Plugin Manager”-》“show Plugin Manager”，然后再“Available”选项卡内找到“Compare”插件，打勾，按Install。理论上就自动下载安装完毕了。\n不过现实中经常会出现“Installation of **** failed”这样的错误，这是因为在国内访问外国网站的时候链接被重置的缘故，解决方法一：多试几次，通常像sourceforge这样的网站是间歇性不能访问，多试几下就可以了，或者在下方的详细那里复制出下载地址，然后自行通过其他方法下载该插件，然后解压到Notepad++的根目录下的plugins目录即可。\n\n\n比较的效果还是不错的。\n\n为方便大家，把该插件[链接](https://github.com/smallwenzi/software)共享给大家，下载该“ComparePlugin.dll”文件后，复制到Notepad++安装目录下的\\plugins目录即可","slug":"tepad-compare","published":1,"updated":"2019-05-05T02:41:23.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce392002an6zq4bievvzs","content":"<p><excerpt in index | 首页摘要><br>对程序员来说，文本比较就是代码的比较，对比新老两个版本的代码的差异是经常需要做的事情，尤其是多人开发的代码尤甚，今天，一个转给了同事，然后同事请小长假，代码又回来了，首先就是要了解代码已经修改了哪些地方。<a id=\"more\"></a></excerpt></p>\n<p><the rest of contents | 余下全文><br>承认，现在的人越来越懒，要去下载一款专门的代码比较器太不情愿了，如果现有的工具有这个功能就好了。这还真有，我一直是用的文本编辑器Notepad++就有个插件“Compare”，可以实现对文本（代码）的比较，而且一点也不亚于专用软件。</the></p>\n<p>Compare插件的安装很简单，在Notepad++的“插件”菜单中选择“Plugin Manager”-》“show Plugin Manager”，然后再“Available”选项卡内找到“Compare”插件，打勾，按Install。理论上就自动下载安装完毕了。<br>不过现实中经常会出现“Installation of <em>**</em> failed”这样的错误，这是因为在国内访问外国网站的时候链接被重置的缘故，解决方法一：多试几次，通常像sourceforge这样的网站是间歇性不能访问，多试几下就可以了，或者在下方的详细那里复制出下载地址，然后自行通过其他方法下载该插件，然后解压到Notepad++的根目录下的plugins目录即可。</p>\n<p>比较的效果还是不错的。</p>\n<p>为方便大家，把该插件<a href=\"https://github.com/smallwenzi/software\" target=\"_blank\" rel=\"noopener\">链接</a>共享给大家，下载该“ComparePlugin.dll”文件后，复制到Notepad++安装目录下的\\plugins目录即可</p>\n","site":{"data":{}},"excerpt":"<p><excerpt in index | 首页摘要><br>对程序员来说，文本比较就是代码的比较，对比新老两个版本的代码的差异是经常需要做的事情，尤其是多人开发的代码尤甚，今天，一个转给了同事，然后同事请小长假，代码又回来了，首先就是要了解代码已经修改了哪些地方。</excerpt></p>","more":"<p></p>\n<p><the rest of contents | 余下全文><br>承认，现在的人越来越懒，要去下载一款专门的代码比较器太不情愿了，如果现有的工具有这个功能就好了。这还真有，我一直是用的文本编辑器Notepad++就有个插件“Compare”，可以实现对文本（代码）的比较，而且一点也不亚于专用软件。</the></p>\n<p>Compare插件的安装很简单，在Notepad++的“插件”菜单中选择“Plugin Manager”-》“show Plugin Manager”，然后再“Available”选项卡内找到“Compare”插件，打勾，按Install。理论上就自动下载安装完毕了。<br>不过现实中经常会出现“Installation of <em>**</em> failed”这样的错误，这是因为在国内访问外国网站的时候链接被重置的缘故，解决方法一：多试几次，通常像sourceforge这样的网站是间歇性不能访问，多试几下就可以了，或者在下方的详细那里复制出下载地址，然后自行通过其他方法下载该插件，然后解压到Notepad++的根目录下的plugins目录即可。</p>\n<p>比较的效果还是不错的。</p>\n<p>为方便大家，把该插件<a href=\"https://github.com/smallwenzi/software\" target=\"_blank\" rel=\"noopener\">链接</a>共享给大家，下载该“ComparePlugin.dll”文件后，复制到Notepad++安装目录下的\\plugins目录即可</p>"},{"title":"七）maven build docker and push Image","author":"wen","date":"2018-05-08T09:36:00.000Z","_content":"链接：[docker安装本地仓库](/2018/05/08/（六）docker安装本地仓库（root用户）/)\n使用maven 打包jar成docker镜像 并发布到镜像库\n# 1 maven settings.xml配置server 节点添加\n（这是私有库 用户名密码）\n```\n\t<server>\n\t\t\t<id>docker-hub</id>\n\t\t\t<username>testuser</username>\n\t\t\t<password>testpassword</password>\n       </server>\n```\n# 2 项目 pom.xml\nproperties 节点\n\n```\n      <docker.image.prefix>reg.itmuch.com</docker.image.prefix>\n     <docker.registry>https://reg.itmuch.com/v1</docker.registry>\n        <tag.version>1.0.0</tag.version>\n         <docker.servcerId>docker-hub</docker.servcerId>\n```\nmaven 配置组件\n```\n         <!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin -->\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>docker-maven-plugin</artifactId>\n                <version>1.0.0</version>\n                <dependencies>\n                <dependency>\n\t\t\t\t\t    <groupId>commons-logging</groupId>\n\t\t\t\t\t    <artifactId>commons-logging</artifactId>\n\t\t\t\t\t    <version>1.1.1</version>\n\t\t\t\t\t</dependency>\n                </dependencies>\n                <configuration>\n                   \t<!-- 镜像名:tag  -->\n                   <imageName>${docker.image.prefix}/${project.artifactId}:${tag.version}</imageName>\n\t\t\t\t    <!-- 指定Dockerfile所在的路径  -->\n                    <dockerDirectory>${project.basedir}/docker</dockerDirectory>\n                    <!-- 以下两行是为了docker push到DockerHub使用的。 -->\n                    <serverId>${docker.servcerId}</serverId>\n                    <registryUrl>${docker.registry}</registryUrl>\n        \t\t\t   <resources>\n                        <resource>\n                            <targetPath>/</targetPath>\n                            <directory>${project.build.directory}</directory>\n                            <include>${project.build.finalName}.jar</include>\n                        </resource>\n                    </resources>\n                </configuration>\n            </plugin>\n```\n\n参考https://github.com/spotify/docker-maven-plugin\n\n# 3 dockerFile文件放在项目根目录下docker目录\n```\nFROM openjre\nMAINTAINER killko <ydhana@isoftstone.com>\nENV EUREKA_INSTANCE_NAME=eureka\nENV EUREKA_SERVICEURL=http://eureka:6080/eureka\nEXPOSE 6080\n#统一时区\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime\n\nCOPY eureka*.jar /Eureka.jar\n\nENTRYPOINT [\"java\",\"-jar\",\"-Djava.net.preferIPv4Stack=true\",\"/Eureka.jar\"]\n\n```\n# 4 maven build docker and push Image：\nmvn clean package docker:build -DpushImage\n\n（需要注意：运行环境必须有docker）","source":"_posts/七）maven-build-docker-and-push-Image.md","raw":"title: 七）maven build docker and push Image\nauthor: wen\ntags:\n  - docker\n  - maven\ncategories:\n  - docker\ndate: 2018-05-08 17:36:00\n---\n链接：[docker安装本地仓库](/2018/05/08/（六）docker安装本地仓库（root用户）/)\n使用maven 打包jar成docker镜像 并发布到镜像库\n# 1 maven settings.xml配置server 节点添加\n（这是私有库 用户名密码）\n```\n\t<server>\n\t\t\t<id>docker-hub</id>\n\t\t\t<username>testuser</username>\n\t\t\t<password>testpassword</password>\n       </server>\n```\n# 2 项目 pom.xml\nproperties 节点\n\n```\n      <docker.image.prefix>reg.itmuch.com</docker.image.prefix>\n     <docker.registry>https://reg.itmuch.com/v1</docker.registry>\n        <tag.version>1.0.0</tag.version>\n         <docker.servcerId>docker-hub</docker.servcerId>\n```\nmaven 配置组件\n```\n         <!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin -->\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>docker-maven-plugin</artifactId>\n                <version>1.0.0</version>\n                <dependencies>\n                <dependency>\n\t\t\t\t\t    <groupId>commons-logging</groupId>\n\t\t\t\t\t    <artifactId>commons-logging</artifactId>\n\t\t\t\t\t    <version>1.1.1</version>\n\t\t\t\t\t</dependency>\n                </dependencies>\n                <configuration>\n                   \t<!-- 镜像名:tag  -->\n                   <imageName>${docker.image.prefix}/${project.artifactId}:${tag.version}</imageName>\n\t\t\t\t    <!-- 指定Dockerfile所在的路径  -->\n                    <dockerDirectory>${project.basedir}/docker</dockerDirectory>\n                    <!-- 以下两行是为了docker push到DockerHub使用的。 -->\n                    <serverId>${docker.servcerId}</serverId>\n                    <registryUrl>${docker.registry}</registryUrl>\n        \t\t\t   <resources>\n                        <resource>\n                            <targetPath>/</targetPath>\n                            <directory>${project.build.directory}</directory>\n                            <include>${project.build.finalName}.jar</include>\n                        </resource>\n                    </resources>\n                </configuration>\n            </plugin>\n```\n\n参考https://github.com/spotify/docker-maven-plugin\n\n# 3 dockerFile文件放在项目根目录下docker目录\n```\nFROM openjre\nMAINTAINER killko <ydhana@isoftstone.com>\nENV EUREKA_INSTANCE_NAME=eureka\nENV EUREKA_SERVICEURL=http://eureka:6080/eureka\nEXPOSE 6080\n#统一时区\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime\n\nCOPY eureka*.jar /Eureka.jar\n\nENTRYPOINT [\"java\",\"-jar\",\"-Djava.net.preferIPv4Stack=true\",\"/Eureka.jar\"]\n\n```\n# 4 maven build docker and push Image：\nmvn clean package docker:build -DpushImage\n\n（需要注意：运行环境必须有docker）","slug":"七）maven-build-docker-and-push-Image","published":1,"updated":"2019-05-05T02:41:23.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce395002fn6zq8cidseyw","content":"<p>链接：<a href=\"/2018/05/08/（六）docker安装本地仓库（root用户）/\">docker安装本地仓库</a><br>使用maven 打包jar成docker镜像 并发布到镜像库</p>\n<h1 id=\"1-maven-settings-xml配置server-节点添加\"><a href=\"#1-maven-settings-xml配置server-节点添加\" class=\"headerlink\" title=\"1 maven settings.xml配置server 节点添加\"></a>1 maven settings.xml配置server 节点添加</h1><p>（这是私有库 用户名密码）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t\t&lt;id&gt;docker-hub&lt;/id&gt;</span><br><span class=\"line\">\t\t&lt;username&gt;testuser&lt;/username&gt;</span><br><span class=\"line\">\t\t&lt;password&gt;testpassword&lt;/password&gt;</span><br><span class=\"line\">      &lt;/server&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-项目-pom-xml\"><a href=\"#2-项目-pom-xml\" class=\"headerlink\" title=\"2 项目 pom.xml\"></a>2 项目 pom.xml</h1><p>properties 节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;docker.image.prefix&gt;reg.itmuch.com&lt;/docker.image.prefix&gt;</span><br><span class=\"line\">&lt;docker.registry&gt;https://reg.itmuch.com/v1&lt;/docker.registry&gt;</span><br><span class=\"line\">   &lt;tag.version&gt;1.0.0&lt;/tag.version&gt;</span><br><span class=\"line\">    &lt;docker.servcerId&gt;docker-hub&lt;/docker.servcerId&gt;</span><br></pre></td></tr></table></figure>\n<p>maven 配置组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt;</span><br><span class=\"line\">       &lt;plugin&gt;</span><br><span class=\"line\">           &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class=\"line\">           &lt;dependencies&gt;</span><br><span class=\"line\">           &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">           &lt;/dependencies&gt;</span><br><span class=\"line\">           &lt;configuration&gt;</span><br><span class=\"line\">              \t&lt;!-- 镜像名:tag  --&gt;</span><br><span class=\"line\">              &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;tag.version&#125;&lt;/imageName&gt;</span><br><span class=\"line\">   &lt;!-- 指定Dockerfile所在的路径  --&gt;</span><br><span class=\"line\">               &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/docker&lt;/dockerDirectory&gt;</span><br><span class=\"line\">               &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt;</span><br><span class=\"line\">               &lt;serverId&gt;$&#123;docker.servcerId&#125;&lt;/serverId&gt;</span><br><span class=\"line\">               &lt;registryUrl&gt;$&#123;docker.registry&#125;&lt;/registryUrl&gt;</span><br><span class=\"line\">   \t\t\t   &lt;resources&gt;</span><br><span class=\"line\">                   &lt;resource&gt;</span><br><span class=\"line\">                       &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class=\"line\">                       &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class=\"line\">                       &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class=\"line\">                   &lt;/resource&gt;</span><br><span class=\"line\">               &lt;/resources&gt;</span><br><span class=\"line\">           &lt;/configuration&gt;</span><br><span class=\"line\">       &lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考<a href=\"https://github.com/spotify/docker-maven-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/spotify/docker-maven-plugin</a></p>\n<h1 id=\"3-dockerFile文件放在项目根目录下docker目录\"><a href=\"#3-dockerFile文件放在项目根目录下docker目录\" class=\"headerlink\" title=\"3 dockerFile文件放在项目根目录下docker目录\"></a>3 dockerFile文件放在项目根目录下docker目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM openjre</span><br><span class=\"line\">MAINTAINER killko &lt;ydhana@isoftstone.com&gt;</span><br><span class=\"line\">ENV EUREKA_INSTANCE_NAME=eureka</span><br><span class=\"line\">ENV EUREKA_SERVICEURL=http://eureka:6080/eureka</span><br><span class=\"line\">EXPOSE 6080</span><br><span class=\"line\">#统一时区</span><br><span class=\"line\">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br><span class=\"line\"></span><br><span class=\"line\">COPY eureka*.jar /Eureka.jar</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;/Eureka.jar&quot;]</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-maven-build-docker-and-push-Image：\"><a href=\"#4-maven-build-docker-and-push-Image：\" class=\"headerlink\" title=\"4 maven build docker and push Image：\"></a>4 maven build docker and push Image：</h1><p>mvn clean package docker:build -DpushImage</p>\n<p>（需要注意：运行环境必须有docker）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>链接：<a href=\"/2018/05/08/（六）docker安装本地仓库（root用户）/\">docker安装本地仓库</a><br>使用maven 打包jar成docker镜像 并发布到镜像库</p>\n<h1 id=\"1-maven-settings-xml配置server-节点添加\"><a href=\"#1-maven-settings-xml配置server-节点添加\" class=\"headerlink\" title=\"1 maven settings.xml配置server 节点添加\"></a>1 maven settings.xml配置server 节点添加</h1><p>（这是私有库 用户名密码）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t\t&lt;id&gt;docker-hub&lt;/id&gt;</span><br><span class=\"line\">\t\t&lt;username&gt;testuser&lt;/username&gt;</span><br><span class=\"line\">\t\t&lt;password&gt;testpassword&lt;/password&gt;</span><br><span class=\"line\">      &lt;/server&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-项目-pom-xml\"><a href=\"#2-项目-pom-xml\" class=\"headerlink\" title=\"2 项目 pom.xml\"></a>2 项目 pom.xml</h1><p>properties 节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;docker.image.prefix&gt;reg.itmuch.com&lt;/docker.image.prefix&gt;</span><br><span class=\"line\">&lt;docker.registry&gt;https://reg.itmuch.com/v1&lt;/docker.registry&gt;</span><br><span class=\"line\">   &lt;tag.version&gt;1.0.0&lt;/tag.version&gt;</span><br><span class=\"line\">    &lt;docker.servcerId&gt;docker-hub&lt;/docker.servcerId&gt;</span><br></pre></td></tr></table></figure>\n<p>maven 配置组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt;</span><br><span class=\"line\">       &lt;plugin&gt;</span><br><span class=\"line\">           &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class=\"line\">           &lt;dependencies&gt;</span><br><span class=\"line\">           &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">           &lt;/dependencies&gt;</span><br><span class=\"line\">           &lt;configuration&gt;</span><br><span class=\"line\">              \t&lt;!-- 镜像名:tag  --&gt;</span><br><span class=\"line\">              &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;tag.version&#125;&lt;/imageName&gt;</span><br><span class=\"line\">   &lt;!-- 指定Dockerfile所在的路径  --&gt;</span><br><span class=\"line\">               &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/docker&lt;/dockerDirectory&gt;</span><br><span class=\"line\">               &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt;</span><br><span class=\"line\">               &lt;serverId&gt;$&#123;docker.servcerId&#125;&lt;/serverId&gt;</span><br><span class=\"line\">               &lt;registryUrl&gt;$&#123;docker.registry&#125;&lt;/registryUrl&gt;</span><br><span class=\"line\">   \t\t\t   &lt;resources&gt;</span><br><span class=\"line\">                   &lt;resource&gt;</span><br><span class=\"line\">                       &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class=\"line\">                       &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class=\"line\">                       &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class=\"line\">                   &lt;/resource&gt;</span><br><span class=\"line\">               &lt;/resources&gt;</span><br><span class=\"line\">           &lt;/configuration&gt;</span><br><span class=\"line\">       &lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考<a href=\"https://github.com/spotify/docker-maven-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/spotify/docker-maven-plugin</a></p>\n<h1 id=\"3-dockerFile文件放在项目根目录下docker目录\"><a href=\"#3-dockerFile文件放在项目根目录下docker目录\" class=\"headerlink\" title=\"3 dockerFile文件放在项目根目录下docker目录\"></a>3 dockerFile文件放在项目根目录下docker目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM openjre</span><br><span class=\"line\">MAINTAINER killko &lt;ydhana@isoftstone.com&gt;</span><br><span class=\"line\">ENV EUREKA_INSTANCE_NAME=eureka</span><br><span class=\"line\">ENV EUREKA_SERVICEURL=http://eureka:6080/eureka</span><br><span class=\"line\">EXPOSE 6080</span><br><span class=\"line\">#统一时区</span><br><span class=\"line\">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br><span class=\"line\"></span><br><span class=\"line\">COPY eureka*.jar /Eureka.jar</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;/Eureka.jar&quot;]</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-maven-build-docker-and-push-Image：\"><a href=\"#4-maven-build-docker-and-push-Image：\" class=\"headerlink\" title=\"4 maven build docker and push Image：\"></a>4 maven build docker and push Image：</h1><p>mvn clean package docker:build -DpushImage</p>\n<p>（需要注意：运行环境必须有docker）</p>\n"},{"title":"在windows下atom上搭建PlantUML书写环境","author":"wen","date":"2018-10-14T07:36:00.000Z","_content":"PlantUML是一款使用纯文本绘制UML图的开源软件。它的优点是能够帮助作者把精力集中到内容的书写上而不是格式的调整。本文介绍了一种在windows环境下atom编辑器上搭建PlantUML书写环境的方法。\n# 工具准备\n* atom\n* graphviz\n[Graphviz](http://www.graphviz.org/)是一款开源图形可视化软件。Atom的PlantUML插件使用graphviz将PlantUML语言绘制成相应的图形。\n# 插件安装\ngithub上已经有开发者为atom开发了PlantUML相关的插件。这里推荐以下两个插件\n* language-plantuml\n* plantuml-viewer\n其中language-plantuml提供了PlantUML语法高亮支持，plantuml-viewer负责把PlantUML语句转化为对应的UML图。\n```\n有很多博客使用plantuml-preview。本人试用了这两款插件，发现都能很好的支持PlantUML。\n但是plantuml-viewer更有优势：plantuml-viewer能够实时显示PlantUML语言描述的图形，\n并且可以通过鼠标滚轮流畅的调节图形大小。此外，plantuml-preview需要显式的配置java和plantuml.jar，\n而plantuml-viewer不需要，因此我推荐plantuml-viewer\n```\n安装方法很简单：atom下 File -> Settings -> Install \n![logo](windows下atom上搭建PlantUML书写环境/plantuml_plugin.png)\n\n# 配置插件\nplantuml-viewer按如下配置 \n![logo](windows下atom上搭建PlantUML书写环境/plantuml_viewer_setting.png)\n* Charset配置成utf-8在生成图形的时候中文不会乱码\n* graphviz从官网下载后安装到自定义位置，在plant-viewer中指定dot.exe路径\n\n# 验证\n用PlantUML生成工厂模式UML\n```\n@startuml\nskinparam classAttributeIconSize 0\nclass Product\nclass ConcreteProduct\nclass Creator {\n  + {abstract} FactoryMethod()\n}\nclass ConcreteCreator {\n  + FactoryMethod()\n}\nProduct <|-- ConcreteProduct\nCreator <|-- ConcreteCreator\nConcreteProduct <.l. ConcreteCreator\nnote left of Product: 定义工厂方法所创建的对象的接口\nnote right of Creator: 声明工厂方法，该方法返回一个Product类型的对象\nnote left of ConcreteProduct: 具体产品，实现了Product的接口\nnote right of ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct实例\n@enduml\n```\n效果图\n![logo](windows下atom上搭建PlantUML书写环境/3.png)\n\n[plantuml语法](http://plantuml.com/)\n","source":"_posts/windows下atom上搭建PlantUML书写环境.md","raw":"title: 在windows下atom上搭建PlantUML书写环境\nauthor: wen\ntags:\n  - plantuml\n  - atom\ncategories:\n  - atom\ndate: 2018-10-14 15:36:00\n---\nPlantUML是一款使用纯文本绘制UML图的开源软件。它的优点是能够帮助作者把精力集中到内容的书写上而不是格式的调整。本文介绍了一种在windows环境下atom编辑器上搭建PlantUML书写环境的方法。\n# 工具准备\n* atom\n* graphviz\n[Graphviz](http://www.graphviz.org/)是一款开源图形可视化软件。Atom的PlantUML插件使用graphviz将PlantUML语言绘制成相应的图形。\n# 插件安装\ngithub上已经有开发者为atom开发了PlantUML相关的插件。这里推荐以下两个插件\n* language-plantuml\n* plantuml-viewer\n其中language-plantuml提供了PlantUML语法高亮支持，plantuml-viewer负责把PlantUML语句转化为对应的UML图。\n```\n有很多博客使用plantuml-preview。本人试用了这两款插件，发现都能很好的支持PlantUML。\n但是plantuml-viewer更有优势：plantuml-viewer能够实时显示PlantUML语言描述的图形，\n并且可以通过鼠标滚轮流畅的调节图形大小。此外，plantuml-preview需要显式的配置java和plantuml.jar，\n而plantuml-viewer不需要，因此我推荐plantuml-viewer\n```\n安装方法很简单：atom下 File -> Settings -> Install \n![logo](windows下atom上搭建PlantUML书写环境/plantuml_plugin.png)\n\n# 配置插件\nplantuml-viewer按如下配置 \n![logo](windows下atom上搭建PlantUML书写环境/plantuml_viewer_setting.png)\n* Charset配置成utf-8在生成图形的时候中文不会乱码\n* graphviz从官网下载后安装到自定义位置，在plant-viewer中指定dot.exe路径\n\n# 验证\n用PlantUML生成工厂模式UML\n```\n@startuml\nskinparam classAttributeIconSize 0\nclass Product\nclass ConcreteProduct\nclass Creator {\n  + {abstract} FactoryMethod()\n}\nclass ConcreteCreator {\n  + FactoryMethod()\n}\nProduct <|-- ConcreteProduct\nCreator <|-- ConcreteCreator\nConcreteProduct <.l. ConcreteCreator\nnote left of Product: 定义工厂方法所创建的对象的接口\nnote right of Creator: 声明工厂方法，该方法返回一个Product类型的对象\nnote left of ConcreteProduct: 具体产品，实现了Product的接口\nnote right of ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct实例\n@enduml\n```\n效果图\n![logo](windows下atom上搭建PlantUML书写环境/3.png)\n\n[plantuml语法](http://plantuml.com/)\n","slug":"windows下atom上搭建PlantUML书写环境","published":1,"updated":"2019-05-05T02:41:23.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce398002hn6zqujwb3s7d","content":"<p>PlantUML是一款使用纯文本绘制UML图的开源软件。它的优点是能够帮助作者把精力集中到内容的书写上而不是格式的调整。本文介绍了一种在windows环境下atom编辑器上搭建PlantUML书写环境的方法。</p>\n<h1 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h1><ul>\n<li>atom</li>\n<li>graphviz<br><a href=\"http://www.graphviz.org/\" target=\"_blank\" rel=\"noopener\">Graphviz</a>是一款开源图形可视化软件。Atom的PlantUML插件使用graphviz将PlantUML语言绘制成相应的图形。<h1 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h1>github上已经有开发者为atom开发了PlantUML相关的插件。这里推荐以下两个插件</li>\n<li>language-plantuml</li>\n<li>plantuml-viewer<br>其中language-plantuml提供了PlantUML语法高亮支持，plantuml-viewer负责把PlantUML语句转化为对应的UML图。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有很多博客使用plantuml-preview。本人试用了这两款插件，发现都能很好的支持PlantUML。</span><br><span class=\"line\">但是plantuml-viewer更有优势：plantuml-viewer能够实时显示PlantUML语言描述的图形，</span><br><span class=\"line\">并且可以通过鼠标滚轮流畅的调节图形大小。此外，plantuml-preview需要显式的配置java和plantuml.jar，</span><br><span class=\"line\">而plantuml-viewer不需要，因此我推荐plantuml-viewer</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装方法很简单：atom下 File -&gt; Settings -&gt; Install<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/plantuml_plugin.png\" alt=\"logo\"></p>\n<h1 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h1><p>plantuml-viewer按如下配置<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/plantuml_viewer_setting.png\" alt=\"logo\"></p>\n<ul>\n<li>Charset配置成utf-8在生成图形的时候中文不会乱码</li>\n<li>graphviz从官网下载后安装到自定义位置，在plant-viewer中指定dot.exe路径</li>\n</ul>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><p>用PlantUML生成工厂模式UML<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\">skinparam classAttributeIconSize 0</span><br><span class=\"line\">class Product</span><br><span class=\"line\">class ConcreteProduct</span><br><span class=\"line\">class Creator &#123;</span><br><span class=\"line\">  + &#123;abstract&#125; FactoryMethod()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class ConcreteCreator &#123;</span><br><span class=\"line\">  + FactoryMethod()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Product &lt;|-- ConcreteProduct</span><br><span class=\"line\">Creator &lt;|-- ConcreteCreator</span><br><span class=\"line\">ConcreteProduct &lt;.l. ConcreteCreator</span><br><span class=\"line\">note left of Product: 定义工厂方法所创建的对象的接口</span><br><span class=\"line\">note right of Creator: 声明工厂方法，该方法返回一个Product类型的对象</span><br><span class=\"line\">note left of ConcreteProduct: 具体产品，实现了Product的接口</span><br><span class=\"line\">note right of ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct实例</span><br><span class=\"line\">@enduml</span><br></pre></td></tr></table></figure></p>\n<p>效果图<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/3.png\" alt=\"logo\"></p>\n<p><a href=\"http://plantuml.com/\" target=\"_blank\" rel=\"noopener\">plantuml语法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>PlantUML是一款使用纯文本绘制UML图的开源软件。它的优点是能够帮助作者把精力集中到内容的书写上而不是格式的调整。本文介绍了一种在windows环境下atom编辑器上搭建PlantUML书写环境的方法。</p>\n<h1 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h1><ul>\n<li>atom</li>\n<li>graphviz<br><a href=\"http://www.graphviz.org/\" target=\"_blank\" rel=\"noopener\">Graphviz</a>是一款开源图形可视化软件。Atom的PlantUML插件使用graphviz将PlantUML语言绘制成相应的图形。<h1 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h1>github上已经有开发者为atom开发了PlantUML相关的插件。这里推荐以下两个插件</li>\n<li>language-plantuml</li>\n<li>plantuml-viewer<br>其中language-plantuml提供了PlantUML语法高亮支持，plantuml-viewer负责把PlantUML语句转化为对应的UML图。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有很多博客使用plantuml-preview。本人试用了这两款插件，发现都能很好的支持PlantUML。</span><br><span class=\"line\">但是plantuml-viewer更有优势：plantuml-viewer能够实时显示PlantUML语言描述的图形，</span><br><span class=\"line\">并且可以通过鼠标滚轮流畅的调节图形大小。此外，plantuml-preview需要显式的配置java和plantuml.jar，</span><br><span class=\"line\">而plantuml-viewer不需要，因此我推荐plantuml-viewer</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装方法很简单：atom下 File -&gt; Settings -&gt; Install<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/plantuml_plugin.png\" alt=\"logo\"></p>\n<h1 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h1><p>plantuml-viewer按如下配置<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/plantuml_viewer_setting.png\" alt=\"logo\"></p>\n<ul>\n<li>Charset配置成utf-8在生成图形的时候中文不会乱码</li>\n<li>graphviz从官网下载后安装到自定义位置，在plant-viewer中指定dot.exe路径</li>\n</ul>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><p>用PlantUML生成工厂模式UML<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\">skinparam classAttributeIconSize 0</span><br><span class=\"line\">class Product</span><br><span class=\"line\">class ConcreteProduct</span><br><span class=\"line\">class Creator &#123;</span><br><span class=\"line\">  + &#123;abstract&#125; FactoryMethod()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class ConcreteCreator &#123;</span><br><span class=\"line\">  + FactoryMethod()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Product &lt;|-- ConcreteProduct</span><br><span class=\"line\">Creator &lt;|-- ConcreteCreator</span><br><span class=\"line\">ConcreteProduct &lt;.l. ConcreteCreator</span><br><span class=\"line\">note left of Product: 定义工厂方法所创建的对象的接口</span><br><span class=\"line\">note right of Creator: 声明工厂方法，该方法返回一个Product类型的对象</span><br><span class=\"line\">note left of ConcreteProduct: 具体产品，实现了Product的接口</span><br><span class=\"line\">note right of ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct实例</span><br><span class=\"line\">@enduml</span><br></pre></td></tr></table></figure></p>\n<p>效果图<br><img src=\"/2018/10/14/windows下atom上搭建PlantUML书写环境/3.png\" alt=\"logo\"></p>\n<p><a href=\"http://plantuml.com/\" target=\"_blank\" rel=\"noopener\">plantuml语法</a></p>\n"},{"title":"九 linux配置java和maven","author":"wen","date":"2018-05-11T14:46:00.000Z","_content":"安装链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n# 安装java\n1 从http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 页面下载jdk-8u171-linux-x64.tar.gz\n2 上传文件至linux服务器 /app\n3 在/app目录 执行\n```\ntar -xvf jdk-8u171-linux-x64.tar.gz\n```\n\n# 安装maven:\n1 在linux里/app执行：wget https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz \n2 在/app目录 执行\n```\ntar -xvf  apache-maven-3.2.3-bin.tar.gz\n```\n3 在/app/apache-maven-3.2.3/bin 目录执行\n```\nchmod +x ./mvn\n```\n\n# 配置环境(root用户)\n```\nvi /etc/profile\n```\n配置maven 和java环境\n```\nexport MAVEN_HOME=/app/apache-maven-3.2.3\nexport MAVEN_HOME\nexport PATH=$PATH:$MAVEN_HOME/bin\nexport JAVA_HOME=/app/jdk1.8.0_171\nexport JAVA_HOME\nexport PATH=$PATH:$JAVA_HOME/bin\n```\n保存完成\n```\nsource /etc/profile\n```\n\n# 验证\n```\njava -version\n```\n\n```\nmvn -v\n```","source":"_posts/九-linux配置java和maven.md","raw":"title: 九 linux配置java和maven\nauthor: wen\ntags:\n  - java\n  - maven\ncategories:\n  - linux\ndate: 2018-05-11 22:46:00\n---\n安装链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n# 安装java\n1 从http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 页面下载jdk-8u171-linux-x64.tar.gz\n2 上传文件至linux服务器 /app\n3 在/app目录 执行\n```\ntar -xvf jdk-8u171-linux-x64.tar.gz\n```\n\n# 安装maven:\n1 在linux里/app执行：wget https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz \n2 在/app目录 执行\n```\ntar -xvf  apache-maven-3.2.3-bin.tar.gz\n```\n3 在/app/apache-maven-3.2.3/bin 目录执行\n```\nchmod +x ./mvn\n```\n\n# 配置环境(root用户)\n```\nvi /etc/profile\n```\n配置maven 和java环境\n```\nexport MAVEN_HOME=/app/apache-maven-3.2.3\nexport MAVEN_HOME\nexport PATH=$PATH:$MAVEN_HOME/bin\nexport JAVA_HOME=/app/jdk1.8.0_171\nexport JAVA_HOME\nexport PATH=$PATH:$JAVA_HOME/bin\n```\n保存完成\n```\nsource /etc/profile\n```\n\n# 验证\n```\njava -version\n```\n\n```\nmvn -v\n```","slug":"九-linux配置java和maven","published":1,"updated":"2019-05-05T02:41:23.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39a002kn6zqxpdhk0wk","content":"<p>安装链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<h1 id=\"安装java\"><a href=\"#安装java\" class=\"headerlink\" title=\"安装java\"></a>安装java</h1><p>1 从<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 页面下载jdk-8u171-linux-x64.tar.gz<br>2 上传文件至linux服务器 /app<br>3 在/app目录 执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"安装maven\"><a href=\"#安装maven\" class=\"headerlink\" title=\"安装maven:\"></a>安装maven:</h1><p>1 在linux里/app执行：wget <a href=\"https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz</a><br>2 在/app目录 执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf  apache-maven-3.2.3-bin.tar.gz</span><br></pre></td></tr></table></figure></p>\n<p>3 在/app/apache-maven-3.2.3/bin 目录执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x ./mvn</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"配置环境-root用户\"><a href=\"#配置环境-root用户\" class=\"headerlink\" title=\"配置环境(root用户)\"></a>配置环境(root用户)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/profile</span><br></pre></td></tr></table></figure>\n<p>配置maven 和java环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export MAVEN_HOME=/app/apache-maven-3.2.3</span><br><span class=\"line\">export MAVEN_HOME</span><br><span class=\"line\">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class=\"line\">export JAVA_HOME=/app/jdk1.8.0_171</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></p>\n<p>保存完成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -v</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>安装链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<h1 id=\"安装java\"><a href=\"#安装java\" class=\"headerlink\" title=\"安装java\"></a>安装java</h1><p>1 从<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 页面下载jdk-8u171-linux-x64.tar.gz<br>2 上传文件至linux服务器 /app<br>3 在/app目录 执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"安装maven\"><a href=\"#安装maven\" class=\"headerlink\" title=\"安装maven:\"></a>安装maven:</h1><p>1 在linux里/app执行：wget <a href=\"https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz</a><br>2 在/app目录 执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf  apache-maven-3.2.3-bin.tar.gz</span><br></pre></td></tr></table></figure></p>\n<p>3 在/app/apache-maven-3.2.3/bin 目录执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x ./mvn</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"配置环境-root用户\"><a href=\"#配置环境-root用户\" class=\"headerlink\" title=\"配置环境(root用户)\"></a>配置环境(root用户)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/profile</span><br></pre></td></tr></table></figure>\n<p>配置maven 和java环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export MAVEN_HOME=/app/apache-maven-3.2.3</span><br><span class=\"line\">export MAVEN_HOME</span><br><span class=\"line\">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class=\"line\">export JAVA_HOME=/app/jdk1.8.0_171</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></p>\n<p>保存完成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -v</span><br></pre></td></tr></table></figure>"},{"title":"提升工作效率","author":"wen","date":"2018-05-08T06:16:00.000Z","_content":"1 时间常有，时间在于优先。\n\n2 时间总会有的：每天只计划 4～5 小时真正的工作。\n\n3 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。\n\n4 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。\n\n5 不要多任务，这只会消耗注意力；保持专注，一心一用。\n\n6、养成工作习惯，并持之以恒，你的身体会适应的。\n\n7.在有限的时间内，我们总是非常专注并且有效率。\n\n8.进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。\n\n9、迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。\n\n10、工作时间越长，并不等于效率越高\n\n11、按重要性工作，提高效率。\n\n12 有会议就尽早安排，用于准备会议\n\n的时间往往都浪费掉了。\n\n13、把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。\n\n14、一整天保持相同的工作环境。在项目/客户之间切换，会效率低。\n\n15 工作—放松—工作=高效(番茄工作法)\n\n16、把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。\n\n17 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。\n\n18 必须清楚白天必须完成的那件事，是什么。“Only ever work on the thing that will have the biggest impact” 只去做那件有着最大影响的事情。\n\n19 把任务按时间分段，就能感觉它快被搞定了。\n\n20 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！\n\n21 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。\n\n22 给所有事情都设定一个期限。不要让工作无期限地进行下去。\n\n23 针对时间紧或有压力的任务，设置结束时间，万事皆可终结\n\n24 多记，多做笔记\n\n25 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。\n\n26 休息，休息一下～","source":"_posts/升工作效率.md","raw":"title: 提升工作效率\nauthor: wen\ntags:\n  - 工作效率\n  - work\ncategories:\n  - work\ndate: 2018-05-08 14:16:00\n---\n1 时间常有，时间在于优先。\n\n2 时间总会有的：每天只计划 4～5 小时真正的工作。\n\n3 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。\n\n4 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。\n\n5 不要多任务，这只会消耗注意力；保持专注，一心一用。\n\n6、养成工作习惯，并持之以恒，你的身体会适应的。\n\n7.在有限的时间内，我们总是非常专注并且有效率。\n\n8.进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。\n\n9、迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。\n\n10、工作时间越长，并不等于效率越高\n\n11、按重要性工作，提高效率。\n\n12 有会议就尽早安排，用于准备会议\n\n的时间往往都浪费掉了。\n\n13、把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。\n\n14、一整天保持相同的工作环境。在项目/客户之间切换，会效率低。\n\n15 工作—放松—工作=高效(番茄工作法)\n\n16、把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。\n\n17 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。\n\n18 必须清楚白天必须完成的那件事，是什么。“Only ever work on the thing that will have the biggest impact” 只去做那件有着最大影响的事情。\n\n19 把任务按时间分段，就能感觉它快被搞定了。\n\n20 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！\n\n21 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。\n\n22 给所有事情都设定一个期限。不要让工作无期限地进行下去。\n\n23 针对时间紧或有压力的任务，设置结束时间，万事皆可终结\n\n24 多记，多做笔记\n\n25 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。\n\n26 休息，休息一下～","slug":"升工作效率","published":1,"updated":"2019-05-05T02:41:23.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39d002nn6zqxd2n4s8q","content":"<p>1 时间常有，时间在于优先。</p>\n<p>2 时间总会有的：每天只计划 4～5 小时真正的工作。</p>\n<p>3 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。</p>\n<p>4 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。</p>\n<p>5 不要多任务，这只会消耗注意力；保持专注，一心一用。</p>\n<p>6、养成工作习惯，并持之以恒，你的身体会适应的。</p>\n<p>7.在有限的时间内，我们总是非常专注并且有效率。</p>\n<p>8.进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。</p>\n<p>9、迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。</p>\n<p>10、工作时间越长，并不等于效率越高</p>\n<p>11、按重要性工作，提高效率。</p>\n<p>12 有会议就尽早安排，用于准备会议</p>\n<p>的时间往往都浪费掉了。</p>\n<p>13、把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。</p>\n<p>14、一整天保持相同的工作环境。在项目/客户之间切换，会效率低。</p>\n<p>15 工作—放松—工作=高效(番茄工作法)</p>\n<p>16、把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。</p>\n<p>17 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。</p>\n<p>18 必须清楚白天必须完成的那件事，是什么。“Only ever work on the thing that will have the biggest impact” 只去做那件有着最大影响的事情。</p>\n<p>19 把任务按时间分段，就能感觉它快被搞定了。</p>\n<p>20 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！</p>\n<p>21 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。</p>\n<p>22 给所有事情都设定一个期限。不要让工作无期限地进行下去。</p>\n<p>23 针对时间紧或有压力的任务，设置结束时间，万事皆可终结</p>\n<p>24 多记，多做笔记</p>\n<p>25 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。</p>\n<p>26 休息，休息一下～</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 时间常有，时间在于优先。</p>\n<p>2 时间总会有的：每天只计划 4～5 小时真正的工作。</p>\n<p>3 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。</p>\n<p>4 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。</p>\n<p>5 不要多任务，这只会消耗注意力；保持专注，一心一用。</p>\n<p>6、养成工作习惯，并持之以恒，你的身体会适应的。</p>\n<p>7.在有限的时间内，我们总是非常专注并且有效率。</p>\n<p>8.进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。</p>\n<p>9、迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。</p>\n<p>10、工作时间越长，并不等于效率越高</p>\n<p>11、按重要性工作，提高效率。</p>\n<p>12 有会议就尽早安排，用于准备会议</p>\n<p>的时间往往都浪费掉了。</p>\n<p>13、把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。</p>\n<p>14、一整天保持相同的工作环境。在项目/客户之间切换，会效率低。</p>\n<p>15 工作—放松—工作=高效(番茄工作法)</p>\n<p>16、把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。</p>\n<p>17 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。</p>\n<p>18 必须清楚白天必须完成的那件事，是什么。“Only ever work on the thing that will have the biggest impact” 只去做那件有着最大影响的事情。</p>\n<p>19 把任务按时间分段，就能感觉它快被搞定了。</p>\n<p>20 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！</p>\n<p>21 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。</p>\n<p>22 给所有事情都设定一个期限。不要让工作无期限地进行下去。</p>\n<p>23 针对时间紧或有压力的任务，设置结束时间，万事皆可终结</p>\n<p>24 多记，多做笔记</p>\n<p>25 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。</p>\n<p>26 休息，休息一下～</p>\n"},{"title":"（三）linux 安装 GIT（root用户）","author":"wen","date":"2018-05-08T07:52:00.000Z","_content":"链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n [升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n# 安装GIT（root用户）\nyum install git\n\n# 1 创建用户\n```\n>useradd test\n```\n\n# 2 设置密码\n```\n>passwd test\n```\n\n# 3 创建目录\n```\n>mkdir -p /repo\n```\n# 4 初始化git 库\n```\n>git init --shared /repo/code\n```\n# 5 进入目录：\n```\n>cd /repo/code\n```\n# 6 git 忽略设置\n```\n>git config receive.denyCurrentBranch\"ignore\"\n```\n# 7 设置 邮件\n```\n>git config --global user.email  123@126.com\n```\n# 8 设置 用户名\n```\n>git config --global user.name \"test\"\n```\n# 9 添加README.md\n```\n>touch ./Readme.md\n```\n\n# 10 git add文件\n```\n>git add ./Readme.md\n```\n\n# 11 提交代码\n```\n>git commit -m \"init\"./Readme.md\n```\n\n# 12 设置权限\n```\n> chmod -R og+w /repoE\n```\n\n# 13 下载代码\n```\ngit clone ssh://test@192.168.137.8/repo/code\n```\n# 14 添加文件\n```\ngit add\n```\n\n# 15 提交文件\n```\ngit commit \n```\n# 16 推送代码\n```\ngit push origin master\n```","source":"_posts/三）linux-安装-GIT（root用户）.md","raw":"title: （三）linux 安装 GIT（root用户）\nauthor: wen\ntags: []\ncategories:\n  - git\ndate: 2018-05-08 15:52:00\n---\n链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n [升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n# 安装GIT（root用户）\nyum install git\n\n# 1 创建用户\n```\n>useradd test\n```\n\n# 2 设置密码\n```\n>passwd test\n```\n\n# 3 创建目录\n```\n>mkdir -p /repo\n```\n# 4 初始化git 库\n```\n>git init --shared /repo/code\n```\n# 5 进入目录：\n```\n>cd /repo/code\n```\n# 6 git 忽略设置\n```\n>git config receive.denyCurrentBranch\"ignore\"\n```\n# 7 设置 邮件\n```\n>git config --global user.email  123@126.com\n```\n# 8 设置 用户名\n```\n>git config --global user.name \"test\"\n```\n# 9 添加README.md\n```\n>touch ./Readme.md\n```\n\n# 10 git add文件\n```\n>git add ./Readme.md\n```\n\n# 11 提交代码\n```\n>git commit -m \"init\"./Readme.md\n```\n\n# 12 设置权限\n```\n> chmod -R og+w /repoE\n```\n\n# 13 下载代码\n```\ngit clone ssh://test@192.168.137.8/repo/code\n```\n# 14 添加文件\n```\ngit add\n```\n\n# 15 提交文件\n```\ngit commit \n```\n# 16 推送代码\n```\ngit push origin master\n```","slug":"三）linux-安装-GIT（root用户）","published":1,"updated":"2019-05-05T02:41:23.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39f002qn6zq2lsr0jby","content":"<p>链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p> <a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"安装GIT（root用户）\"><a href=\"#安装GIT（root用户）\" class=\"headerlink\" title=\"安装GIT（root用户）\"></a>安装GIT（root用户）</h1><p>yum install git</p>\n<h1 id=\"1-创建用户\"><a href=\"#1-创建用户\" class=\"headerlink\" title=\"1 创建用户\"></a>1 创建用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;useradd test</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-设置密码\"><a href=\"#2-设置密码\" class=\"headerlink\" title=\"2 设置密码\"></a>2 设置密码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;passwd test</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-创建目录\"><a href=\"#3-创建目录\" class=\"headerlink\" title=\"3 创建目录\"></a>3 创建目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;mkdir -p /repo</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-初始化git-库\"><a href=\"#4-初始化git-库\" class=\"headerlink\" title=\"4 初始化git 库\"></a>4 初始化git 库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git init --shared /repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-进入目录：\"><a href=\"#5-进入目录：\" class=\"headerlink\" title=\"5 进入目录：\"></a>5 进入目录：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;cd /repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-git-忽略设置\"><a href=\"#6-git-忽略设置\" class=\"headerlink\" title=\"6 git 忽略设置\"></a>6 git 忽略设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config receive.denyCurrentBranch&quot;ignore&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-设置-邮件\"><a href=\"#7-设置-邮件\" class=\"headerlink\" title=\"7 设置 邮件\"></a>7 设置 邮件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config --global user.email  123@126.com</span><br></pre></td></tr></table></figure>\n<h1 id=\"8-设置-用户名\"><a href=\"#8-设置-用户名\" class=\"headerlink\" title=\"8 设置 用户名\"></a>8 设置 用户名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config --global user.name &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"9-添加README-md\"><a href=\"#9-添加README-md\" class=\"headerlink\" title=\"9 添加README.md\"></a>9 添加README.md</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;touch ./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"10-git-add文件\"><a href=\"#10-git-add文件\" class=\"headerlink\" title=\"10 git add文件\"></a>10 git add文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git add ./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"11-提交代码\"><a href=\"#11-提交代码\" class=\"headerlink\" title=\"11 提交代码\"></a>11 提交代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git commit -m &quot;init&quot;./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-设置权限\"><a href=\"#12-设置权限\" class=\"headerlink\" title=\"12 设置权限\"></a>12 设置权限</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chmod -R og+w /repoE</span><br></pre></td></tr></table></figure>\n<h1 id=\"13-下载代码\"><a href=\"#13-下载代码\" class=\"headerlink\" title=\"13 下载代码\"></a>13 下载代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone ssh://test@192.168.137.8/repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-添加文件\"><a href=\"#14-添加文件\" class=\"headerlink\" title=\"14 添加文件\"></a>14 添加文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add</span><br></pre></td></tr></table></figure>\n<h1 id=\"15-提交文件\"><a href=\"#15-提交文件\" class=\"headerlink\" title=\"15 提交文件\"></a>15 提交文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit</span><br></pre></td></tr></table></figure>\n<h1 id=\"16-推送代码\"><a href=\"#16-推送代码\" class=\"headerlink\" title=\"16 推送代码\"></a>16 推送代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p> <a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"安装GIT（root用户）\"><a href=\"#安装GIT（root用户）\" class=\"headerlink\" title=\"安装GIT（root用户）\"></a>安装GIT（root用户）</h1><p>yum install git</p>\n<h1 id=\"1-创建用户\"><a href=\"#1-创建用户\" class=\"headerlink\" title=\"1 创建用户\"></a>1 创建用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;useradd test</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-设置密码\"><a href=\"#2-设置密码\" class=\"headerlink\" title=\"2 设置密码\"></a>2 设置密码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;passwd test</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-创建目录\"><a href=\"#3-创建目录\" class=\"headerlink\" title=\"3 创建目录\"></a>3 创建目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;mkdir -p /repo</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-初始化git-库\"><a href=\"#4-初始化git-库\" class=\"headerlink\" title=\"4 初始化git 库\"></a>4 初始化git 库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git init --shared /repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-进入目录：\"><a href=\"#5-进入目录：\" class=\"headerlink\" title=\"5 进入目录：\"></a>5 进入目录：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;cd /repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-git-忽略设置\"><a href=\"#6-git-忽略设置\" class=\"headerlink\" title=\"6 git 忽略设置\"></a>6 git 忽略设置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config receive.denyCurrentBranch&quot;ignore&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-设置-邮件\"><a href=\"#7-设置-邮件\" class=\"headerlink\" title=\"7 设置 邮件\"></a>7 设置 邮件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config --global user.email  123@126.com</span><br></pre></td></tr></table></figure>\n<h1 id=\"8-设置-用户名\"><a href=\"#8-设置-用户名\" class=\"headerlink\" title=\"8 设置 用户名\"></a>8 设置 用户名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git config --global user.name &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"9-添加README-md\"><a href=\"#9-添加README-md\" class=\"headerlink\" title=\"9 添加README.md\"></a>9 添加README.md</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;touch ./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"10-git-add文件\"><a href=\"#10-git-add文件\" class=\"headerlink\" title=\"10 git add文件\"></a>10 git add文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git add ./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"11-提交代码\"><a href=\"#11-提交代码\" class=\"headerlink\" title=\"11 提交代码\"></a>11 提交代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;git commit -m &quot;init&quot;./Readme.md</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-设置权限\"><a href=\"#12-设置权限\" class=\"headerlink\" title=\"12 设置权限\"></a>12 设置权限</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; chmod -R og+w /repoE</span><br></pre></td></tr></table></figure>\n<h1 id=\"13-下载代码\"><a href=\"#13-下载代码\" class=\"headerlink\" title=\"13 下载代码\"></a>13 下载代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone ssh://test@192.168.137.8/repo/code</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-添加文件\"><a href=\"#14-添加文件\" class=\"headerlink\" title=\"14 添加文件\"></a>14 添加文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add</span><br></pre></td></tr></table></figure>\n<h1 id=\"15-提交文件\"><a href=\"#15-提交文件\" class=\"headerlink\" title=\"15 提交文件\"></a>15 提交文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit</span><br></pre></td></tr></table></figure>\n<h1 id=\"16-推送代码\"><a href=\"#16-推送代码\" class=\"headerlink\" title=\"16 推送代码\"></a>16 推送代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>"},{"title":"resttemplate 问题","author":"wen","date":"2019-05-29T08:38:00.000Z","_content":"最近遇到一个问题：\nmq消费 同步调用其他服务，突然不消费mq数据，且mq数据一直堆积\n\n原因：\n如果什么都不设置，RestTemplate默认使用的是SimpleClientHttpRequestFactory，其内部使用的是jdk的java.net.HttpURLConnection创建底层连接，默认是没有连接池的，connectTimeout和readTimeout都是 -1，即没有超时时间\n\n解决方案：\nhttp链接池配置\n```\n \nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n \n@Component\n@ConfigurationProperties(prefix = \"http-pool\")\n@Data\npublic class HttpPoolProperties {\n \n    private Integer maxTotal;\n    private Integer defaultMaxPerRoute;\n    private Integer connectTimeout;\n    private Integer connectionRequestTimeout;\n    private Integer socketTimeout;\n    private Integer validateAfterInactivity;\n \n}\n```\n配置文件\n```\nhttp-pool.maxTotal=200\nhttp-pool.defaultMaxPerRoute=100\nhttp-pool.connectTimeout=5000\nhttp-pool.connectionRequestTimeout=1000\nhttp-pool.socketTimeout=600000\nhttp-pool.validateAfterInactivity=2000\n```\nRestTemplateConfig\n```\n@Configuration\npublic class RestTemplateConfig {\n \n    @Autowired\n    private HttpPoolProperties httpPoolProperties;\n \n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate(httpRequestFactory());\n    }\n \n    @Bean\n    public ClientHttpRequestFactory httpRequestFactory() {\n        return new HttpComponentsClientHttpRequestFactory(httpClient());\n    }\n \n    @Bean\n    public HttpClient httpClient() {\n        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()\n                .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n                .register(\"https\", SSLConnectionSocketFactory.getSocketFactory())\n                .build();\n        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);\n        connectionManager.setMaxTotal(httpPoolProperties.getMaxTotal());\n        connectionManager.setDefaultMaxPerRoute(httpPoolProperties.getDefaultMaxPerRoute());\n        connectionManager.setValidateAfterInactivity(httpPoolProperties.getValidateAfterInactivity());\n        RequestConfig requestConfig = RequestConfig.custom()\n                .setSocketTimeout(httpPoolProperties.getSocketTimeout()) //服务器返回数据(response)的时间，超过抛出read timeout\n                .setConnectTimeout(httpPoolProperties.getConnectTimeout()) //连接上服务器(握手成功)的时间，超出抛出connect timeout\n                .setConnectionRequestTimeout(httpPoolProperties.getConnectionRequestTimeout())//从连接池中获取连接的超时时间，超时间未拿到可用连接，会抛出org.apache.http.conn.ConnectionPoolTimeoutException: Timeout waiting for connection from pool\n                .build();\n        return HttpClientBuilder.create()\n                .setDefaultRequestConfig(requestConfig)\n                .setConnectionManager(connectionManager)\n                .build();\n    }\n}\n```\n引用\n```\n  @Autowired\n    private RestTemplate restTemplate;\n```","source":"_posts/sttemplate-问题.md","raw":"title: resttemplate 问题\nauthor: wen\ntags:\n  - resttemplate\n  - spring cloud\ncategories:\n  - spring cloud\ndate: 2019-05-29 16:38:00\n---\n最近遇到一个问题：\nmq消费 同步调用其他服务，突然不消费mq数据，且mq数据一直堆积\n\n原因：\n如果什么都不设置，RestTemplate默认使用的是SimpleClientHttpRequestFactory，其内部使用的是jdk的java.net.HttpURLConnection创建底层连接，默认是没有连接池的，connectTimeout和readTimeout都是 -1，即没有超时时间\n\n解决方案：\nhttp链接池配置\n```\n \nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n \n@Component\n@ConfigurationProperties(prefix = \"http-pool\")\n@Data\npublic class HttpPoolProperties {\n \n    private Integer maxTotal;\n    private Integer defaultMaxPerRoute;\n    private Integer connectTimeout;\n    private Integer connectionRequestTimeout;\n    private Integer socketTimeout;\n    private Integer validateAfterInactivity;\n \n}\n```\n配置文件\n```\nhttp-pool.maxTotal=200\nhttp-pool.defaultMaxPerRoute=100\nhttp-pool.connectTimeout=5000\nhttp-pool.connectionRequestTimeout=1000\nhttp-pool.socketTimeout=600000\nhttp-pool.validateAfterInactivity=2000\n```\nRestTemplateConfig\n```\n@Configuration\npublic class RestTemplateConfig {\n \n    @Autowired\n    private HttpPoolProperties httpPoolProperties;\n \n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate(httpRequestFactory());\n    }\n \n    @Bean\n    public ClientHttpRequestFactory httpRequestFactory() {\n        return new HttpComponentsClientHttpRequestFactory(httpClient());\n    }\n \n    @Bean\n    public HttpClient httpClient() {\n        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()\n                .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n                .register(\"https\", SSLConnectionSocketFactory.getSocketFactory())\n                .build();\n        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);\n        connectionManager.setMaxTotal(httpPoolProperties.getMaxTotal());\n        connectionManager.setDefaultMaxPerRoute(httpPoolProperties.getDefaultMaxPerRoute());\n        connectionManager.setValidateAfterInactivity(httpPoolProperties.getValidateAfterInactivity());\n        RequestConfig requestConfig = RequestConfig.custom()\n                .setSocketTimeout(httpPoolProperties.getSocketTimeout()) //服务器返回数据(response)的时间，超过抛出read timeout\n                .setConnectTimeout(httpPoolProperties.getConnectTimeout()) //连接上服务器(握手成功)的时间，超出抛出connect timeout\n                .setConnectionRequestTimeout(httpPoolProperties.getConnectionRequestTimeout())//从连接池中获取连接的超时时间，超时间未拿到可用连接，会抛出org.apache.http.conn.ConnectionPoolTimeoutException: Timeout waiting for connection from pool\n                .build();\n        return HttpClientBuilder.create()\n                .setDefaultRequestConfig(requestConfig)\n                .setConnectionManager(connectionManager)\n                .build();\n    }\n}\n```\n引用\n```\n  @Autowired\n    private RestTemplate restTemplate;\n```","slug":"sttemplate-问题","published":1,"updated":"2019-06-09T15:13:13.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39i002vn6zqk5xoad9n","content":"<p>最近遇到一个问题：<br>mq消费 同步调用其他服务，突然不消费mq数据，且mq数据一直堆积</p>\n<p>原因：<br>如果什么都不设置，RestTemplate默认使用的是SimpleClientHttpRequestFactory，其内部使用的是jdk的java.net.HttpURLConnection创建底层连接，默认是没有连接池的，connectTimeout和readTimeout都是 -1，即没有超时时间</p>\n<p>解决方案：<br>http链接池配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"> </span><br><span class=\"line\">@Component</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;http-pool&quot;)</span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class HttpPoolProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private Integer maxTotal;</span><br><span class=\"line\">    private Integer defaultMaxPerRoute;</span><br><span class=\"line\">    private Integer connectTimeout;</span><br><span class=\"line\">    private Integer connectionRequestTimeout;</span><br><span class=\"line\">    private Integer socketTimeout;</span><br><span class=\"line\">    private Integer validateAfterInactivity;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-pool.maxTotal=200</span><br><span class=\"line\">http-pool.defaultMaxPerRoute=100</span><br><span class=\"line\">http-pool.connectTimeout=5000</span><br><span class=\"line\">http-pool.connectionRequestTimeout=1000</span><br><span class=\"line\">http-pool.socketTimeout=600000</span><br><span class=\"line\">http-pool.validateAfterInactivity=2000</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplateConfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private HttpPoolProperties httpPoolProperties;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    @LoadBalanced</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate(httpRequestFactory());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory httpRequestFactory() &#123;</span><br><span class=\"line\">        return new HttpComponentsClientHttpRequestFactory(httpClient());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public HttpClient httpClient() &#123;</span><br><span class=\"line\">        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span><br><span class=\"line\">                .register(&quot;http&quot;, PlainConnectionSocketFactory.getSocketFactory())</span><br><span class=\"line\">                .register(&quot;https&quot;, SSLConnectionSocketFactory.getSocketFactory())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);</span><br><span class=\"line\">        connectionManager.setMaxTotal(httpPoolProperties.getMaxTotal());</span><br><span class=\"line\">        connectionManager.setDefaultMaxPerRoute(httpPoolProperties.getDefaultMaxPerRoute());</span><br><span class=\"line\">        connectionManager.setValidateAfterInactivity(httpPoolProperties.getValidateAfterInactivity());</span><br><span class=\"line\">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class=\"line\">                .setSocketTimeout(httpPoolProperties.getSocketTimeout()) //服务器返回数据(response)的时间，超过抛出read timeout</span><br><span class=\"line\">                .setConnectTimeout(httpPoolProperties.getConnectTimeout()) //连接上服务器(握手成功)的时间，超出抛出connect timeout</span><br><span class=\"line\">                .setConnectionRequestTimeout(httpPoolProperties.getConnectionRequestTimeout())//从连接池中获取连接的超时时间，超时间未拿到可用连接，会抛出org.apache.http.conn.ConnectionPoolTimeoutException: Timeout waiting for connection from pool</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        return HttpClientBuilder.create()</span><br><span class=\"line\">                .setDefaultRequestConfig(requestConfig)</span><br><span class=\"line\">                .setConnectionManager(connectionManager)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Autowired</span><br><span class=\"line\">  private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近遇到一个问题：<br>mq消费 同步调用其他服务，突然不消费mq数据，且mq数据一直堆积</p>\n<p>原因：<br>如果什么都不设置，RestTemplate默认使用的是SimpleClientHttpRequestFactory，其内部使用的是jdk的java.net.HttpURLConnection创建底层连接，默认是没有连接池的，connectTimeout和readTimeout都是 -1，即没有超时时间</p>\n<p>解决方案：<br>http链接池配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"> </span><br><span class=\"line\">@Component</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;http-pool&quot;)</span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class HttpPoolProperties &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private Integer maxTotal;</span><br><span class=\"line\">    private Integer defaultMaxPerRoute;</span><br><span class=\"line\">    private Integer connectTimeout;</span><br><span class=\"line\">    private Integer connectionRequestTimeout;</span><br><span class=\"line\">    private Integer socketTimeout;</span><br><span class=\"line\">    private Integer validateAfterInactivity;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-pool.maxTotal=200</span><br><span class=\"line\">http-pool.defaultMaxPerRoute=100</span><br><span class=\"line\">http-pool.connectTimeout=5000</span><br><span class=\"line\">http-pool.connectionRequestTimeout=1000</span><br><span class=\"line\">http-pool.socketTimeout=600000</span><br><span class=\"line\">http-pool.validateAfterInactivity=2000</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplateConfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private HttpPoolProperties httpPoolProperties;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    @LoadBalanced</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate(httpRequestFactory());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory httpRequestFactory() &#123;</span><br><span class=\"line\">        return new HttpComponentsClientHttpRequestFactory(httpClient());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public HttpClient httpClient() &#123;</span><br><span class=\"line\">        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span><br><span class=\"line\">                .register(&quot;http&quot;, PlainConnectionSocketFactory.getSocketFactory())</span><br><span class=\"line\">                .register(&quot;https&quot;, SSLConnectionSocketFactory.getSocketFactory())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);</span><br><span class=\"line\">        connectionManager.setMaxTotal(httpPoolProperties.getMaxTotal());</span><br><span class=\"line\">        connectionManager.setDefaultMaxPerRoute(httpPoolProperties.getDefaultMaxPerRoute());</span><br><span class=\"line\">        connectionManager.setValidateAfterInactivity(httpPoolProperties.getValidateAfterInactivity());</span><br><span class=\"line\">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class=\"line\">                .setSocketTimeout(httpPoolProperties.getSocketTimeout()) //服务器返回数据(response)的时间，超过抛出read timeout</span><br><span class=\"line\">                .setConnectTimeout(httpPoolProperties.getConnectTimeout()) //连接上服务器(握手成功)的时间，超出抛出connect timeout</span><br><span class=\"line\">                .setConnectionRequestTimeout(httpPoolProperties.getConnectionRequestTimeout())//从连接池中获取连接的超时时间，超时间未拿到可用连接，会抛出org.apache.http.conn.ConnectionPoolTimeoutException: Timeout waiting for connection from pool</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        return HttpClientBuilder.create()</span><br><span class=\"line\">                .setDefaultRequestConfig(requestConfig)</span><br><span class=\"line\">                .setConnectionManager(connectionManager)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Autowired</span><br><span class=\"line\">  private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"工具集","author":"wen","date":"2019-11-13T03:31:00.000Z","_content":"\n# GC分析工具\nhttps://gceasy.io/\n上传java gc文件，进行分析\n![logo](具集/2.png)\n\n# json转换\nhttp://www.bejson.com/jsonviewernew/\n![logo](具集/1.png)\n\n# MemoryAnalyzer\nhttps://www.eclipse.org/mat/\n分析java dump\n![logo](具集/3.png)\n# 性能测试jmeter","source":"_posts/具集.md","raw":"title: 工具集\nauthor: wen\ntags:\n  - 工具\ncategories:\n  - tools\ndate: 2019-11-13 11:31:00\n---\n\n# GC分析工具\nhttps://gceasy.io/\n上传java gc文件，进行分析\n![logo](具集/2.png)\n\n# json转换\nhttp://www.bejson.com/jsonviewernew/\n![logo](具集/1.png)\n\n# MemoryAnalyzer\nhttps://www.eclipse.org/mat/\n分析java dump\n![logo](具集/3.png)\n# 性能测试jmeter","slug":"具集","published":1,"updated":"2020-02-17T15:08:47.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39j002xn6zqra0y1533","content":"<h1 id=\"GC分析工具\"><a href=\"#GC分析工具\" class=\"headerlink\" title=\"GC分析工具\"></a>GC分析工具</h1><p><a href=\"https://gceasy.io/\" target=\"_blank\" rel=\"noopener\">https://gceasy.io/</a><br>上传java gc文件，进行分析<br><img src=\"/2019/11/13/具集/2.png\" alt=\"logo\"></p>\n<h1 id=\"json转换\"><a href=\"#json转换\" class=\"headerlink\" title=\"json转换\"></a>json转换</h1><p><a href=\"http://www.bejson.com/jsonviewernew/\" target=\"_blank\" rel=\"noopener\">http://www.bejson.com/jsonviewernew/</a><br><img src=\"/2019/11/13/具集/1.png\" alt=\"logo\"></p>\n<h1 id=\"MemoryAnalyzer\"><a href=\"#MemoryAnalyzer\" class=\"headerlink\" title=\"MemoryAnalyzer\"></a>MemoryAnalyzer</h1><p><a href=\"https://www.eclipse.org/mat/\" target=\"_blank\" rel=\"noopener\">https://www.eclipse.org/mat/</a><br>分析java dump<br><img src=\"/2019/11/13/具集/3.png\" alt=\"logo\"></p>\n<h1 id=\"性能测试jmeter\"><a href=\"#性能测试jmeter\" class=\"headerlink\" title=\"性能测试jmeter\"></a>性能测试jmeter</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"GC分析工具\"><a href=\"#GC分析工具\" class=\"headerlink\" title=\"GC分析工具\"></a>GC分析工具</h1><p><a href=\"https://gceasy.io/\" target=\"_blank\" rel=\"noopener\">https://gceasy.io/</a><br>上传java gc文件，进行分析<br><img src=\"/2019/11/13/具集/2.png\" alt=\"logo\"></p>\n<h1 id=\"json转换\"><a href=\"#json转换\" class=\"headerlink\" title=\"json转换\"></a>json转换</h1><p><a href=\"http://www.bejson.com/jsonviewernew/\" target=\"_blank\" rel=\"noopener\">http://www.bejson.com/jsonviewernew/</a><br><img src=\"/2019/11/13/具集/1.png\" alt=\"logo\"></p>\n<h1 id=\"MemoryAnalyzer\"><a href=\"#MemoryAnalyzer\" class=\"headerlink\" title=\"MemoryAnalyzer\"></a>MemoryAnalyzer</h1><p><a href=\"https://www.eclipse.org/mat/\" target=\"_blank\" rel=\"noopener\">https://www.eclipse.org/mat/</a><br>分析java dump<br><img src=\"/2019/11/13/具集/3.png\" alt=\"logo\"></p>\n<h1 id=\"性能测试jmeter\"><a href=\"#性能测试jmeter\" class=\"headerlink\" title=\"性能测试jmeter\"></a>性能测试jmeter</h1>"},{"title":"tomcat 三种部署方式","author":"wen","date":"2020-01-03T02:26:00.000Z","_content":"\n\n# 一Tomcat自动部署：\n只要将一个Web应用的WebContent级的AppName直接扔进%Tomcat_Home%\\webapps文件夹下，系统会把该web应用直接部署到Tomcat中\n因为:\n\n# 二增加自定义的Web部署文件\n我们需要在%Tomcat_Home%\\conf路径下新建一个文件夹catalina——再在其中新建一个localhost文件夹——最后再新建一个XML文件，即增加两层目录并新增XML文件：%Tomcat_Home%\\conf\\Catalina\\localhost\\web应用配置文件.xml ，该文件就是部署Web应用的配置文件。例如，我们新建一个%Tomcat_Home%\\conf\\Catalina\\localhost\\XXX.xml，  该文件的内容如下：\n```\n<Context path=\"/XXX\" reloadable=\"true\" docBase=\"D:\\workspace\\WebApp\\AppName\" workDir=\"D:\\workspace\\WebApp\\work\"/>  \n```\n\n# 手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用\n\n打开%Tomcat_Home%\\conf\\server.xml文件并在其中增加以下元素：\n\n```\n\n<Context docBase=\"D:\\workspace\\WebApp\\AppName\" path=\"/XXX\" debug=\"0\" reloadable=\"false\" /> \n```\n\n总结：第一种和第二种：\ntomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用\n","source":"_posts/omcat-三种部署方式.md","raw":"title: tomcat 三种部署方式\nauthor: wen\ntags:\n  - tomcat\ncategories: []\ndate: 2020-01-03 10:26:00\n---\n\n\n# 一Tomcat自动部署：\n只要将一个Web应用的WebContent级的AppName直接扔进%Tomcat_Home%\\webapps文件夹下，系统会把该web应用直接部署到Tomcat中\n因为:\n\n# 二增加自定义的Web部署文件\n我们需要在%Tomcat_Home%\\conf路径下新建一个文件夹catalina——再在其中新建一个localhost文件夹——最后再新建一个XML文件，即增加两层目录并新增XML文件：%Tomcat_Home%\\conf\\Catalina\\localhost\\web应用配置文件.xml ，该文件就是部署Web应用的配置文件。例如，我们新建一个%Tomcat_Home%\\conf\\Catalina\\localhost\\XXX.xml，  该文件的内容如下：\n```\n<Context path=\"/XXX\" reloadable=\"true\" docBase=\"D:\\workspace\\WebApp\\AppName\" workDir=\"D:\\workspace\\WebApp\\work\"/>  \n```\n\n# 手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用\n\n打开%Tomcat_Home%\\conf\\server.xml文件并在其中增加以下元素：\n\n```\n\n<Context docBase=\"D:\\workspace\\WebApp\\AppName\" path=\"/XXX\" debug=\"0\" reloadable=\"false\" /> \n```\n\n总结：第一种和第二种：\ntomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用\n","slug":"omcat-三种部署方式","published":1,"updated":"2020-08-08T01:59:28.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39m0032n6zqi1333a09","content":"<h1 id=\"一Tomcat自动部署：\"><a href=\"#一Tomcat自动部署：\" class=\"headerlink\" title=\"一Tomcat自动部署：\"></a>一Tomcat自动部署：</h1><p>只要将一个Web应用的WebContent级的AppName直接扔进%Tomcat_Home%\\webapps文件夹下，系统会把该web应用直接部署到Tomcat中<br>因为:</p>\n<h1 id=\"二增加自定义的Web部署文件\"><a href=\"#二增加自定义的Web部署文件\" class=\"headerlink\" title=\"二增加自定义的Web部署文件\"></a>二增加自定义的Web部署文件</h1><p>我们需要在%Tomcat_Home%\\conf路径下新建一个文件夹catalina——再在其中新建一个localhost文件夹——最后再新建一个XML文件，即增加两层目录并新增XML文件：%Tomcat_Home%\\conf\\Catalina\\localhost\\web应用配置文件.xml ，该文件就是部署Web应用的配置文件。例如，我们新建一个%Tomcat_Home%\\conf\\Catalina\\localhost\\XXX.xml，  该文件的内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Context path=&quot;/XXX&quot; reloadable=&quot;true&quot; docBase=&quot;D:\\workspace\\WebApp\\AppName&quot; workDir=&quot;D:\\workspace\\WebApp\\work&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"手动修改-Tomcat-Home-conf-server-xml文件来部署web应用\"><a href=\"#手动修改-Tomcat-Home-conf-server-xml文件来部署web应用\" class=\"headerlink\" title=\"手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用\"></a>手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用</h1><p>打开%Tomcat_Home%\\conf\\server.xml文件并在其中增加以下元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;Context docBase=&quot;D:\\workspace\\WebApp\\AppName&quot; path=&quot;/XXX&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>总结：第一种和第二种：<br>tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一Tomcat自动部署：\"><a href=\"#一Tomcat自动部署：\" class=\"headerlink\" title=\"一Tomcat自动部署：\"></a>一Tomcat自动部署：</h1><p>只要将一个Web应用的WebContent级的AppName直接扔进%Tomcat_Home%\\webapps文件夹下，系统会把该web应用直接部署到Tomcat中<br>因为:</p>\n<h1 id=\"二增加自定义的Web部署文件\"><a href=\"#二增加自定义的Web部署文件\" class=\"headerlink\" title=\"二增加自定义的Web部署文件\"></a>二增加自定义的Web部署文件</h1><p>我们需要在%Tomcat_Home%\\conf路径下新建一个文件夹catalina——再在其中新建一个localhost文件夹——最后再新建一个XML文件，即增加两层目录并新增XML文件：%Tomcat_Home%\\conf\\Catalina\\localhost\\web应用配置文件.xml ，该文件就是部署Web应用的配置文件。例如，我们新建一个%Tomcat_Home%\\conf\\Catalina\\localhost\\XXX.xml，  该文件的内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Context path=&quot;/XXX&quot; reloadable=&quot;true&quot; docBase=&quot;D:\\workspace\\WebApp\\AppName&quot; workDir=&quot;D:\\workspace\\WebApp\\work&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"手动修改-Tomcat-Home-conf-server-xml文件来部署web应用\"><a href=\"#手动修改-Tomcat-Home-conf-server-xml文件来部署web应用\" class=\"headerlink\" title=\"手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用\"></a>手动修改%Tomcat_Home%\\conf\\server.xml文件来部署web应用</h1><p>打开%Tomcat_Home%\\conf\\server.xml文件并在其中增加以下元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;Context docBase=&quot;D:\\workspace\\WebApp\\AppName&quot; path=&quot;/XXX&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>总结：第一种和第二种：<br>tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用</p>\n"},{"title":"（六）docker安装本地仓库（root用户）","author":"wen","date":"2018-05-08T09:09:00.000Z","_content":"参考：\n[安装docker](/2018/05/08/（四）安装docker（root用户）/)\n\n创建使用仓库，并设置https 及安全访问\n\n# 1下载镜像 \n```\n > docker pull registry \n```\n# 2 创建目录\n```\n> mkdir -p ~/certs \n```\n\n# 3 进入目录\n```\n> cd ~/certs  \n```\n\n# 4 创建域名证书\n```\n> openssl genrsa -out rep.itmuch.com.key 2048 \n```\n\n# 5 创建证书\n```\n> openssl req -newkey rsa:4096 -nodes -sha256 -keyout \\ rep.itmuch.com.key -x509 -days 365 -out \\ rep.itmuch.com.crt  \n\nCountry Name (2 letter code) [XX]:       # 你的国家名称\n\nCN State or Province Name (full name) []:GD    # 省份\n\nLocality Name (eg, city) [Default City]:GZ      # 所在城市\n\nOrganization Name (eg, company) [DefaultCompany Ltd]:test     # 组织名称\n\nOrganizational Unit Name (eg, section)[]:test      # 组织单元名称\n\nCommon Name (eg, your name or your server'shostname) []:rep.itmuch.com    # 域名\n\nEmail Address []:     # 邮箱 \n```\n# 3 复制证书至docker\n## 3.1创建目录\n```\n> mkdir -p /etc/docker/certs.d/rep.itmuch.com\n```\n## 3.2 复制证书至docker目录\n```\n> cp ~/certs/rep.itmuch.com.crt /etc/docker/certs.d/rep.itmuch.com/ \n```\n## 3.3 重启docker\n```\n> systemctl restart docker  \n```\n\n# 4 设置用户名和密码\n## 4.1 安装 httpd-tools\n```\n> yum install httpd-tools \n```\n## 4.2 当前登录用户\n```\n> cd~  \n```\n## 4.3 创建目录\n```\n>mkdir auth \n```\n## 4.4创建用户名和密码 \n```\nhtpasswd -Bbn testuser testpassword > auth/htpasswd  \n```\n## 5 运行\n```\ndocker run -d -p 443:5000   \\-v /root/certs:/certs \\ -v/root/auth:/auth \\-v /opt/docker-image:/var/lib/registry \\-e STORAGE_PATH=/opt/docker-image \\-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/rep.itmuch.com.crt\\-e REGISTRY_HTTP_TLS_KEY=/certs/rep.itmuch.com.key\\ -e\"REGISTRY_AUTH=htpasswd\" \\  -e\"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\  -eREGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\registry\n```\n# host主机名\n```\n echo '192.168.137.8 rep.itmuch.com'>> /etc/hosts \n```\n\n\n# 登录私有库\n```\ndocker login rep.itmuch.com\n```\npush或pull需要登录否则不能报错\n\n# push到私有库\n```\ndocker tag alpine rep.itmuch.com/alpine\n\ndocker push rep.itmuch.com/alpine\n```\n\n# 查看镜像目录\n```\nhttps://rep.itmuch.com/v2/_catalog\n```\n\n# 查看镜像 版本列表\n```\nhttps://rep.itmuch.com/v2/alpine/tags/list\n```","source":"_posts/（六）docker安装本地仓库（root用户）.md","raw":"title: （六）docker安装本地仓库（root用户）\nauthor: wen\ntags:\n  - docker\ncategories: []\ndate: 2018-05-08 17:09:00\n---\n参考：\n[安装docker](/2018/05/08/（四）安装docker（root用户）/)\n\n创建使用仓库，并设置https 及安全访问\n\n# 1下载镜像 \n```\n > docker pull registry \n```\n# 2 创建目录\n```\n> mkdir -p ~/certs \n```\n\n# 3 进入目录\n```\n> cd ~/certs  \n```\n\n# 4 创建域名证书\n```\n> openssl genrsa -out rep.itmuch.com.key 2048 \n```\n\n# 5 创建证书\n```\n> openssl req -newkey rsa:4096 -nodes -sha256 -keyout \\ rep.itmuch.com.key -x509 -days 365 -out \\ rep.itmuch.com.crt  \n\nCountry Name (2 letter code) [XX]:       # 你的国家名称\n\nCN State or Province Name (full name) []:GD    # 省份\n\nLocality Name (eg, city) [Default City]:GZ      # 所在城市\n\nOrganization Name (eg, company) [DefaultCompany Ltd]:test     # 组织名称\n\nOrganizational Unit Name (eg, section)[]:test      # 组织单元名称\n\nCommon Name (eg, your name or your server'shostname) []:rep.itmuch.com    # 域名\n\nEmail Address []:     # 邮箱 \n```\n# 3 复制证书至docker\n## 3.1创建目录\n```\n> mkdir -p /etc/docker/certs.d/rep.itmuch.com\n```\n## 3.2 复制证书至docker目录\n```\n> cp ~/certs/rep.itmuch.com.crt /etc/docker/certs.d/rep.itmuch.com/ \n```\n## 3.3 重启docker\n```\n> systemctl restart docker  \n```\n\n# 4 设置用户名和密码\n## 4.1 安装 httpd-tools\n```\n> yum install httpd-tools \n```\n## 4.2 当前登录用户\n```\n> cd~  \n```\n## 4.3 创建目录\n```\n>mkdir auth \n```\n## 4.4创建用户名和密码 \n```\nhtpasswd -Bbn testuser testpassword > auth/htpasswd  \n```\n## 5 运行\n```\ndocker run -d -p 443:5000   \\-v /root/certs:/certs \\ -v/root/auth:/auth \\-v /opt/docker-image:/var/lib/registry \\-e STORAGE_PATH=/opt/docker-image \\-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/rep.itmuch.com.crt\\-e REGISTRY_HTTP_TLS_KEY=/certs/rep.itmuch.com.key\\ -e\"REGISTRY_AUTH=htpasswd\" \\  -e\"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\  -eREGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\registry\n```\n# host主机名\n```\n echo '192.168.137.8 rep.itmuch.com'>> /etc/hosts \n```\n\n\n# 登录私有库\n```\ndocker login rep.itmuch.com\n```\npush或pull需要登录否则不能报错\n\n# push到私有库\n```\ndocker tag alpine rep.itmuch.com/alpine\n\ndocker push rep.itmuch.com/alpine\n```\n\n# 查看镜像目录\n```\nhttps://rep.itmuch.com/v2/_catalog\n```\n\n# 查看镜像 版本列表\n```\nhttps://rep.itmuch.com/v2/alpine/tags/list\n```","slug":"（六）docker安装本地仓库（root用户）","published":1,"updated":"2019-05-06T11:45:45.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39o0034n6zqdildrvu6","content":"<p>参考：<br><a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker</a></p>\n<p>创建使用仓库，并设置https 及安全访问</p>\n<h1 id=\"1下载镜像\"><a href=\"#1下载镜像\" class=\"headerlink\" title=\"1下载镜像\"></a>1下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker pull registry</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-创建目录\"><a href=\"#2-创建目录\" class=\"headerlink\" title=\"2 创建目录\"></a>2 创建目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p ~/certs</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-进入目录\"><a href=\"#3-进入目录\" class=\"headerlink\" title=\"3 进入目录\"></a>3 进入目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd ~/certs</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-创建域名证书\"><a href=\"#4-创建域名证书\" class=\"headerlink\" title=\"4 创建域名证书\"></a>4 创建域名证书</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; openssl genrsa -out rep.itmuch.com.key 2048</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-创建证书\"><a href=\"#5-创建证书\" class=\"headerlink\" title=\"5 创建证书\"></a>5 创建证书</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; openssl req -newkey rsa:4096 -nodes -sha256 -keyout \\ rep.itmuch.com.key -x509 -days 365 -out \\ rep.itmuch.com.crt  </span><br><span class=\"line\"></span><br><span class=\"line\">Country Name (2 letter code) [XX]:       # 你的国家名称</span><br><span class=\"line\"></span><br><span class=\"line\">CN State or Province Name (full name) []:GD    # 省份</span><br><span class=\"line\"></span><br><span class=\"line\">Locality Name (eg, city) [Default City]:GZ      # 所在城市</span><br><span class=\"line\"></span><br><span class=\"line\">Organization Name (eg, company) [DefaultCompany Ltd]:test     # 组织名称</span><br><span class=\"line\"></span><br><span class=\"line\">Organizational Unit Name (eg, section)[]:test      # 组织单元名称</span><br><span class=\"line\"></span><br><span class=\"line\">Common Name (eg, your name or your server&apos;shostname) []:rep.itmuch.com    # 域名</span><br><span class=\"line\"></span><br><span class=\"line\">Email Address []:     # 邮箱</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-复制证书至docker\"><a href=\"#3-复制证书至docker\" class=\"headerlink\" title=\"3 复制证书至docker\"></a>3 复制证书至docker</h1><h2 id=\"3-1创建目录\"><a href=\"#3-1创建目录\" class=\"headerlink\" title=\"3.1创建目录\"></a>3.1创建目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p /etc/docker/certs.d/rep.itmuch.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-复制证书至docker目录\"><a href=\"#3-2-复制证书至docker目录\" class=\"headerlink\" title=\"3.2 复制证书至docker目录\"></a>3.2 复制证书至docker目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cp ~/certs/rep.itmuch.com.crt /etc/docker/certs.d/rep.itmuch.com/</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-重启docker\"><a href=\"#3-3-重启docker\" class=\"headerlink\" title=\"3.3 重启docker\"></a>3.3 重启docker</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; systemctl restart docker</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-设置用户名和密码\"><a href=\"#4-设置用户名和密码\" class=\"headerlink\" title=\"4 设置用户名和密码\"></a>4 设置用户名和密码</h1><h2 id=\"4-1-安装-httpd-tools\"><a href=\"#4-1-安装-httpd-tools\" class=\"headerlink\" title=\"4.1 安装 httpd-tools\"></a>4.1 安装 httpd-tools</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; yum install httpd-tools</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2-当前登录用户\"><a href=\"#4-2-当前登录用户\" class=\"headerlink\" title=\"4.2 当前登录用户\"></a>4.2 当前登录用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd~</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-创建目录\"><a href=\"#4-3-创建目录\" class=\"headerlink\" title=\"4.3 创建目录\"></a>4.3 创建目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;mkdir auth</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4创建用户名和密码\"><a href=\"#4-4创建用户名和密码\" class=\"headerlink\" title=\"4.4创建用户名和密码\"></a>4.4创建用户名和密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">htpasswd -Bbn testuser testpassword &gt; auth/htpasswd</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-运行\"><a href=\"#5-运行\" class=\"headerlink\" title=\"5 运行\"></a>5 运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 443:5000   \\-v /root/certs:/certs \\ -v/root/auth:/auth \\-v /opt/docker-image:/var/lib/registry \\-e STORAGE_PATH=/opt/docker-image \\-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/rep.itmuch.com.crt\\-e REGISTRY_HTTP_TLS_KEY=/certs/rep.itmuch.com.key\\ -e&quot;REGISTRY_AUTH=htpasswd&quot; \\  -e&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\  -eREGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\registry</span><br></pre></td></tr></table></figure>\n<h1 id=\"host主机名\"><a href=\"#host主机名\" class=\"headerlink\" title=\"host主机名\"></a>host主机名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &apos;192.168.137.8 rep.itmuch.com&apos;&gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>\n<h1 id=\"登录私有库\"><a href=\"#登录私有库\" class=\"headerlink\" title=\"登录私有库\"></a>登录私有库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login rep.itmuch.com</span><br></pre></td></tr></table></figure>\n<p>push或pull需要登录否则不能报错</p>\n<h1 id=\"push到私有库\"><a href=\"#push到私有库\" class=\"headerlink\" title=\"push到私有库\"></a>push到私有库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag alpine rep.itmuch.com/alpine</span><br><span class=\"line\"></span><br><span class=\"line\">docker push rep.itmuch.com/alpine</span><br></pre></td></tr></table></figure>\n<h1 id=\"查看镜像目录\"><a href=\"#查看镜像目录\" class=\"headerlink\" title=\"查看镜像目录\"></a>查看镜像目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://rep.itmuch.com/v2/_catalog</span><br></pre></td></tr></table></figure>\n<h1 id=\"查看镜像-版本列表\"><a href=\"#查看镜像-版本列表\" class=\"headerlink\" title=\"查看镜像 版本列表\"></a>查看镜像 版本列表</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://rep.itmuch.com/v2/alpine/tags/list</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>参考：<br><a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker</a></p>\n<p>创建使用仓库，并设置https 及安全访问</p>\n<h1 id=\"1下载镜像\"><a href=\"#1下载镜像\" class=\"headerlink\" title=\"1下载镜像\"></a>1下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; docker pull registry</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-创建目录\"><a href=\"#2-创建目录\" class=\"headerlink\" title=\"2 创建目录\"></a>2 创建目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p ~/certs</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-进入目录\"><a href=\"#3-进入目录\" class=\"headerlink\" title=\"3 进入目录\"></a>3 进入目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd ~/certs</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-创建域名证书\"><a href=\"#4-创建域名证书\" class=\"headerlink\" title=\"4 创建域名证书\"></a>4 创建域名证书</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; openssl genrsa -out rep.itmuch.com.key 2048</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-创建证书\"><a href=\"#5-创建证书\" class=\"headerlink\" title=\"5 创建证书\"></a>5 创建证书</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; openssl req -newkey rsa:4096 -nodes -sha256 -keyout \\ rep.itmuch.com.key -x509 -days 365 -out \\ rep.itmuch.com.crt  </span><br><span class=\"line\"></span><br><span class=\"line\">Country Name (2 letter code) [XX]:       # 你的国家名称</span><br><span class=\"line\"></span><br><span class=\"line\">CN State or Province Name (full name) []:GD    # 省份</span><br><span class=\"line\"></span><br><span class=\"line\">Locality Name (eg, city) [Default City]:GZ      # 所在城市</span><br><span class=\"line\"></span><br><span class=\"line\">Organization Name (eg, company) [DefaultCompany Ltd]:test     # 组织名称</span><br><span class=\"line\"></span><br><span class=\"line\">Organizational Unit Name (eg, section)[]:test      # 组织单元名称</span><br><span class=\"line\"></span><br><span class=\"line\">Common Name (eg, your name or your server&apos;shostname) []:rep.itmuch.com    # 域名</span><br><span class=\"line\"></span><br><span class=\"line\">Email Address []:     # 邮箱</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-复制证书至docker\"><a href=\"#3-复制证书至docker\" class=\"headerlink\" title=\"3 复制证书至docker\"></a>3 复制证书至docker</h1><h2 id=\"3-1创建目录\"><a href=\"#3-1创建目录\" class=\"headerlink\" title=\"3.1创建目录\"></a>3.1创建目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mkdir -p /etc/docker/certs.d/rep.itmuch.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-复制证书至docker目录\"><a href=\"#3-2-复制证书至docker目录\" class=\"headerlink\" title=\"3.2 复制证书至docker目录\"></a>3.2 复制证书至docker目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cp ~/certs/rep.itmuch.com.crt /etc/docker/certs.d/rep.itmuch.com/</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-重启docker\"><a href=\"#3-3-重启docker\" class=\"headerlink\" title=\"3.3 重启docker\"></a>3.3 重启docker</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; systemctl restart docker</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-设置用户名和密码\"><a href=\"#4-设置用户名和密码\" class=\"headerlink\" title=\"4 设置用户名和密码\"></a>4 设置用户名和密码</h1><h2 id=\"4-1-安装-httpd-tools\"><a href=\"#4-1-安装-httpd-tools\" class=\"headerlink\" title=\"4.1 安装 httpd-tools\"></a>4.1 安装 httpd-tools</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; yum install httpd-tools</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2-当前登录用户\"><a href=\"#4-2-当前登录用户\" class=\"headerlink\" title=\"4.2 当前登录用户\"></a>4.2 当前登录用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd~</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-创建目录\"><a href=\"#4-3-创建目录\" class=\"headerlink\" title=\"4.3 创建目录\"></a>4.3 创建目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;mkdir auth</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4创建用户名和密码\"><a href=\"#4-4创建用户名和密码\" class=\"headerlink\" title=\"4.4创建用户名和密码\"></a>4.4创建用户名和密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">htpasswd -Bbn testuser testpassword &gt; auth/htpasswd</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-运行\"><a href=\"#5-运行\" class=\"headerlink\" title=\"5 运行\"></a>5 运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 443:5000   \\-v /root/certs:/certs \\ -v/root/auth:/auth \\-v /opt/docker-image:/var/lib/registry \\-e STORAGE_PATH=/opt/docker-image \\-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/rep.itmuch.com.crt\\-e REGISTRY_HTTP_TLS_KEY=/certs/rep.itmuch.com.key\\ -e&quot;REGISTRY_AUTH=htpasswd&quot; \\  -e&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\  -eREGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\registry</span><br></pre></td></tr></table></figure>\n<h1 id=\"host主机名\"><a href=\"#host主机名\" class=\"headerlink\" title=\"host主机名\"></a>host主机名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &apos;192.168.137.8 rep.itmuch.com&apos;&gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>\n<h1 id=\"登录私有库\"><a href=\"#登录私有库\" class=\"headerlink\" title=\"登录私有库\"></a>登录私有库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login rep.itmuch.com</span><br></pre></td></tr></table></figure>\n<p>push或pull需要登录否则不能报错</p>\n<h1 id=\"push到私有库\"><a href=\"#push到私有库\" class=\"headerlink\" title=\"push到私有库\"></a>push到私有库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag alpine rep.itmuch.com/alpine</span><br><span class=\"line\"></span><br><span class=\"line\">docker push rep.itmuch.com/alpine</span><br></pre></td></tr></table></figure>\n<h1 id=\"查看镜像目录\"><a href=\"#查看镜像目录\" class=\"headerlink\" title=\"查看镜像目录\"></a>查看镜像目录</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://rep.itmuch.com/v2/_catalog</span><br></pre></td></tr></table></figure>\n<h1 id=\"查看镜像-版本列表\"><a href=\"#查看镜像-版本列表\" class=\"headerlink\" title=\"查看镜像 版本列表\"></a>查看镜像 版本列表</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://rep.itmuch.com/v2/alpine/tags/list</span><br></pre></td></tr></table></figure>"},{"title":"八）安装jenkins","author":"wen","date":"2018-05-08T10:03:00.000Z","_content":"参考：\n\n1[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n2[升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n\n# 1 安装java环境\n```\nyum install -y java\n```\n\n# 2 安装wget\n```\nyum install -y wget\n```\n\n# 3 获取jenkins的配置\n```\n wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo\n```\n# 4 导入jenkinskey\n```\n rpm --import http://pkg.jenkins.io/redhat/jenkins.io.key\n ``\n\n# 5 安装jenkins\n```\nyum install jenkins\n```\n# 6 jenkins的配置文件： \n```\n/etc/sysconfig/jenkins\n```\n# 7 运行 jenkins\n```\nservice jenkins start\n```\n# 8 查看日志：\n```\ntail-f  /var/log/jenkins/jenkins.log\n```\n![logo](安装jenkins/11278290-b7f1229f3c16a906.png)\n211是jenkins key\n\n如果不能访问请关闭防火墙\niptables -F\n\n# 9 浏览器访问：192.168.137.8：8080\n![logo](安装jenkins/11278290-e2f6e1054f7f923a.png)\n输入21120240a2cb4e8e83065dc7c71a5b88  \n点击确定\n\n# 10 安装推荐的插件\n![logo](安装jenkins/11278290-9e1548cc032d002c.png)\n# 11  等等安装完成\n![logo](安装jenkins/11278290-a2000d90816960d4.png)\n12 创建用户:  输入完信息 点击 确定：  \n![logo](安装jenkins/11278290-364c455c39845e06.png)\n13 点击save and finish\n\n![logo](安装jenkins/11278290-6cce522c3a59044b.png)\n14 安装成功\n![logo](安装jenkins/11278290-aab55082195f5c56.png)\n","source":"_posts/安装jenkins.md","raw":"title: 八）安装jenkins\nauthor: wen\ntags:\n  - jenkins\ncategories: []\ndate: 2018-05-08 18:03:00\n---\n参考：\n\n1[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n2[升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n\n# 1 安装java环境\n```\nyum install -y java\n```\n\n# 2 安装wget\n```\nyum install -y wget\n```\n\n# 3 获取jenkins的配置\n```\n wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo\n```\n# 4 导入jenkinskey\n```\n rpm --import http://pkg.jenkins.io/redhat/jenkins.io.key\n ``\n\n# 5 安装jenkins\n```\nyum install jenkins\n```\n# 6 jenkins的配置文件： \n```\n/etc/sysconfig/jenkins\n```\n# 7 运行 jenkins\n```\nservice jenkins start\n```\n# 8 查看日志：\n```\ntail-f  /var/log/jenkins/jenkins.log\n```\n![logo](安装jenkins/11278290-b7f1229f3c16a906.png)\n211是jenkins key\n\n如果不能访问请关闭防火墙\niptables -F\n\n# 9 浏览器访问：192.168.137.8：8080\n![logo](安装jenkins/11278290-e2f6e1054f7f923a.png)\n输入21120240a2cb4e8e83065dc7c71a5b88  \n点击确定\n\n# 10 安装推荐的插件\n![logo](安装jenkins/11278290-9e1548cc032d002c.png)\n# 11  等等安装完成\n![logo](安装jenkins/11278290-a2000d90816960d4.png)\n12 创建用户:  输入完信息 点击 确定：  \n![logo](安装jenkins/11278290-364c455c39845e06.png)\n13 点击save and finish\n\n![logo](安装jenkins/11278290-6cce522c3a59044b.png)\n14 安装成功\n![logo](安装jenkins/11278290-aab55082195f5c56.png)\n","slug":"安装jenkins","published":1,"updated":"2019-05-05T02:41:23.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39q0039n6zqxljx5nax","content":"<p>参考：</p>\n<p>1<a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p>2<a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"1-安装java环境\"><a href=\"#1-安装java环境\" class=\"headerlink\" title=\"1 安装java环境\"></a>1 安装java环境</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y java</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-安装wget\"><a href=\"#2-安装wget\" class=\"headerlink\" title=\"2 安装wget\"></a>2 安装wget</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y wget</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-获取jenkins的配置\"><a href=\"#3-获取jenkins的配置\" class=\"headerlink\" title=\"3 获取jenkins的配置\"></a>3 获取jenkins的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-导入jenkinskey\"><a href=\"#4-导入jenkinskey\" class=\"headerlink\" title=\"4 导入jenkinskey\"></a>4 导入jenkinskey</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> rpm --import http://pkg.jenkins.io/redhat/jenkins.io.key</span><br><span class=\"line\"> ``</span><br><span class=\"line\"></span><br><span class=\"line\"># 5 安装jenkins</span><br></pre></td></tr></table></figure>\n<p>yum install jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 6 jenkins的配置文件：</span><br></pre></td></tr></table></figure></p>\n<p>/etc/sysconfig/jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 7 运行 jenkins</span><br></pre></td></tr></table></figure></p>\n<p>service jenkins start<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 8 查看日志：</span><br></pre></td></tr></table></figure></p>\n<p>tail-f  /var/log/jenkins/jenkins.log<br><code>`</code><br><img src=\"/2018/05/08/安装jenkins/11278290-b7f1229f3c16a906.png\" alt=\"logo\"><br>211是jenkins key</p>\n<p>如果不能访问请关闭防火墙<br>iptables -F</p>\n<h1 id=\"9-浏览器访问：192-168-137-8：8080\"><a href=\"#9-浏览器访问：192-168-137-8：8080\" class=\"headerlink\" title=\"9 浏览器访问：192.168.137.8：8080\"></a>9 浏览器访问：192.168.137.8：8080</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-e2f6e1054f7f923a.png\" alt=\"logo\"><br>输入21120240a2cb4e8e83065dc7c71a5b88<br>点击确定</p>\n<h1 id=\"10-安装推荐的插件\"><a href=\"#10-安装推荐的插件\" class=\"headerlink\" title=\"10 安装推荐的插件\"></a>10 安装推荐的插件</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-9e1548cc032d002c.png\" alt=\"logo\"></p>\n<h1 id=\"11-等等安装完成\"><a href=\"#11-等等安装完成\" class=\"headerlink\" title=\"11  等等安装完成\"></a>11  等等安装完成</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-a2000d90816960d4.png\" alt=\"logo\"><br>12 创建用户:  输入完信息 点击 确定：<br><img src=\"/2018/05/08/安装jenkins/11278290-364c455c39845e06.png\" alt=\"logo\"><br>13 点击save and finish</p>\n<p><img src=\"/2018/05/08/安装jenkins/11278290-6cce522c3a59044b.png\" alt=\"logo\"><br>14 安装成功<br><img src=\"/2018/05/08/安装jenkins/11278290-aab55082195f5c56.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：</p>\n<p>1<a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p>2<a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"1-安装java环境\"><a href=\"#1-安装java环境\" class=\"headerlink\" title=\"1 安装java环境\"></a>1 安装java环境</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y java</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-安装wget\"><a href=\"#2-安装wget\" class=\"headerlink\" title=\"2 安装wget\"></a>2 安装wget</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y wget</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-获取jenkins的配置\"><a href=\"#3-获取jenkins的配置\" class=\"headerlink\" title=\"3 获取jenkins的配置\"></a>3 获取jenkins的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-导入jenkinskey\"><a href=\"#4-导入jenkinskey\" class=\"headerlink\" title=\"4 导入jenkinskey\"></a>4 导入jenkinskey</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> rpm --import http://pkg.jenkins.io/redhat/jenkins.io.key</span><br><span class=\"line\"> ``</span><br><span class=\"line\"></span><br><span class=\"line\"># 5 安装jenkins</span><br></pre></td></tr></table></figure>\n<p>yum install jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 6 jenkins的配置文件：</span><br></pre></td></tr></table></figure></p>\n<p>/etc/sysconfig/jenkins<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 7 运行 jenkins</span><br></pre></td></tr></table></figure></p>\n<p>service jenkins start<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 8 查看日志：</span><br></pre></td></tr></table></figure></p>\n<p>tail-f  /var/log/jenkins/jenkins.log<br><code>`</code><br><img src=\"/2018/05/08/安装jenkins/11278290-b7f1229f3c16a906.png\" alt=\"logo\"><br>211是jenkins key</p>\n<p>如果不能访问请关闭防火墙<br>iptables -F</p>\n<h1 id=\"9-浏览器访问：192-168-137-8：8080\"><a href=\"#9-浏览器访问：192-168-137-8：8080\" class=\"headerlink\" title=\"9 浏览器访问：192.168.137.8：8080\"></a>9 浏览器访问：192.168.137.8：8080</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-e2f6e1054f7f923a.png\" alt=\"logo\"><br>输入21120240a2cb4e8e83065dc7c71a5b88<br>点击确定</p>\n<h1 id=\"10-安装推荐的插件\"><a href=\"#10-安装推荐的插件\" class=\"headerlink\" title=\"10 安装推荐的插件\"></a>10 安装推荐的插件</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-9e1548cc032d002c.png\" alt=\"logo\"></p>\n<h1 id=\"11-等等安装完成\"><a href=\"#11-等等安装完成\" class=\"headerlink\" title=\"11  等等安装完成\"></a>11  等等安装完成</h1><p><img src=\"/2018/05/08/安装jenkins/11278290-a2000d90816960d4.png\" alt=\"logo\"><br>12 创建用户:  输入完信息 点击 确定：<br><img src=\"/2018/05/08/安装jenkins/11278290-364c455c39845e06.png\" alt=\"logo\"><br>13 点击save and finish</p>\n<p><img src=\"/2018/05/08/安装jenkins/11278290-6cce522c3a59044b.png\" alt=\"logo\"><br>14 安装成功<br><img src=\"/2018/05/08/安装jenkins/11278290-aab55082195f5c56.png\" alt=\"logo\"></p>\n"},{"title":"（五）更新docker 版本（root用户）","author":"wen","date":"2018-05-08T09:00:00.000Z","_content":"参考：[安装docker 操作](/2018/05/08/（四）安装docker（root用户）/)\n\n# 1 删除旧版本（以下操作都是使用root用户）\n```\nyum remove docker \\\n\ndocker-client \\\n\ndocker-client-latest\\ \n\ndocker-common \\\n\ndocker-latest \\\n\ndocker-latest-logrotate \\\n\ndocker-logrotate \\\n\ndocker-selinux \\\n\ndocker-engine-selinux \\\n\ndocker-engine\n\n```\n\n# 2 确保docker-ce-edge最新版本\n```\nyum-config-manager--enable docker-ce-edge\n```\n# 3 安装docker\n```\n yum install docker-ce\n```\n\n# 4 设置集群功能\n```\nvi /etc/systemd/system/multi-user.target.wants/docker.service \n在\nExecStart=/usr/bin/dockerd 添加 --experimental=true  表示启用集群功能\n```\n# 5 重新加载配置\n```\nsystemctl daemon-reload\n```\n\n# 6 启动服务\n```\nsysctemctl start docker\n```\n\n# 7 查看版本：\n```\ndocker version\n```","source":"_posts/）更新docker-版本（root用户）.md","raw":"title: （五）更新docker 版本（root用户）\nauthor: wen\ntags:\n  - docker\ncategories: []\ndate: 2018-05-08 17:00:00\n---\n参考：[安装docker 操作](/2018/05/08/（四）安装docker（root用户）/)\n\n# 1 删除旧版本（以下操作都是使用root用户）\n```\nyum remove docker \\\n\ndocker-client \\\n\ndocker-client-latest\\ \n\ndocker-common \\\n\ndocker-latest \\\n\ndocker-latest-logrotate \\\n\ndocker-logrotate \\\n\ndocker-selinux \\\n\ndocker-engine-selinux \\\n\ndocker-engine\n\n```\n\n# 2 确保docker-ce-edge最新版本\n```\nyum-config-manager--enable docker-ce-edge\n```\n# 3 安装docker\n```\n yum install docker-ce\n```\n\n# 4 设置集群功能\n```\nvi /etc/systemd/system/multi-user.target.wants/docker.service \n在\nExecStart=/usr/bin/dockerd 添加 --experimental=true  表示启用集群功能\n```\n# 5 重新加载配置\n```\nsystemctl daemon-reload\n```\n\n# 6 启动服务\n```\nsysctemctl start docker\n```\n\n# 7 查看版本：\n```\ndocker version\n```","slug":"）更新docker-版本（root用户）","published":1,"updated":"2019-05-06T11:45:45.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39s003cn6zqks3c9bux","content":"<p>参考：<a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker 操作</a></p>\n<h1 id=\"1-删除旧版本（以下操作都是使用root用户）\"><a href=\"#1-删除旧版本（以下操作都是使用root用户）\" class=\"headerlink\" title=\"1 删除旧版本（以下操作都是使用root用户）\"></a>1 删除旧版本（以下操作都是使用root用户）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum remove docker \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-client \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-client-latest\\ </span><br><span class=\"line\"></span><br><span class=\"line\">docker-common \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-latest \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-latest-logrotate \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-logrotate \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-selinux \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-engine-selinux \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-engine</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-确保docker-ce-edge最新版本\"><a href=\"#2-确保docker-ce-edge最新版本\" class=\"headerlink\" title=\"2 确保docker-ce-edge最新版本\"></a>2 确保docker-ce-edge最新版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum-config-manager--enable docker-ce-edge</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-安装docker\"><a href=\"#3-安装docker\" class=\"headerlink\" title=\"3 安装docker\"></a>3 安装docker</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker-ce</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-设置集群功能\"><a href=\"#4-设置集群功能\" class=\"headerlink\" title=\"4 设置集群功能\"></a>4 设置集群功能</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/multi-user.target.wants/docker.service </span><br><span class=\"line\">在</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd 添加 --experimental=true  表示启用集群功能</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-重新加载配置\"><a href=\"#5-重新加载配置\" class=\"headerlink\" title=\"5 重新加载配置\"></a>5 重新加载配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-启动服务\"><a href=\"#6-启动服务\" class=\"headerlink\" title=\"6 启动服务\"></a>6 启动服务</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctemctl start docker</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-查看版本：\"><a href=\"#7-查看版本：\" class=\"headerlink\" title=\"7 查看版本：\"></a>7 查看版本：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"/2018/05/08/（四）安装docker（root用户）/\">安装docker 操作</a></p>\n<h1 id=\"1-删除旧版本（以下操作都是使用root用户）\"><a href=\"#1-删除旧版本（以下操作都是使用root用户）\" class=\"headerlink\" title=\"1 删除旧版本（以下操作都是使用root用户）\"></a>1 删除旧版本（以下操作都是使用root用户）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum remove docker \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-client \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-client-latest\\ </span><br><span class=\"line\"></span><br><span class=\"line\">docker-common \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-latest \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-latest-logrotate \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-logrotate \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-selinux \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-engine-selinux \\</span><br><span class=\"line\"></span><br><span class=\"line\">docker-engine</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-确保docker-ce-edge最新版本\"><a href=\"#2-确保docker-ce-edge最新版本\" class=\"headerlink\" title=\"2 确保docker-ce-edge最新版本\"></a>2 确保docker-ce-edge最新版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum-config-manager--enable docker-ce-edge</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-安装docker\"><a href=\"#3-安装docker\" class=\"headerlink\" title=\"3 安装docker\"></a>3 安装docker</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker-ce</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-设置集群功能\"><a href=\"#4-设置集群功能\" class=\"headerlink\" title=\"4 设置集群功能\"></a>4 设置集群功能</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/multi-user.target.wants/docker.service </span><br><span class=\"line\">在</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd 添加 --experimental=true  表示启用集群功能</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-重新加载配置\"><a href=\"#5-重新加载配置\" class=\"headerlink\" title=\"5 重新加载配置\"></a>5 重新加载配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-启动服务\"><a href=\"#6-启动服务\" class=\"headerlink\" title=\"6 启动服务\"></a>6 启动服务</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctemctl start docker</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-查看版本：\"><a href=\"#7-查看版本：\" class=\"headerlink\" title=\"7 查看版本：\"></a>7 查看版本：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>"},{"title":"（一）oracle VM安装red hat liunx","author":"wen","date":"2018-05-08T07:01:00.000Z","_content":"软件：Oracle VM VirtualBox\n\n网络桥接物流网卡：\n\n# 1打开Oracle VMVirtualBox 点击新建按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-8cae3ccf049eb036.png)\n# 2 点击 下一步 按钮\n名称 输入：jenkins\n\n类型：Linux\n\n操作系统：Red Rat(64 bit)\n![logo](）oracle-VM安装red-hat-liunx/11278290-d23c40773d84371f.png)\n\n# 3 内存 默认1G，点击 下一步\n![logo](）oracle-VM安装red-hat-liunx/11278290-22f082cba471a8bb.png)\n\n# 4 选择 现在创建虚拟硬盘 ，点击 创建 按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-6a1302edff3ebf2e.png)\n\n# 5 默认选项，点击 下一步\n![logo](）oracle-VM安装red-hat-liunx/11278290-8baeb9eb905c71a2.png)\n\n# 6 选择 动态分配 ，点击 下一步 按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-7adf8cc44c0ee846.png)\n\n# 7  设置硬盘大小:40G ，后点击创建按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-4e335970ba06000f.png)\n\n# 8 点击设置按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-f9a8280cb4192f6b.png)\n\n# 9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项\n![logo](）oracle-VM安装red-hat-liunx/11278290-24e0f2beb6f3331e.png)\n\n# 10 进行选择ISO镜像，点击图中 红色部分\n![logo](）oracle-VM安装red-hat-liunx/11278290-0322ebd8568ed1e0.png)\n\n# 11 点击选择 磁盘\n![logo](）oracle-VM安装red-hat-liunx/11278290-82234f6e704f75f6.png)\n\n# 12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从https://www.linuxprobe.com/tools下载\n![logo](）oracle-VM安装red-hat-liunx/11278290-e8c8a52d140c5609.png)\n\n# 13 点击OK 按钮后\n![logo](）oracle-VM安装red-hat-liunx/11278290-e22e0734301c33b6.png)\n\n# 14 虚拟机设置完成，点击启动\n![logo](）oracle-VM安装red-hat-liunx/11278290-23e3a150c783f9fb.png)\n\n# 15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1-->enter\n![logo](）oracle-VM安装red-hat-liunx/11278290-b20d2391b41df6dc.png)\n\n\n# 16 选择语言 界面 ，点击continue\n![logo](）oracle-VM安装red-hat-liunx/11278290-fe5bdba62c19c919.png)\n\n# 17 点击network& host name\n![logo](）oracle-VM安装red-hat-liunx/11278290-77b646357a8b5e8a.png)\n\n# 18 OFF 改为ON后，点击DONE\n![logo](）oracle-VM安装red-hat-liunx/11278290-5bc80879edb2e0d6.png)\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-cd397c4737115c39.png)\n\n# 19 选择INSTALLATIONDESTINATION\n![logo](）oracle-VM安装red-hat-liunx/11278290-dc140d95517fb4de.png)\n\n# 20 点击Done,默认设置\n![logo](）oracle-VM安装red-hat-liunx/11278290-44f8decd9c26bb76.png)\n# 21 点击DATE&TIME\n![logo](）oracle-VM安装red-hat-liunx/11278290-62b4d6ecfa01455b.png)\n\n# 22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-5b08e271ee6f5d60.png)\n![logo](）oracle-VM安装red-hat-liunx/11278290-f36a34e0fbdd4dbf.png)\n# 23 点击BeginInstallation\n![logo](）oracle-VM安装red-hat-liunx/11278290-a75186d85c19ec0b.png)\n# 24 点击ROOT PASSWORD 进行设置ROOT 密码\n![logo](）oracle-VM安装red-hat-liunx/11278290-26a6a241112a9517.png)\n# 25 输入ROOT 密码点击Done\n![logo](）oracle-VM安装red-hat-liunx/11278290-7a2a749fed3fa8f9.png)\n# 26 耐心等候安装完成 如下图，点击REBOOT\n![logo](）oracle-VM安装red-hat-liunx/11278290-1df5c789751f5083.png)\n# 27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录\n![logo](）oracle-VM安装red-hat-liunx/11278290-1edb28581c216a0d.png)\n# 28 输入ip addr 查看当前虚拟机的ip\n正常：\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-92aec236bf64d15a.png)\n\n\n不正常：\n![logo](）oracle-VM安装red-hat-liunx/11278290-105894cde675332f.png)\n\n解决办法：\n\n cd/etc/sysconfig/network-scripts/\n\n打开网卡文件进行设置静态IP vi ifcfg-enp0s3\n\n首先把BOOTPROTO=\"dhcp\"改成BOOTPROTO=\"static\"表示静态获取，\n\n然后在最后追加比如下面的配置：\n\nIPADDR=192.168.1.33\n\nNETMASK=255.255.255.0\n\nGATEWAY=192.168.1.1\n\nDNS1=202.96.134.33\n\n保存后，\n\n运行systemctl restart network\n\n再次查看ip addr\n![logo](）oracle-VM安装red-hat-liunx/11278290-cc3760aa781c68ef.png)\n\n#  29 使用SecureCRT 进行连接虚拟机\n![logo](）oracle-VM安装red-hat-liunx/11278290-01decabbbeebf0d4.png)","source":"_posts/）oracle-VM安装red-hat-liunx.md","raw":"title: （一）oracle VM安装red hat liunx\nauthor: wen\ntags:\n  - red hat Linux\ncategories: []\ndate: 2018-05-08 15:01:00\n---\n软件：Oracle VM VirtualBox\n\n网络桥接物流网卡：\n\n# 1打开Oracle VMVirtualBox 点击新建按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-8cae3ccf049eb036.png)\n# 2 点击 下一步 按钮\n名称 输入：jenkins\n\n类型：Linux\n\n操作系统：Red Rat(64 bit)\n![logo](）oracle-VM安装red-hat-liunx/11278290-d23c40773d84371f.png)\n\n# 3 内存 默认1G，点击 下一步\n![logo](）oracle-VM安装red-hat-liunx/11278290-22f082cba471a8bb.png)\n\n# 4 选择 现在创建虚拟硬盘 ，点击 创建 按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-6a1302edff3ebf2e.png)\n\n# 5 默认选项，点击 下一步\n![logo](）oracle-VM安装red-hat-liunx/11278290-8baeb9eb905c71a2.png)\n\n# 6 选择 动态分配 ，点击 下一步 按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-7adf8cc44c0ee846.png)\n\n# 7  设置硬盘大小:40G ，后点击创建按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-4e335970ba06000f.png)\n\n# 8 点击设置按钮\n![logo](）oracle-VM安装red-hat-liunx/11278290-f9a8280cb4192f6b.png)\n\n# 9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项\n![logo](）oracle-VM安装red-hat-liunx/11278290-24e0f2beb6f3331e.png)\n\n# 10 进行选择ISO镜像，点击图中 红色部分\n![logo](）oracle-VM安装red-hat-liunx/11278290-0322ebd8568ed1e0.png)\n\n# 11 点击选择 磁盘\n![logo](）oracle-VM安装red-hat-liunx/11278290-82234f6e704f75f6.png)\n\n# 12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从https://www.linuxprobe.com/tools下载\n![logo](）oracle-VM安装red-hat-liunx/11278290-e8c8a52d140c5609.png)\n\n# 13 点击OK 按钮后\n![logo](）oracle-VM安装red-hat-liunx/11278290-e22e0734301c33b6.png)\n\n# 14 虚拟机设置完成，点击启动\n![logo](）oracle-VM安装red-hat-liunx/11278290-23e3a150c783f9fb.png)\n\n# 15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1-->enter\n![logo](）oracle-VM安装red-hat-liunx/11278290-b20d2391b41df6dc.png)\n\n\n# 16 选择语言 界面 ，点击continue\n![logo](）oracle-VM安装red-hat-liunx/11278290-fe5bdba62c19c919.png)\n\n# 17 点击network& host name\n![logo](）oracle-VM安装red-hat-liunx/11278290-77b646357a8b5e8a.png)\n\n# 18 OFF 改为ON后，点击DONE\n![logo](）oracle-VM安装red-hat-liunx/11278290-5bc80879edb2e0d6.png)\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-cd397c4737115c39.png)\n\n# 19 选择INSTALLATIONDESTINATION\n![logo](）oracle-VM安装red-hat-liunx/11278290-dc140d95517fb4de.png)\n\n# 20 点击Done,默认设置\n![logo](）oracle-VM安装red-hat-liunx/11278290-44f8decd9c26bb76.png)\n# 21 点击DATE&TIME\n![logo](）oracle-VM安装red-hat-liunx/11278290-62b4d6ecfa01455b.png)\n\n# 22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-5b08e271ee6f5d60.png)\n![logo](）oracle-VM安装red-hat-liunx/11278290-f36a34e0fbdd4dbf.png)\n# 23 点击BeginInstallation\n![logo](）oracle-VM安装red-hat-liunx/11278290-a75186d85c19ec0b.png)\n# 24 点击ROOT PASSWORD 进行设置ROOT 密码\n![logo](）oracle-VM安装red-hat-liunx/11278290-26a6a241112a9517.png)\n# 25 输入ROOT 密码点击Done\n![logo](）oracle-VM安装red-hat-liunx/11278290-7a2a749fed3fa8f9.png)\n# 26 耐心等候安装完成 如下图，点击REBOOT\n![logo](）oracle-VM安装red-hat-liunx/11278290-1df5c789751f5083.png)\n# 27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录\n![logo](）oracle-VM安装red-hat-liunx/11278290-1edb28581c216a0d.png)\n# 28 输入ip addr 查看当前虚拟机的ip\n正常：\n\n![logo](）oracle-VM安装red-hat-liunx/11278290-92aec236bf64d15a.png)\n\n\n不正常：\n![logo](）oracle-VM安装red-hat-liunx/11278290-105894cde675332f.png)\n\n解决办法：\n\n cd/etc/sysconfig/network-scripts/\n\n打开网卡文件进行设置静态IP vi ifcfg-enp0s3\n\n首先把BOOTPROTO=\"dhcp\"改成BOOTPROTO=\"static\"表示静态获取，\n\n然后在最后追加比如下面的配置：\n\nIPADDR=192.168.1.33\n\nNETMASK=255.255.255.0\n\nGATEWAY=192.168.1.1\n\nDNS1=202.96.134.33\n\n保存后，\n\n运行systemctl restart network\n\n再次查看ip addr\n![logo](）oracle-VM安装red-hat-liunx/11278290-cc3760aa781c68ef.png)\n\n#  29 使用SecureCRT 进行连接虚拟机\n![logo](）oracle-VM安装red-hat-liunx/11278290-01decabbbeebf0d4.png)","slug":"）oracle-VM安装red-hat-liunx","published":1,"updated":"2019-05-05T02:41:23.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39u003hn6zqp6m3zfd8","content":"<p>软件：Oracle VM VirtualBox</p>\n<p>网络桥接物流网卡：</p>\n<h1 id=\"1打开Oracle-VMVirtualBox-点击新建按钮\"><a href=\"#1打开Oracle-VMVirtualBox-点击新建按钮\" class=\"headerlink\" title=\"1打开Oracle VMVirtualBox 点击新建按钮\"></a>1打开Oracle VMVirtualBox 点击新建按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-8cae3ccf049eb036.png\" alt=\"logo\"></p>\n<h1 id=\"2-点击-下一步-按钮\"><a href=\"#2-点击-下一步-按钮\" class=\"headerlink\" title=\"2 点击 下一步 按钮\"></a>2 点击 下一步 按钮</h1><p>名称 输入：jenkins</p>\n<p>类型：Linux</p>\n<p>操作系统：Red Rat(64 bit)<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-d23c40773d84371f.png\" alt=\"logo\"></p>\n<h1 id=\"3-内存-默认1G，点击-下一步\"><a href=\"#3-内存-默认1G，点击-下一步\" class=\"headerlink\" title=\"3 内存 默认1G，点击 下一步\"></a>3 内存 默认1G，点击 下一步</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-22f082cba471a8bb.png\" alt=\"logo\"></p>\n<h1 id=\"4-选择-现在创建虚拟硬盘-，点击-创建-按钮\"><a href=\"#4-选择-现在创建虚拟硬盘-，点击-创建-按钮\" class=\"headerlink\" title=\"4 选择 现在创建虚拟硬盘 ，点击 创建 按钮\"></a>4 选择 现在创建虚拟硬盘 ，点击 创建 按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-6a1302edff3ebf2e.png\" alt=\"logo\"></p>\n<h1 id=\"5-默认选项，点击-下一步\"><a href=\"#5-默认选项，点击-下一步\" class=\"headerlink\" title=\"5 默认选项，点击 下一步\"></a>5 默认选项，点击 下一步</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-8baeb9eb905c71a2.png\" alt=\"logo\"></p>\n<h1 id=\"6-选择-动态分配-，点击-下一步-按钮\"><a href=\"#6-选择-动态分配-，点击-下一步-按钮\" class=\"headerlink\" title=\"6 选择 动态分配 ，点击 下一步 按钮\"></a>6 选择 动态分配 ，点击 下一步 按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-7adf8cc44c0ee846.png\" alt=\"logo\"></p>\n<h1 id=\"7-设置硬盘大小-40G-，后点击创建按钮\"><a href=\"#7-设置硬盘大小-40G-，后点击创建按钮\" class=\"headerlink\" title=\"7  设置硬盘大小:40G ，后点击创建按钮\"></a>7  设置硬盘大小:40G ，后点击创建按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-4e335970ba06000f.png\" alt=\"logo\"></p>\n<h1 id=\"8-点击设置按钮\"><a href=\"#8-点击设置按钮\" class=\"headerlink\" title=\"8 点击设置按钮\"></a>8 点击设置按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-f9a8280cb4192f6b.png\" alt=\"logo\"></p>\n<h1 id=\"9-选择-网卡-选项，选择-桥接网卡-方式，选择存储选项\"><a href=\"#9-选择-网卡-选项，选择-桥接网卡-方式，选择存储选项\" class=\"headerlink\" title=\"9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项\"></a>9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-24e0f2beb6f3331e.png\" alt=\"logo\"></p>\n<h1 id=\"10-进行选择ISO镜像，点击图中-红色部分\"><a href=\"#10-进行选择ISO镜像，点击图中-红色部分\" class=\"headerlink\" title=\"10 进行选择ISO镜像，点击图中 红色部分\"></a>10 进行选择ISO镜像，点击图中 红色部分</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-0322ebd8568ed1e0.png\" alt=\"logo\"></p>\n<h1 id=\"11-点击选择-磁盘\"><a href=\"#11-点击选择-磁盘\" class=\"headerlink\" title=\"11 点击选择 磁盘\"></a>11 点击选择 磁盘</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-82234f6e704f75f6.png\" alt=\"logo\"></p>\n<h1 id=\"12-在弹出窗口-选择-系统镜像，选择完成-，点击打开按钮镜像可以从https-www-linuxprobe-com-tools下载\"><a href=\"#12-在弹出窗口-选择-系统镜像，选择完成-，点击打开按钮镜像可以从https-www-linuxprobe-com-tools下载\" class=\"headerlink\" title=\"12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从https://www.linuxprobe.com/tools下载\"></a>12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从<a href=\"https://www.linuxprobe.com/tools下载\" target=\"_blank\" rel=\"noopener\">https://www.linuxprobe.com/tools下载</a></h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-e8c8a52d140c5609.png\" alt=\"logo\"></p>\n<h1 id=\"13-点击OK-按钮后\"><a href=\"#13-点击OK-按钮后\" class=\"headerlink\" title=\"13 点击OK 按钮后\"></a>13 点击OK 按钮后</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-e22e0734301c33b6.png\" alt=\"logo\"></p>\n<h1 id=\"14-虚拟机设置完成，点击启动\"><a href=\"#14-虚拟机设置完成，点击启动\" class=\"headerlink\" title=\"14 虚拟机设置完成，点击启动\"></a>14 虚拟机设置完成，点击启动</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-23e3a150c783f9fb.png\" alt=\"logo\"></p>\n<h1 id=\"15-点击-启动按钮-选择InstallRed-Hat-Enterprise-Linux-7-1–-gt-enter\"><a href=\"#15-点击-启动按钮-选择InstallRed-Hat-Enterprise-Linux-7-1–-gt-enter\" class=\"headerlink\" title=\"15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1–&gt;enter\"></a>15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1–&gt;enter</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-b20d2391b41df6dc.png\" alt=\"logo\"></p>\n<h1 id=\"16-选择语言-界面-，点击continue\"><a href=\"#16-选择语言-界面-，点击continue\" class=\"headerlink\" title=\"16 选择语言 界面 ，点击continue\"></a>16 选择语言 界面 ，点击continue</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-fe5bdba62c19c919.png\" alt=\"logo\"></p>\n<h1 id=\"17-点击network-amp-host-name\"><a href=\"#17-点击network-amp-host-name\" class=\"headerlink\" title=\"17 点击network&amp; host name\"></a>17 点击network&amp; host name</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-77b646357a8b5e8a.png\" alt=\"logo\"></p>\n<h1 id=\"18-OFF-改为ON后，点击DONE\"><a href=\"#18-OFF-改为ON后，点击DONE\" class=\"headerlink\" title=\"18 OFF 改为ON后，点击DONE\"></a>18 OFF 改为ON后，点击DONE</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-5bc80879edb2e0d6.png\" alt=\"logo\"></p>\n<p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-cd397c4737115c39.png\" alt=\"logo\"></p>\n<h1 id=\"19-选择INSTALLATIONDESTINATION\"><a href=\"#19-选择INSTALLATIONDESTINATION\" class=\"headerlink\" title=\"19 选择INSTALLATIONDESTINATION\"></a>19 选择INSTALLATIONDESTINATION</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-dc140d95517fb4de.png\" alt=\"logo\"></p>\n<h1 id=\"20-点击Done-默认设置\"><a href=\"#20-点击Done-默认设置\" class=\"headerlink\" title=\"20 点击Done,默认设置\"></a>20 点击Done,默认设置</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-44f8decd9c26bb76.png\" alt=\"logo\"></p>\n<h1 id=\"21-点击DATE-amp-TIME\"><a href=\"#21-点击DATE-amp-TIME\" class=\"headerlink\" title=\"21 点击DATE&amp;TIME\"></a>21 点击DATE&amp;TIME</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-62b4d6ecfa01455b.png\" alt=\"logo\"></p>\n<h1 id=\"22-Region-改为Asia-City-上海，networkTime-ON，后点击Done\"><a href=\"#22-Region-改为Asia-City-上海，networkTime-ON，后点击Done\" class=\"headerlink\" title=\"22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done\"></a>22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-5b08e271ee6f5d60.png\" alt=\"logo\"><br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-f36a34e0fbdd4dbf.png\" alt=\"logo\"></p>\n<h1 id=\"23-点击BeginInstallation\"><a href=\"#23-点击BeginInstallation\" class=\"headerlink\" title=\"23 点击BeginInstallation\"></a>23 点击BeginInstallation</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-a75186d85c19ec0b.png\" alt=\"logo\"></p>\n<h1 id=\"24-点击ROOT-PASSWORD-进行设置ROOT-密码\"><a href=\"#24-点击ROOT-PASSWORD-进行设置ROOT-密码\" class=\"headerlink\" title=\"24 点击ROOT PASSWORD 进行设置ROOT 密码\"></a>24 点击ROOT PASSWORD 进行设置ROOT 密码</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-26a6a241112a9517.png\" alt=\"logo\"></p>\n<h1 id=\"25-输入ROOT-密码点击Done\"><a href=\"#25-输入ROOT-密码点击Done\" class=\"headerlink\" title=\"25 输入ROOT 密码点击Done\"></a>25 输入ROOT 密码点击Done</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-7a2a749fed3fa8f9.png\" alt=\"logo\"></p>\n<h1 id=\"26-耐心等候安装完成-如下图，点击REBOOT\"><a href=\"#26-耐心等候安装完成-如下图，点击REBOOT\" class=\"headerlink\" title=\"26 耐心等候安装完成 如下图，点击REBOOT\"></a>26 耐心等候安装完成 如下图，点击REBOOT</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-1df5c789751f5083.png\" alt=\"logo\"></p>\n<h1 id=\"27-重启完成，如下图，表示安装成功，使用ROOT用户进行登录\"><a href=\"#27-重启完成，如下图，表示安装成功，使用ROOT用户进行登录\" class=\"headerlink\" title=\"27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录\"></a>27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-1edb28581c216a0d.png\" alt=\"logo\"></p>\n<h1 id=\"28-输入ip-addr-查看当前虚拟机的ip\"><a href=\"#28-输入ip-addr-查看当前虚拟机的ip\" class=\"headerlink\" title=\"28 输入ip addr 查看当前虚拟机的ip\"></a>28 输入ip addr 查看当前虚拟机的ip</h1><p>正常：</p>\n<p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-92aec236bf64d15a.png\" alt=\"logo\"></p>\n<p>不正常：<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-105894cde675332f.png\" alt=\"logo\"></p>\n<p>解决办法：</p>\n<p> cd/etc/sysconfig/network-scripts/</p>\n<p>打开网卡文件进行设置静态IP vi ifcfg-enp0s3</p>\n<p>首先把BOOTPROTO=”dhcp”改成BOOTPROTO=”static”表示静态获取，</p>\n<p>然后在最后追加比如下面的配置：</p>\n<p>IPADDR=192.168.1.33</p>\n<p>NETMASK=255.255.255.0</p>\n<p>GATEWAY=192.168.1.1</p>\n<p>DNS1=202.96.134.33</p>\n<p>保存后，</p>\n<p>运行systemctl restart network</p>\n<p>再次查看ip addr<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-cc3760aa781c68ef.png\" alt=\"logo\"></p>\n<h1 id=\"29-使用SecureCRT-进行连接虚拟机\"><a href=\"#29-使用SecureCRT-进行连接虚拟机\" class=\"headerlink\" title=\"29 使用SecureCRT 进行连接虚拟机\"></a>29 使用SecureCRT 进行连接虚拟机</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-01decabbbeebf0d4.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>软件：Oracle VM VirtualBox</p>\n<p>网络桥接物流网卡：</p>\n<h1 id=\"1打开Oracle-VMVirtualBox-点击新建按钮\"><a href=\"#1打开Oracle-VMVirtualBox-点击新建按钮\" class=\"headerlink\" title=\"1打开Oracle VMVirtualBox 点击新建按钮\"></a>1打开Oracle VMVirtualBox 点击新建按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-8cae3ccf049eb036.png\" alt=\"logo\"></p>\n<h1 id=\"2-点击-下一步-按钮\"><a href=\"#2-点击-下一步-按钮\" class=\"headerlink\" title=\"2 点击 下一步 按钮\"></a>2 点击 下一步 按钮</h1><p>名称 输入：jenkins</p>\n<p>类型：Linux</p>\n<p>操作系统：Red Rat(64 bit)<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-d23c40773d84371f.png\" alt=\"logo\"></p>\n<h1 id=\"3-内存-默认1G，点击-下一步\"><a href=\"#3-内存-默认1G，点击-下一步\" class=\"headerlink\" title=\"3 内存 默认1G，点击 下一步\"></a>3 内存 默认1G，点击 下一步</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-22f082cba471a8bb.png\" alt=\"logo\"></p>\n<h1 id=\"4-选择-现在创建虚拟硬盘-，点击-创建-按钮\"><a href=\"#4-选择-现在创建虚拟硬盘-，点击-创建-按钮\" class=\"headerlink\" title=\"4 选择 现在创建虚拟硬盘 ，点击 创建 按钮\"></a>4 选择 现在创建虚拟硬盘 ，点击 创建 按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-6a1302edff3ebf2e.png\" alt=\"logo\"></p>\n<h1 id=\"5-默认选项，点击-下一步\"><a href=\"#5-默认选项，点击-下一步\" class=\"headerlink\" title=\"5 默认选项，点击 下一步\"></a>5 默认选项，点击 下一步</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-8baeb9eb905c71a2.png\" alt=\"logo\"></p>\n<h1 id=\"6-选择-动态分配-，点击-下一步-按钮\"><a href=\"#6-选择-动态分配-，点击-下一步-按钮\" class=\"headerlink\" title=\"6 选择 动态分配 ，点击 下一步 按钮\"></a>6 选择 动态分配 ，点击 下一步 按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-7adf8cc44c0ee846.png\" alt=\"logo\"></p>\n<h1 id=\"7-设置硬盘大小-40G-，后点击创建按钮\"><a href=\"#7-设置硬盘大小-40G-，后点击创建按钮\" class=\"headerlink\" title=\"7  设置硬盘大小:40G ，后点击创建按钮\"></a>7  设置硬盘大小:40G ，后点击创建按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-4e335970ba06000f.png\" alt=\"logo\"></p>\n<h1 id=\"8-点击设置按钮\"><a href=\"#8-点击设置按钮\" class=\"headerlink\" title=\"8 点击设置按钮\"></a>8 点击设置按钮</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-f9a8280cb4192f6b.png\" alt=\"logo\"></p>\n<h1 id=\"9-选择-网卡-选项，选择-桥接网卡-方式，选择存储选项\"><a href=\"#9-选择-网卡-选项，选择-桥接网卡-方式，选择存储选项\" class=\"headerlink\" title=\"9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项\"></a>9 选择 网卡 选项，选择 桥接网卡 方式，选择存储选项</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-24e0f2beb6f3331e.png\" alt=\"logo\"></p>\n<h1 id=\"10-进行选择ISO镜像，点击图中-红色部分\"><a href=\"#10-进行选择ISO镜像，点击图中-红色部分\" class=\"headerlink\" title=\"10 进行选择ISO镜像，点击图中 红色部分\"></a>10 进行选择ISO镜像，点击图中 红色部分</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-0322ebd8568ed1e0.png\" alt=\"logo\"></p>\n<h1 id=\"11-点击选择-磁盘\"><a href=\"#11-点击选择-磁盘\" class=\"headerlink\" title=\"11 点击选择 磁盘\"></a>11 点击选择 磁盘</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-82234f6e704f75f6.png\" alt=\"logo\"></p>\n<h1 id=\"12-在弹出窗口-选择-系统镜像，选择完成-，点击打开按钮镜像可以从https-www-linuxprobe-com-tools下载\"><a href=\"#12-在弹出窗口-选择-系统镜像，选择完成-，点击打开按钮镜像可以从https-www-linuxprobe-com-tools下载\" class=\"headerlink\" title=\"12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从https://www.linuxprobe.com/tools下载\"></a>12 在弹出窗口 选择 系统镜像，选择完成 ，点击打开按钮镜像可以从<a href=\"https://www.linuxprobe.com/tools下载\" target=\"_blank\" rel=\"noopener\">https://www.linuxprobe.com/tools下载</a></h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-e8c8a52d140c5609.png\" alt=\"logo\"></p>\n<h1 id=\"13-点击OK-按钮后\"><a href=\"#13-点击OK-按钮后\" class=\"headerlink\" title=\"13 点击OK 按钮后\"></a>13 点击OK 按钮后</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-e22e0734301c33b6.png\" alt=\"logo\"></p>\n<h1 id=\"14-虚拟机设置完成，点击启动\"><a href=\"#14-虚拟机设置完成，点击启动\" class=\"headerlink\" title=\"14 虚拟机设置完成，点击启动\"></a>14 虚拟机设置完成，点击启动</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-23e3a150c783f9fb.png\" alt=\"logo\"></p>\n<h1 id=\"15-点击-启动按钮-选择InstallRed-Hat-Enterprise-Linux-7-1–-gt-enter\"><a href=\"#15-点击-启动按钮-选择InstallRed-Hat-Enterprise-Linux-7-1–-gt-enter\" class=\"headerlink\" title=\"15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1–&gt;enter\"></a>15 点击 启动按钮,选择InstallRed Hat Enterprise Linux 7.1–&gt;enter</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-b20d2391b41df6dc.png\" alt=\"logo\"></p>\n<h1 id=\"16-选择语言-界面-，点击continue\"><a href=\"#16-选择语言-界面-，点击continue\" class=\"headerlink\" title=\"16 选择语言 界面 ，点击continue\"></a>16 选择语言 界面 ，点击continue</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-fe5bdba62c19c919.png\" alt=\"logo\"></p>\n<h1 id=\"17-点击network-amp-host-name\"><a href=\"#17-点击network-amp-host-name\" class=\"headerlink\" title=\"17 点击network&amp; host name\"></a>17 点击network&amp; host name</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-77b646357a8b5e8a.png\" alt=\"logo\"></p>\n<h1 id=\"18-OFF-改为ON后，点击DONE\"><a href=\"#18-OFF-改为ON后，点击DONE\" class=\"headerlink\" title=\"18 OFF 改为ON后，点击DONE\"></a>18 OFF 改为ON后，点击DONE</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-5bc80879edb2e0d6.png\" alt=\"logo\"></p>\n<p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-cd397c4737115c39.png\" alt=\"logo\"></p>\n<h1 id=\"19-选择INSTALLATIONDESTINATION\"><a href=\"#19-选择INSTALLATIONDESTINATION\" class=\"headerlink\" title=\"19 选择INSTALLATIONDESTINATION\"></a>19 选择INSTALLATIONDESTINATION</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-dc140d95517fb4de.png\" alt=\"logo\"></p>\n<h1 id=\"20-点击Done-默认设置\"><a href=\"#20-点击Done-默认设置\" class=\"headerlink\" title=\"20 点击Done,默认设置\"></a>20 点击Done,默认设置</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-44f8decd9c26bb76.png\" alt=\"logo\"></p>\n<h1 id=\"21-点击DATE-amp-TIME\"><a href=\"#21-点击DATE-amp-TIME\" class=\"headerlink\" title=\"21 点击DATE&amp;TIME\"></a>21 点击DATE&amp;TIME</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-62b4d6ecfa01455b.png\" alt=\"logo\"></p>\n<h1 id=\"22-Region-改为Asia-City-上海，networkTime-ON，后点击Done\"><a href=\"#22-Region-改为Asia-City-上海，networkTime-ON，后点击Done\" class=\"headerlink\" title=\"22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done\"></a>22 Region 改为Asia ,City:上海，networkTime=ON，后点击Done</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-5b08e271ee6f5d60.png\" alt=\"logo\"><br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-f36a34e0fbdd4dbf.png\" alt=\"logo\"></p>\n<h1 id=\"23-点击BeginInstallation\"><a href=\"#23-点击BeginInstallation\" class=\"headerlink\" title=\"23 点击BeginInstallation\"></a>23 点击BeginInstallation</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-a75186d85c19ec0b.png\" alt=\"logo\"></p>\n<h1 id=\"24-点击ROOT-PASSWORD-进行设置ROOT-密码\"><a href=\"#24-点击ROOT-PASSWORD-进行设置ROOT-密码\" class=\"headerlink\" title=\"24 点击ROOT PASSWORD 进行设置ROOT 密码\"></a>24 点击ROOT PASSWORD 进行设置ROOT 密码</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-26a6a241112a9517.png\" alt=\"logo\"></p>\n<h1 id=\"25-输入ROOT-密码点击Done\"><a href=\"#25-输入ROOT-密码点击Done\" class=\"headerlink\" title=\"25 输入ROOT 密码点击Done\"></a>25 输入ROOT 密码点击Done</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-7a2a749fed3fa8f9.png\" alt=\"logo\"></p>\n<h1 id=\"26-耐心等候安装完成-如下图，点击REBOOT\"><a href=\"#26-耐心等候安装完成-如下图，点击REBOOT\" class=\"headerlink\" title=\"26 耐心等候安装完成 如下图，点击REBOOT\"></a>26 耐心等候安装完成 如下图，点击REBOOT</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-1df5c789751f5083.png\" alt=\"logo\"></p>\n<h1 id=\"27-重启完成，如下图，表示安装成功，使用ROOT用户进行登录\"><a href=\"#27-重启完成，如下图，表示安装成功，使用ROOT用户进行登录\" class=\"headerlink\" title=\"27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录\"></a>27 重启完成，如下图，表示安装成功，使用ROOT用户进行登录</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-1edb28581c216a0d.png\" alt=\"logo\"></p>\n<h1 id=\"28-输入ip-addr-查看当前虚拟机的ip\"><a href=\"#28-输入ip-addr-查看当前虚拟机的ip\" class=\"headerlink\" title=\"28 输入ip addr 查看当前虚拟机的ip\"></a>28 输入ip addr 查看当前虚拟机的ip</h1><p>正常：</p>\n<p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-92aec236bf64d15a.png\" alt=\"logo\"></p>\n<p>不正常：<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-105894cde675332f.png\" alt=\"logo\"></p>\n<p>解决办法：</p>\n<p> cd/etc/sysconfig/network-scripts/</p>\n<p>打开网卡文件进行设置静态IP vi ifcfg-enp0s3</p>\n<p>首先把BOOTPROTO=”dhcp”改成BOOTPROTO=”static”表示静态获取，</p>\n<p>然后在最后追加比如下面的配置：</p>\n<p>IPADDR=192.168.1.33</p>\n<p>NETMASK=255.255.255.0</p>\n<p>GATEWAY=192.168.1.1</p>\n<p>DNS1=202.96.134.33</p>\n<p>保存后，</p>\n<p>运行systemctl restart network</p>\n<p>再次查看ip addr<br><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-cc3760aa781c68ef.png\" alt=\"logo\"></p>\n<h1 id=\"29-使用SecureCRT-进行连接虚拟机\"><a href=\"#29-使用SecureCRT-进行连接虚拟机\" class=\"headerlink\" title=\"29 使用SecureCRT 进行连接虚拟机\"></a>29 使用SecureCRT 进行连接虚拟机</h1><p><img src=\"/2018/05/08/）oracle-VM安装red-hat-liunx/11278290-01decabbbeebf0d4.png\" alt=\"logo\"></p>\n"},{"title":"（四）安装docker（root用户）","author":"wen","date":"2018-05-08T07:59:00.000Z","_content":"链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n[升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n# 1 安装docker（以下操作都是使用root用户）\n```\n--安装驱动（red-hat为例,不同操作系统，驱动不同详细看官网教程）\n> yum install -y yum-utils device-mapper-persistent-data lvm2  \n\n--添加docker仓库\n> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n--清除缓存\n> yum clean all\n\n--重新更新缓存\n> yum makecache\n\n--确保docker engine最新\n> yum-config-manager --enable docker-ce-edge\n\n--安装docker\n> yum install docker-ce\n\n开机启动\n> systemctl enable docker\n\n开启集群权限\n>vi /etc/systemd/system/multi-user.target.wants/docker.service \n在\nExecStart=/usr/bin/dockerd \n添加\n--experimental=true \n\n重新加载配置\n>systemctl daemon-reload \n\n --启动docker\n>systemctl start docker\n```\n\n参考：[docker官网](https://docs.docker.com/install/linux/docker-ce/centos/)\n\ndocker 常用命令 参考[docker 命令官网](https://docs.docker.com/engine/reference/run/)\n\n# 2 查看docker 版本\n```\ndocker version --目前最新版本是 17.12.1-ce\n```\n# 3 查看docker 信息\n```\ndocker info\n```\n# 4 运行镜像\n```\ndocker run hello-word --本地没有会找镜像库 \n```\n关于run 一些参数详细参考[docker官网](https://docs.docker.com/engine/reference/run/)\n\n\n\n# 5 下载镜像\n```\ndocker pull alpine\n```\n# 6 制作java环境镜像：\n使用DockerFile 进行编写 ,参考[dockerFile官网](https://docs.docker.com/engine/reference/builder/#usage)\n\n```\nFROM alpine\nMAINTAINER killko <killko@qq.com>\nENV TIME_ZONE Asiz/Shanghai\nRUN echo '@edge http://nl.alpinelinux.org/alpine/edge/main' >> /etc/apk/repositories && \\\n    echo '@community http://nl.alpinelinux.org/alpine/edge/community' >> /etc/apk/repositories && \\\n    apk update && \\\n    apk upgrade && \\\n    apk add ca-certificates openjdk8-jre-base@community && \\\n    apk del ca-certificates && \\\n    apk add --no-cache tzdata && \\\n    echo \"${TIME_ZONE}\" > /etc/timezone && \\\n    ln -sf /usr/share/zoneinfo/${TIME_ZONE} /etc/localtime && \\\n    rm -rf /tmp/* /var/cache/apk/*\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime\n```\n编写完成进行build\n```\n>docker build  -t openjre:latest . --表示在当前目录进行制作镜像\n>docker images --查看镜像\n>docker run -it openjre sh --进行查看java是否安装成功\n```\n\n\n# 7 导入镜像\n```\ndocker load < openjre.tar\n```\n\n# 8 导出镜像：\n```\ndocker save openjre:latest  openjre.tar\n```\n\n# 9 查看镜像\n```\ndocker images\n```\n\n# 10 查看正在运行容器\n```\ndocker ps -a --查看容器id 运行状态 映射端口\n```\n\n# 11 查看容器日志\n```\ndocker logs -f 容器id --容器id从docker ps -a获取\n```\n\n# 12 停止容器\n```\ndocker stop 容器id ----容器id从docker ps -a获取\n```\n\n# 13 删除容器\n```\ndocker rm 容器id --容器id从docker ps -a获取\n```\n# 14 删除镜像\n```\ndocker rmi imagename:tag --imagename:tag imagename表示镜像名称 tag表示版本 这些信息可以从docker images进行获取\n```\n\n# 15 进入容器 运行sh命令：\ndocker exec -it 容器id sh --容器id从docker ps -a获取\n\n# 16 添加普通用户操作docker\n```\nvi etc/systemd/system/multi-user.target.wants/docker.service （操作服务）\n\nExecStart=/usr/bin/dockerd -G jenkins  #表示jenkins用户组可以操作docker命令\n\n保存后\n\nsystemctl daemon-reload --重新加载服务\n\nsystemctl restart docker --重启服务\n```","source":"_posts/（四）安装docker（root用户）.md","raw":"title: （四）安装docker（root用户）\nauthor: wen\ntags:\n  - docker\ncategories: []\ndate: 2018-05-08 15:59:00\n---\n链接：\n[oracle VM安装red hat liunx](/2018/05/08/）oracle-VM安装red-hat-liunx/)\n\n[升级RPM和YUM 包](/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/)\n\n# 1 安装docker（以下操作都是使用root用户）\n```\n--安装驱动（red-hat为例,不同操作系统，驱动不同详细看官网教程）\n> yum install -y yum-utils device-mapper-persistent-data lvm2  \n\n--添加docker仓库\n> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n--清除缓存\n> yum clean all\n\n--重新更新缓存\n> yum makecache\n\n--确保docker engine最新\n> yum-config-manager --enable docker-ce-edge\n\n--安装docker\n> yum install docker-ce\n\n开机启动\n> systemctl enable docker\n\n开启集群权限\n>vi /etc/systemd/system/multi-user.target.wants/docker.service \n在\nExecStart=/usr/bin/dockerd \n添加\n--experimental=true \n\n重新加载配置\n>systemctl daemon-reload \n\n --启动docker\n>systemctl start docker\n```\n\n参考：[docker官网](https://docs.docker.com/install/linux/docker-ce/centos/)\n\ndocker 常用命令 参考[docker 命令官网](https://docs.docker.com/engine/reference/run/)\n\n# 2 查看docker 版本\n```\ndocker version --目前最新版本是 17.12.1-ce\n```\n# 3 查看docker 信息\n```\ndocker info\n```\n# 4 运行镜像\n```\ndocker run hello-word --本地没有会找镜像库 \n```\n关于run 一些参数详细参考[docker官网](https://docs.docker.com/engine/reference/run/)\n\n\n\n# 5 下载镜像\n```\ndocker pull alpine\n```\n# 6 制作java环境镜像：\n使用DockerFile 进行编写 ,参考[dockerFile官网](https://docs.docker.com/engine/reference/builder/#usage)\n\n```\nFROM alpine\nMAINTAINER killko <killko@qq.com>\nENV TIME_ZONE Asiz/Shanghai\nRUN echo '@edge http://nl.alpinelinux.org/alpine/edge/main' >> /etc/apk/repositories && \\\n    echo '@community http://nl.alpinelinux.org/alpine/edge/community' >> /etc/apk/repositories && \\\n    apk update && \\\n    apk upgrade && \\\n    apk add ca-certificates openjdk8-jre-base@community && \\\n    apk del ca-certificates && \\\n    apk add --no-cache tzdata && \\\n    echo \"${TIME_ZONE}\" > /etc/timezone && \\\n    ln -sf /usr/share/zoneinfo/${TIME_ZONE} /etc/localtime && \\\n    rm -rf /tmp/* /var/cache/apk/*\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime\n```\n编写完成进行build\n```\n>docker build  -t openjre:latest . --表示在当前目录进行制作镜像\n>docker images --查看镜像\n>docker run -it openjre sh --进行查看java是否安装成功\n```\n\n\n# 7 导入镜像\n```\ndocker load < openjre.tar\n```\n\n# 8 导出镜像：\n```\ndocker save openjre:latest  openjre.tar\n```\n\n# 9 查看镜像\n```\ndocker images\n```\n\n# 10 查看正在运行容器\n```\ndocker ps -a --查看容器id 运行状态 映射端口\n```\n\n# 11 查看容器日志\n```\ndocker logs -f 容器id --容器id从docker ps -a获取\n```\n\n# 12 停止容器\n```\ndocker stop 容器id ----容器id从docker ps -a获取\n```\n\n# 13 删除容器\n```\ndocker rm 容器id --容器id从docker ps -a获取\n```\n# 14 删除镜像\n```\ndocker rmi imagename:tag --imagename:tag imagename表示镜像名称 tag表示版本 这些信息可以从docker images进行获取\n```\n\n# 15 进入容器 运行sh命令：\ndocker exec -it 容器id sh --容器id从docker ps -a获取\n\n# 16 添加普通用户操作docker\n```\nvi etc/systemd/system/multi-user.target.wants/docker.service （操作服务）\n\nExecStart=/usr/bin/dockerd -G jenkins  #表示jenkins用户组可以操作docker命令\n\n保存后\n\nsystemctl daemon-reload --重新加载服务\n\nsystemctl restart docker --重启服务\n```","slug":"（四）安装docker（root用户）","published":1,"updated":"2019-05-06T11:45:45.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39w003kn6zq8oxz6g2i","content":"<p>链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p><a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"1-安装docker（以下操作都是使用root用户）\"><a href=\"#1-安装docker（以下操作都是使用root用户）\" class=\"headerlink\" title=\"1 安装docker（以下操作都是使用root用户）\"></a>1 安装docker（以下操作都是使用root用户）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--安装驱动（red-hat为例,不同操作系统，驱动不同详细看官网教程）</span><br><span class=\"line\">&gt; yum install -y yum-utils device-mapper-persistent-data lvm2  </span><br><span class=\"line\"></span><br><span class=\"line\">--添加docker仓库</span><br><span class=\"line\">&gt; yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\">--清除缓存</span><br><span class=\"line\">&gt; yum clean all</span><br><span class=\"line\"></span><br><span class=\"line\">--重新更新缓存</span><br><span class=\"line\">&gt; yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\">--确保docker engine最新</span><br><span class=\"line\">&gt; yum-config-manager --enable docker-ce-edge</span><br><span class=\"line\"></span><br><span class=\"line\">--安装docker</span><br><span class=\"line\">&gt; yum install docker-ce</span><br><span class=\"line\"></span><br><span class=\"line\">开机启动</span><br><span class=\"line\">&gt; systemctl enable docker</span><br><span class=\"line\"></span><br><span class=\"line\">开启集群权限</span><br><span class=\"line\">&gt;vi /etc/systemd/system/multi-user.target.wants/docker.service </span><br><span class=\"line\">在</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd </span><br><span class=\"line\">添加</span><br><span class=\"line\">--experimental=true </span><br><span class=\"line\"></span><br><span class=\"line\">重新加载配置</span><br><span class=\"line\">&gt;systemctl daemon-reload </span><br><span class=\"line\"></span><br><span class=\"line\"> --启动docker</span><br><span class=\"line\">&gt;systemctl start docker</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\" target=\"_blank\" rel=\"noopener\">docker官网</a></p>\n<p>docker 常用命令 参考<a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">docker 命令官网</a></p>\n<h1 id=\"2-查看docker-版本\"><a href=\"#2-查看docker-版本\" class=\"headerlink\" title=\"2 查看docker 版本\"></a>2 查看docker 版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version --目前最新版本是 17.12.1-ce</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-查看docker-信息\"><a href=\"#3-查看docker-信息\" class=\"headerlink\" title=\"3 查看docker 信息\"></a>3 查看docker 信息</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-运行镜像\"><a href=\"#4-运行镜像\" class=\"headerlink\" title=\"4 运行镜像\"></a>4 运行镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run hello-word --本地没有会找镜像库</span><br></pre></td></tr></table></figure>\n<p>关于run 一些参数详细参考<a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">docker官网</a></p>\n<h1 id=\"5-下载镜像\"><a href=\"#5-下载镜像\" class=\"headerlink\" title=\"5 下载镜像\"></a>5 下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull alpine</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-制作java环境镜像：\"><a href=\"#6-制作java环境镜像：\" class=\"headerlink\" title=\"6 制作java环境镜像：\"></a>6 制作java环境镜像：</h1><p>使用DockerFile 进行编写 ,参考<a href=\"https://docs.docker.com/engine/reference/builder/#usage\" target=\"_blank\" rel=\"noopener\">dockerFile官网</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">MAINTAINER killko &lt;killko@qq.com&gt;</span><br><span class=\"line\">ENV TIME_ZONE Asiz/Shanghai</span><br><span class=\"line\">RUN echo &apos;@edge http://nl.alpinelinux.org/alpine/edge/main&apos; &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span><br><span class=\"line\">    echo &apos;@community http://nl.alpinelinux.org/alpine/edge/community&apos; &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span><br><span class=\"line\">    apk update &amp;&amp; \\</span><br><span class=\"line\">    apk upgrade &amp;&amp; \\</span><br><span class=\"line\">    apk add ca-certificates openjdk8-jre-base@community &amp;&amp; \\</span><br><span class=\"line\">    apk del ca-certificates &amp;&amp; \\</span><br><span class=\"line\">    apk add --no-cache tzdata &amp;&amp; \\</span><br><span class=\"line\">    echo &quot;$&#123;TIME_ZONE&#125;&quot; &gt; /etc/timezone &amp;&amp; \\</span><br><span class=\"line\">    ln -sf /usr/share/zoneinfo/$&#123;TIME_ZONE&#125; /etc/localtime &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /tmp/* /var/cache/apk/*</span><br><span class=\"line\">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure>\n<p>编写完成进行build<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;docker build  -t openjre:latest . --表示在当前目录进行制作镜像</span><br><span class=\"line\">&gt;docker images --查看镜像</span><br><span class=\"line\">&gt;docker run -it openjre sh --进行查看java是否安装成功</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-导入镜像\"><a href=\"#7-导入镜像\" class=\"headerlink\" title=\"7 导入镜像\"></a>7 导入镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load &lt; openjre.tar</span><br></pre></td></tr></table></figure>\n<h1 id=\"8-导出镜像：\"><a href=\"#8-导出镜像：\" class=\"headerlink\" title=\"8 导出镜像：\"></a>8 导出镜像：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save openjre:latest  openjre.tar</span><br></pre></td></tr></table></figure>\n<h1 id=\"9-查看镜像\"><a href=\"#9-查看镜像\" class=\"headerlink\" title=\"9 查看镜像\"></a>9 查看镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<h1 id=\"10-查看正在运行容器\"><a href=\"#10-查看正在运行容器\" class=\"headerlink\" title=\"10 查看正在运行容器\"></a>10 查看正在运行容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a --查看容器id 运行状态 映射端口</span><br></pre></td></tr></table></figure>\n<h1 id=\"11-查看容器日志\"><a href=\"#11-查看容器日志\" class=\"headerlink\" title=\"11 查看容器日志\"></a>11 查看容器日志</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs -f 容器id --容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-停止容器\"><a href=\"#12-停止容器\" class=\"headerlink\" title=\"12 停止容器\"></a>12 停止容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器id ----容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"13-删除容器\"><a href=\"#13-删除容器\" class=\"headerlink\" title=\"13 删除容器\"></a>13 删除容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm 容器id --容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-删除镜像\"><a href=\"#14-删除镜像\" class=\"headerlink\" title=\"14 删除镜像\"></a>14 删除镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi imagename:tag --imagename:tag imagename表示镜像名称 tag表示版本 这些信息可以从docker images进行获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"15-进入容器-运行sh命令：\"><a href=\"#15-进入容器-运行sh命令：\" class=\"headerlink\" title=\"15 进入容器 运行sh命令：\"></a>15 进入容器 运行sh命令：</h1><p>docker exec -it 容器id sh –容器id从docker ps -a获取</p>\n<h1 id=\"16-添加普通用户操作docker\"><a href=\"#16-添加普通用户操作docker\" class=\"headerlink\" title=\"16 添加普通用户操作docker\"></a>16 添加普通用户操作docker</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi etc/systemd/system/multi-user.target.wants/docker.service （操作服务）</span><br><span class=\"line\"></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -G jenkins  #表示jenkins用户组可以操作docker命令</span><br><span class=\"line\"></span><br><span class=\"line\">保存后</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload --重新加载服务</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart docker --重启服务</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>链接：<br><a href=\"/2018/05/08/）oracle-VM安装red-hat-liunx/\">oracle VM安装red hat liunx</a></p>\n<p><a href=\"/2018/05/08/）Red-Hat-升级-rpm软件、YUM软件（root用户）/\">升级RPM和YUM 包</a></p>\n<h1 id=\"1-安装docker（以下操作都是使用root用户）\"><a href=\"#1-安装docker（以下操作都是使用root用户）\" class=\"headerlink\" title=\"1 安装docker（以下操作都是使用root用户）\"></a>1 安装docker（以下操作都是使用root用户）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--安装驱动（red-hat为例,不同操作系统，驱动不同详细看官网教程）</span><br><span class=\"line\">&gt; yum install -y yum-utils device-mapper-persistent-data lvm2  </span><br><span class=\"line\"></span><br><span class=\"line\">--添加docker仓库</span><br><span class=\"line\">&gt; yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\">--清除缓存</span><br><span class=\"line\">&gt; yum clean all</span><br><span class=\"line\"></span><br><span class=\"line\">--重新更新缓存</span><br><span class=\"line\">&gt; yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\">--确保docker engine最新</span><br><span class=\"line\">&gt; yum-config-manager --enable docker-ce-edge</span><br><span class=\"line\"></span><br><span class=\"line\">--安装docker</span><br><span class=\"line\">&gt; yum install docker-ce</span><br><span class=\"line\"></span><br><span class=\"line\">开机启动</span><br><span class=\"line\">&gt; systemctl enable docker</span><br><span class=\"line\"></span><br><span class=\"line\">开启集群权限</span><br><span class=\"line\">&gt;vi /etc/systemd/system/multi-user.target.wants/docker.service </span><br><span class=\"line\">在</span><br><span class=\"line\">ExecStart=/usr/bin/dockerd </span><br><span class=\"line\">添加</span><br><span class=\"line\">--experimental=true </span><br><span class=\"line\"></span><br><span class=\"line\">重新加载配置</span><br><span class=\"line\">&gt;systemctl daemon-reload </span><br><span class=\"line\"></span><br><span class=\"line\"> --启动docker</span><br><span class=\"line\">&gt;systemctl start docker</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\" target=\"_blank\" rel=\"noopener\">docker官网</a></p>\n<p>docker 常用命令 参考<a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">docker 命令官网</a></p>\n<h1 id=\"2-查看docker-版本\"><a href=\"#2-查看docker-版本\" class=\"headerlink\" title=\"2 查看docker 版本\"></a>2 查看docker 版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version --目前最新版本是 17.12.1-ce</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-查看docker-信息\"><a href=\"#3-查看docker-信息\" class=\"headerlink\" title=\"3 查看docker 信息\"></a>3 查看docker 信息</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-运行镜像\"><a href=\"#4-运行镜像\" class=\"headerlink\" title=\"4 运行镜像\"></a>4 运行镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run hello-word --本地没有会找镜像库</span><br></pre></td></tr></table></figure>\n<p>关于run 一些参数详细参考<a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\">docker官网</a></p>\n<h1 id=\"5-下载镜像\"><a href=\"#5-下载镜像\" class=\"headerlink\" title=\"5 下载镜像\"></a>5 下载镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull alpine</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-制作java环境镜像：\"><a href=\"#6-制作java环境镜像：\" class=\"headerlink\" title=\"6 制作java环境镜像：\"></a>6 制作java环境镜像：</h1><p>使用DockerFile 进行编写 ,参考<a href=\"https://docs.docker.com/engine/reference/builder/#usage\" target=\"_blank\" rel=\"noopener\">dockerFile官网</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">MAINTAINER killko &lt;killko@qq.com&gt;</span><br><span class=\"line\">ENV TIME_ZONE Asiz/Shanghai</span><br><span class=\"line\">RUN echo &apos;@edge http://nl.alpinelinux.org/alpine/edge/main&apos; &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span><br><span class=\"line\">    echo &apos;@community http://nl.alpinelinux.org/alpine/edge/community&apos; &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span><br><span class=\"line\">    apk update &amp;&amp; \\</span><br><span class=\"line\">    apk upgrade &amp;&amp; \\</span><br><span class=\"line\">    apk add ca-certificates openjdk8-jre-base@community &amp;&amp; \\</span><br><span class=\"line\">    apk del ca-certificates &amp;&amp; \\</span><br><span class=\"line\">    apk add --no-cache tzdata &amp;&amp; \\</span><br><span class=\"line\">    echo &quot;$&#123;TIME_ZONE&#125;&quot; &gt; /etc/timezone &amp;&amp; \\</span><br><span class=\"line\">    ln -sf /usr/share/zoneinfo/$&#123;TIME_ZONE&#125; /etc/localtime &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /tmp/* /var/cache/apk/*</span><br><span class=\"line\">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure>\n<p>编写完成进行build<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;docker build  -t openjre:latest . --表示在当前目录进行制作镜像</span><br><span class=\"line\">&gt;docker images --查看镜像</span><br><span class=\"line\">&gt;docker run -it openjre sh --进行查看java是否安装成功</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-导入镜像\"><a href=\"#7-导入镜像\" class=\"headerlink\" title=\"7 导入镜像\"></a>7 导入镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load &lt; openjre.tar</span><br></pre></td></tr></table></figure>\n<h1 id=\"8-导出镜像：\"><a href=\"#8-导出镜像：\" class=\"headerlink\" title=\"8 导出镜像：\"></a>8 导出镜像：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save openjre:latest  openjre.tar</span><br></pre></td></tr></table></figure>\n<h1 id=\"9-查看镜像\"><a href=\"#9-查看镜像\" class=\"headerlink\" title=\"9 查看镜像\"></a>9 查看镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<h1 id=\"10-查看正在运行容器\"><a href=\"#10-查看正在运行容器\" class=\"headerlink\" title=\"10 查看正在运行容器\"></a>10 查看正在运行容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a --查看容器id 运行状态 映射端口</span><br></pre></td></tr></table></figure>\n<h1 id=\"11-查看容器日志\"><a href=\"#11-查看容器日志\" class=\"headerlink\" title=\"11 查看容器日志\"></a>11 查看容器日志</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs -f 容器id --容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-停止容器\"><a href=\"#12-停止容器\" class=\"headerlink\" title=\"12 停止容器\"></a>12 停止容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器id ----容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"13-删除容器\"><a href=\"#13-删除容器\" class=\"headerlink\" title=\"13 删除容器\"></a>13 删除容器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm 容器id --容器id从docker ps -a获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-删除镜像\"><a href=\"#14-删除镜像\" class=\"headerlink\" title=\"14 删除镜像\"></a>14 删除镜像</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi imagename:tag --imagename:tag imagename表示镜像名称 tag表示版本 这些信息可以从docker images进行获取</span><br></pre></td></tr></table></figure>\n<h1 id=\"15-进入容器-运行sh命令：\"><a href=\"#15-进入容器-运行sh命令：\" class=\"headerlink\" title=\"15 进入容器 运行sh命令：\"></a>15 进入容器 运行sh命令：</h1><p>docker exec -it 容器id sh –容器id从docker ps -a获取</p>\n<h1 id=\"16-添加普通用户操作docker\"><a href=\"#16-添加普通用户操作docker\" class=\"headerlink\" title=\"16 添加普通用户操作docker\"></a>16 添加普通用户操作docker</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi etc/systemd/system/multi-user.target.wants/docker.service （操作服务）</span><br><span class=\"line\"></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -G jenkins  #表示jenkins用户组可以操作docker命令</span><br><span class=\"line\"></span><br><span class=\"line\">保存后</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload --重新加载服务</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart docker --重启服务</span><br></pre></td></tr></table></figure>"},{"title":"那些提升开发人员工作效率的在线工具","author":"wen","date":"2018-05-08T06:20:00.000Z","_content":"作为一个Java开发人员，经常要和各种各样的工具打交道，除了我们常用的IDE工具以外，其实还有很多工具是我们在日常开发及学习过程中要经常使用到的。\n\nHollis偏爱使用在线工具，因为个人觉得这样比较方便。本文就总结了一下我常用的在线工具。欢迎纠正及补充。\n\n# Java源代码搜索 #\nhttp://grepcode.com/\n\nGrepcode是一个面向于Java开发人员的网站，在这里你可以通过Java的projects、classes等各种关键字在线查看它对应的源码，知道对应的project、classes等信息。 更方便的是，能提供非常多不同版本的源码在线查看、jar包、源码jar包、doc的下载。 同样，你也可以之间使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。\n\n# 开源代码及文档搜索 #\nhttps://searchcode.com/\n\nSearchCode 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。\n\n# 电子书搜索 #\nhttps://www.jiumodiary.com/\n\n鸠摩搜书是一个比较不错的电子书搜索网站。内容也比较全。\n\n# 网盘资源搜索  #\nhttp://pansou.com/\n\n这个大家都懂的，可以通过这个网站搜索百度网盘上面的各种资源。\n\n# 无版权图片搜索\nhttps://unsplash.com\n\n不知道有没有人和我一样，经常需要一些无版权的图片，比如公众号配图。\n\nunsplash是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜。\n\n# 在线UML制图\nhttps://www.processon.com/\n\nProcessOn是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计等。\n\n# Json在线验证及格式化\nhttps://www.json.cn/\n\n我用过很多json在线格式化的工具，经过实践，json.cn是比较不错的，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。\n\nDiff Check\nhttps://www.diffchecker.com/\n\n使用过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。diffchecker很不错。\n\n# MarkDown编辑器\nMaHua ：http://mahua.jser.me/\n\n马克飞象 ：https://maxiang.io/\n\nCmd ：https://www.zybuluo.com/mdeditor\n\n以上这几个我都用过，都还好吧，因为我一般都喜欢把自己写过的东西保存下来，所以就用了客户端的，我是用的是MacDown\n\n# Maven依赖查询\nhttp://mvnrepository.com/\n\nmvnrepository这个不用详细解释了，就是查询maven的gav信息一类的。因为我们公司有内部的Nexus仓库，所以很少用这个。\n\n# 在线代码运行\nhttps://tool.lu/coderunner/\n\ncoderunner可以在线运行php,c,c++,go,python,java,groovy等代码。当我们在外面，没有IDE又想执行个小程序的时候是个不错的选择。\n\n# 在线翻译\nGoogle翻译 ：https://translate.google.cn/\n\n百度翻译 ：http://fanyi.baidu.com/\n\n有道翻译 ：http://fanyi.youdao.com/\n\n说不出具体哪个好，其实都不太准确，还是需要自己根据语境进行翻译。\n\n不过忍不住吐槽一句国内的这几个翻译网站，既然是做翻译的，域名竟然用拼音，我也是醉了。\n\n# SQL自动生成Java代码\nhttp://www.autojcode.com/code/sql2class.jsp\n\nAutoJCode可以从sql的建表语句中生成一个DO类。\n\n# json生成java类\nhttp://www.bejson.com/json2javapojo\n\njson是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。\n\n# SQL美化/格式化/压缩\nhttps://tool.lu/sql/\n\nsql在线美化，格式化，压缩：\n\n# 编码转换\nhttp://tool.chinaz.com/tools/unicode.aspx\n\n站长工具的编码转换比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。\n\n# Corn表达式生成\nhttp://www.pdtools.net/tools/becron.jsp\n\nCron 一般用于配置定时任务的执行。\n\n# 正则验证\nhttp://tool.chinaz.com/regex\n\nJava开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。\n\n# 正则代码生成\nhttp://tool.chinaz.com/tools/regexgenerate\n\n站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。\n\n# 时间戳转换\nhttp://tool.chinaz.com/Tools/unixtime.aspx\n\n时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。\n\nJava中很多地方都会用到时间戳，也经常会使用这种转换工具。\n\n# 世界时间转换\nhttp://www.timebie.com/cn/easternbeijing.php\n\n世界各地时间转换，我之前做国际业务的时候，比较常用的是北京时间转纽约时间，北京时间转洛杉矶时间。 timebie提供了世界时间相互转换的功能。\n\n# 加密解密\nhttp://tool.chinaz.com/tools/textencrypt.aspx\n\n加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。\n\n# 查看网页源代码\nhttp://s.tool.chinaz.com/tools/pagecode.aspx\n\n这个工具，可以输入一个网站，直接查看网站的源码。具体有什么用，大家可以发挥各种想象。\n\n# 单位换算\nhttps://www.convertworld.com/zh-hans/\n\nconvertworld是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。\n\n# 在线调色板\nhttp://tool.chinaz.com/Tools/OnlineColor.aspx\n\n这个对前端开发比较有用，可以在线调色。\n\n# ASCII ART生成\nhttp://patorjk.com/software/taag/\n\n常用对照表\n\nASCII对照表 ： http://tool.oschina.net/commons?type=4\n\nHTTP状态码 ： http://tool.oschina.net/commons?type=5\n\nHTTP Content-type ： http://tool.oschina.net/commons\n\nTCP/UDP常见端口参考 ：http://tool.oschina.net/commons?type=7\n\nHTML转义字符 ： http://tool.oschina.net/commons?type=2\n\nRGB颜色参考 ： http://tool.oschina.net/commons?type=3\n\n网页字体参考 ： http://tool.oschina.net/commons?type=8","source":"_posts/那些提升开发人员工作效率的在线工具.md","raw":"title: 那些提升开发人员工作效率的在线工具\nauthor: wen\ntags:\n  - 工作\n  - work\n  - 工具\n  - tools\ncategories:\n  - work\ndate: 2018-05-08 14:20:00\n---\n作为一个Java开发人员，经常要和各种各样的工具打交道，除了我们常用的IDE工具以外，其实还有很多工具是我们在日常开发及学习过程中要经常使用到的。\n\nHollis偏爱使用在线工具，因为个人觉得这样比较方便。本文就总结了一下我常用的在线工具。欢迎纠正及补充。\n\n# Java源代码搜索 #\nhttp://grepcode.com/\n\nGrepcode是一个面向于Java开发人员的网站，在这里你可以通过Java的projects、classes等各种关键字在线查看它对应的源码，知道对应的project、classes等信息。 更方便的是，能提供非常多不同版本的源码在线查看、jar包、源码jar包、doc的下载。 同样，你也可以之间使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。\n\n# 开源代码及文档搜索 #\nhttps://searchcode.com/\n\nSearchCode 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。\n\n# 电子书搜索 #\nhttps://www.jiumodiary.com/\n\n鸠摩搜书是一个比较不错的电子书搜索网站。内容也比较全。\n\n# 网盘资源搜索  #\nhttp://pansou.com/\n\n这个大家都懂的，可以通过这个网站搜索百度网盘上面的各种资源。\n\n# 无版权图片搜索\nhttps://unsplash.com\n\n不知道有没有人和我一样，经常需要一些无版权的图片，比如公众号配图。\n\nunsplash是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜。\n\n# 在线UML制图\nhttps://www.processon.com/\n\nProcessOn是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计等。\n\n# Json在线验证及格式化\nhttps://www.json.cn/\n\n我用过很多json在线格式化的工具，经过实践，json.cn是比较不错的，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。\n\nDiff Check\nhttps://www.diffchecker.com/\n\n使用过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。diffchecker很不错。\n\n# MarkDown编辑器\nMaHua ：http://mahua.jser.me/\n\n马克飞象 ：https://maxiang.io/\n\nCmd ：https://www.zybuluo.com/mdeditor\n\n以上这几个我都用过，都还好吧，因为我一般都喜欢把自己写过的东西保存下来，所以就用了客户端的，我是用的是MacDown\n\n# Maven依赖查询\nhttp://mvnrepository.com/\n\nmvnrepository这个不用详细解释了，就是查询maven的gav信息一类的。因为我们公司有内部的Nexus仓库，所以很少用这个。\n\n# 在线代码运行\nhttps://tool.lu/coderunner/\n\ncoderunner可以在线运行php,c,c++,go,python,java,groovy等代码。当我们在外面，没有IDE又想执行个小程序的时候是个不错的选择。\n\n# 在线翻译\nGoogle翻译 ：https://translate.google.cn/\n\n百度翻译 ：http://fanyi.baidu.com/\n\n有道翻译 ：http://fanyi.youdao.com/\n\n说不出具体哪个好，其实都不太准确，还是需要自己根据语境进行翻译。\n\n不过忍不住吐槽一句国内的这几个翻译网站，既然是做翻译的，域名竟然用拼音，我也是醉了。\n\n# SQL自动生成Java代码\nhttp://www.autojcode.com/code/sql2class.jsp\n\nAutoJCode可以从sql的建表语句中生成一个DO类。\n\n# json生成java类\nhttp://www.bejson.com/json2javapojo\n\njson是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。\n\n# SQL美化/格式化/压缩\nhttps://tool.lu/sql/\n\nsql在线美化，格式化，压缩：\n\n# 编码转换\nhttp://tool.chinaz.com/tools/unicode.aspx\n\n站长工具的编码转换比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。\n\n# Corn表达式生成\nhttp://www.pdtools.net/tools/becron.jsp\n\nCron 一般用于配置定时任务的执行。\n\n# 正则验证\nhttp://tool.chinaz.com/regex\n\nJava开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。\n\n# 正则代码生成\nhttp://tool.chinaz.com/tools/regexgenerate\n\n站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。\n\n# 时间戳转换\nhttp://tool.chinaz.com/Tools/unixtime.aspx\n\n时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。\n\nJava中很多地方都会用到时间戳，也经常会使用这种转换工具。\n\n# 世界时间转换\nhttp://www.timebie.com/cn/easternbeijing.php\n\n世界各地时间转换，我之前做国际业务的时候，比较常用的是北京时间转纽约时间，北京时间转洛杉矶时间。 timebie提供了世界时间相互转换的功能。\n\n# 加密解密\nhttp://tool.chinaz.com/tools/textencrypt.aspx\n\n加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。\n\n# 查看网页源代码\nhttp://s.tool.chinaz.com/tools/pagecode.aspx\n\n这个工具，可以输入一个网站，直接查看网站的源码。具体有什么用，大家可以发挥各种想象。\n\n# 单位换算\nhttps://www.convertworld.com/zh-hans/\n\nconvertworld是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。\n\n# 在线调色板\nhttp://tool.chinaz.com/Tools/OnlineColor.aspx\n\n这个对前端开发比较有用，可以在线调色。\n\n# ASCII ART生成\nhttp://patorjk.com/software/taag/\n\n常用对照表\n\nASCII对照表 ： http://tool.oschina.net/commons?type=4\n\nHTTP状态码 ： http://tool.oschina.net/commons?type=5\n\nHTTP Content-type ： http://tool.oschina.net/commons\n\nTCP/UDP常见端口参考 ：http://tool.oschina.net/commons?type=7\n\nHTML转义字符 ： http://tool.oschina.net/commons?type=2\n\nRGB颜色参考 ： http://tool.oschina.net/commons?type=3\n\n网页字体参考 ： http://tool.oschina.net/commons?type=8","slug":"那些提升开发人员工作效率的在线工具","published":1,"updated":"2019-05-05T02:41:23.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdzce39y003on6zqt13e88kw","content":"<p>作为一个Java开发人员，经常要和各种各样的工具打交道，除了我们常用的IDE工具以外，其实还有很多工具是我们在日常开发及学习过程中要经常使用到的。</p>\n<p>Hollis偏爱使用在线工具，因为个人觉得这样比较方便。本文就总结了一下我常用的在线工具。欢迎纠正及补充。</p>\n<h1 id=\"Java源代码搜索\"><a href=\"#Java源代码搜索\" class=\"headerlink\" title=\"Java源代码搜索\"></a>Java源代码搜索</h1><p><a href=\"http://grepcode.com/\" target=\"_blank\" rel=\"noopener\">http://grepcode.com/</a></p>\n<p>Grepcode是一个面向于Java开发人员的网站，在这里你可以通过Java的projects、classes等各种关键字在线查看它对应的源码，知道对应的project、classes等信息。 更方便的是，能提供非常多不同版本的源码在线查看、jar包、源码jar包、doc的下载。 同样，你也可以之间使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。</p>\n<h1 id=\"开源代码及文档搜索\"><a href=\"#开源代码及文档搜索\" class=\"headerlink\" title=\"开源代码及文档搜索\"></a>开源代码及文档搜索</h1><p><a href=\"https://searchcode.com/\" target=\"_blank\" rel=\"noopener\">https://searchcode.com/</a></p>\n<p>SearchCode 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>\n<h1 id=\"电子书搜索\"><a href=\"#电子书搜索\" class=\"headerlink\" title=\"电子书搜索\"></a>电子书搜索</h1><p><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">https://www.jiumodiary.com/</a></p>\n<p>鸠摩搜书是一个比较不错的电子书搜索网站。内容也比较全。</p>\n<h1 id=\"网盘资源搜索\"><a href=\"#网盘资源搜索\" class=\"headerlink\" title=\"网盘资源搜索\"></a>网盘资源搜索</h1><p><a href=\"http://pansou.com/\" target=\"_blank\" rel=\"noopener\">http://pansou.com/</a></p>\n<p>这个大家都懂的，可以通过这个网站搜索百度网盘上面的各种资源。</p>\n<h1 id=\"无版权图片搜索\"><a href=\"#无版权图片搜索\" class=\"headerlink\" title=\"无版权图片搜索\"></a>无版权图片搜索</h1><p><a href=\"https://unsplash.com\" target=\"_blank\" rel=\"noopener\">https://unsplash.com</a></p>\n<p>不知道有没有人和我一样，经常需要一些无版权的图片，比如公众号配图。</p>\n<p>unsplash是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜。</p>\n<h1 id=\"在线UML制图\"><a href=\"#在线UML制图\" class=\"headerlink\" title=\"在线UML制图\"></a>在线UML制图</h1><p><a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">https://www.processon.com/</a></p>\n<p>ProcessOn是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计等。</p>\n<h1 id=\"Json在线验证及格式化\"><a href=\"#Json在线验证及格式化\" class=\"headerlink\" title=\"Json在线验证及格式化\"></a>Json在线验证及格式化</h1><p><a href=\"https://www.json.cn/\" target=\"_blank\" rel=\"noopener\">https://www.json.cn/</a></p>\n<p>我用过很多json在线格式化的工具，经过实践，json.cn是比较不错的，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。</p>\n<p>Diff Check<br><a href=\"https://www.diffchecker.com/\" target=\"_blank\" rel=\"noopener\">https://www.diffchecker.com/</a></p>\n<p>使用过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。diffchecker很不错。</p>\n<h1 id=\"MarkDown编辑器\"><a href=\"#MarkDown编辑器\" class=\"headerlink\" title=\"MarkDown编辑器\"></a>MarkDown编辑器</h1><p>MaHua ：<a href=\"http://mahua.jser.me/\" target=\"_blank\" rel=\"noopener\">http://mahua.jser.me/</a></p>\n<p>马克飞象 ：<a href=\"https://maxiang.io/\" target=\"_blank\" rel=\"noopener\">https://maxiang.io/</a></p>\n<p>Cmd ：<a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">https://www.zybuluo.com/mdeditor</a></p>\n<p>以上这几个我都用过，都还好吧，因为我一般都喜欢把自己写过的东西保存下来，所以就用了客户端的，我是用的是MacDown</p>\n<h1 id=\"Maven依赖查询\"><a href=\"#Maven依赖查询\" class=\"headerlink\" title=\"Maven依赖查询\"></a>Maven依赖查询</h1><p><a href=\"http://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">http://mvnrepository.com/</a></p>\n<p>mvnrepository这个不用详细解释了，就是查询maven的gav信息一类的。因为我们公司有内部的Nexus仓库，所以很少用这个。</p>\n<h1 id=\"在线代码运行\"><a href=\"#在线代码运行\" class=\"headerlink\" title=\"在线代码运行\"></a>在线代码运行</h1><p><a href=\"https://tool.lu/coderunner/\" target=\"_blank\" rel=\"noopener\">https://tool.lu/coderunner/</a></p>\n<p>coderunner可以在线运行php,c,c++,go,python,java,groovy等代码。当我们在外面，没有IDE又想执行个小程序的时候是个不错的选择。</p>\n<h1 id=\"在线翻译\"><a href=\"#在线翻译\" class=\"headerlink\" title=\"在线翻译\"></a>在线翻译</h1><p>Google翻译 ：<a href=\"https://translate.google.cn/\" target=\"_blank\" rel=\"noopener\">https://translate.google.cn/</a></p>\n<p>百度翻译 ：<a href=\"http://fanyi.baidu.com/\" target=\"_blank\" rel=\"noopener\">http://fanyi.baidu.com/</a></p>\n<p>有道翻译 ：<a href=\"http://fanyi.youdao.com/\" target=\"_blank\" rel=\"noopener\">http://fanyi.youdao.com/</a></p>\n<p>说不出具体哪个好，其实都不太准确，还是需要自己根据语境进行翻译。</p>\n<p>不过忍不住吐槽一句国内的这几个翻译网站，既然是做翻译的，域名竟然用拼音，我也是醉了。</p>\n<h1 id=\"SQL自动生成Java代码\"><a href=\"#SQL自动生成Java代码\" class=\"headerlink\" title=\"SQL自动生成Java代码\"></a>SQL自动生成Java代码</h1><p><a href=\"http://www.autojcode.com/code/sql2class.jsp\" target=\"_blank\" rel=\"noopener\">http://www.autojcode.com/code/sql2class.jsp</a></p>\n<p>AutoJCode可以从sql的建表语句中生成一个DO类。</p>\n<h1 id=\"json生成java类\"><a href=\"#json生成java类\" class=\"headerlink\" title=\"json生成java类\"></a>json生成java类</h1><p><a href=\"http://www.bejson.com/json2javapojo\" target=\"_blank\" rel=\"noopener\">http://www.bejson.com/json2javapojo</a></p>\n<p>json是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。</p>\n<h1 id=\"SQL美化-格式化-压缩\"><a href=\"#SQL美化-格式化-压缩\" class=\"headerlink\" title=\"SQL美化/格式化/压缩\"></a>SQL美化/格式化/压缩</h1><p><a href=\"https://tool.lu/sql/\" target=\"_blank\" rel=\"noopener\">https://tool.lu/sql/</a></p>\n<p>sql在线美化，格式化，压缩：</p>\n<h1 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h1><p><a href=\"http://tool.chinaz.com/tools/unicode.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/unicode.aspx</a></p>\n<p>站长工具的编码转换比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。</p>\n<h1 id=\"Corn表达式生成\"><a href=\"#Corn表达式生成\" class=\"headerlink\" title=\"Corn表达式生成\"></a>Corn表达式生成</h1><p><a href=\"http://www.pdtools.net/tools/becron.jsp\" target=\"_blank\" rel=\"noopener\">http://www.pdtools.net/tools/becron.jsp</a></p>\n<p>Cron 一般用于配置定时任务的执行。</p>\n<h1 id=\"正则验证\"><a href=\"#正则验证\" class=\"headerlink\" title=\"正则验证\"></a>正则验证</h1><p><a href=\"http://tool.chinaz.com/regex\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/regex</a></p>\n<p>Java开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。</p>\n<h1 id=\"正则代码生成\"><a href=\"#正则代码生成\" class=\"headerlink\" title=\"正则代码生成\"></a>正则代码生成</h1><p><a href=\"http://tool.chinaz.com/tools/regexgenerate\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/regexgenerate</a></p>\n<p>站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。</p>\n<h1 id=\"时间戳转换\"><a href=\"#时间戳转换\" class=\"headerlink\" title=\"时间戳转换\"></a>时间戳转换</h1><p><a href=\"http://tool.chinaz.com/Tools/unixtime.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/Tools/unixtime.aspx</a></p>\n<p>时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。</p>\n<p>Java中很多地方都会用到时间戳，也经常会使用这种转换工具。</p>\n<h1 id=\"世界时间转换\"><a href=\"#世界时间转换\" class=\"headerlink\" title=\"世界时间转换\"></a>世界时间转换</h1><p><a href=\"http://www.timebie.com/cn/easternbeijing.php\" target=\"_blank\" rel=\"noopener\">http://www.timebie.com/cn/easternbeijing.php</a></p>\n<p>世界各地时间转换，我之前做国际业务的时候，比较常用的是北京时间转纽约时间，北京时间转洛杉矶时间。 timebie提供了世界时间相互转换的功能。</p>\n<h1 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h1><p><a href=\"http://tool.chinaz.com/tools/textencrypt.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/textencrypt.aspx</a></p>\n<p>加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。</p>\n<h1 id=\"查看网页源代码\"><a href=\"#查看网页源代码\" class=\"headerlink\" title=\"查看网页源代码\"></a>查看网页源代码</h1><p><a href=\"http://s.tool.chinaz.com/tools/pagecode.aspx\" target=\"_blank\" rel=\"noopener\">http://s.tool.chinaz.com/tools/pagecode.aspx</a></p>\n<p>这个工具，可以输入一个网站，直接查看网站的源码。具体有什么用，大家可以发挥各种想象。</p>\n<h1 id=\"单位换算\"><a href=\"#单位换算\" class=\"headerlink\" title=\"单位换算\"></a>单位换算</h1><p><a href=\"https://www.convertworld.com/zh-hans/\" target=\"_blank\" rel=\"noopener\">https://www.convertworld.com/zh-hans/</a></p>\n<p>convertworld是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。</p>\n<h1 id=\"在线调色板\"><a href=\"#在线调色板\" class=\"headerlink\" title=\"在线调色板\"></a>在线调色板</h1><p><a href=\"http://tool.chinaz.com/Tools/OnlineColor.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/Tools/OnlineColor.aspx</a></p>\n<p>这个对前端开发比较有用，可以在线调色。</p>\n<h1 id=\"ASCII-ART生成\"><a href=\"#ASCII-ART生成\" class=\"headerlink\" title=\"ASCII ART生成\"></a>ASCII ART生成</h1><p><a href=\"http://patorjk.com/software/taag/\" target=\"_blank\" rel=\"noopener\">http://patorjk.com/software/taag/</a></p>\n<p>常用对照表</p>\n<p>ASCII对照表 ： <a href=\"http://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=4</a></p>\n<p>HTTP状态码 ： <a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=5</a></p>\n<p>HTTP Content-type ： <a href=\"http://tool.oschina.net/commons\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons</a></p>\n<p>TCP/UDP常见端口参考 ：<a href=\"http://tool.oschina.net/commons?type=7\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=7</a></p>\n<p>HTML转义字符 ： <a href=\"http://tool.oschina.net/commons?type=2\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=2</a></p>\n<p>RGB颜色参考 ： <a href=\"http://tool.oschina.net/commons?type=3\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=3</a></p>\n<p>网页字体参考 ： <a href=\"http://tool.oschina.net/commons?type=8\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为一个Java开发人员，经常要和各种各样的工具打交道，除了我们常用的IDE工具以外，其实还有很多工具是我们在日常开发及学习过程中要经常使用到的。</p>\n<p>Hollis偏爱使用在线工具，因为个人觉得这样比较方便。本文就总结了一下我常用的在线工具。欢迎纠正及补充。</p>\n<h1 id=\"Java源代码搜索\"><a href=\"#Java源代码搜索\" class=\"headerlink\" title=\"Java源代码搜索\"></a>Java源代码搜索</h1><p><a href=\"http://grepcode.com/\" target=\"_blank\" rel=\"noopener\">http://grepcode.com/</a></p>\n<p>Grepcode是一个面向于Java开发人员的网站，在这里你可以通过Java的projects、classes等各种关键字在线查看它对应的源码，知道对应的project、classes等信息。 更方便的是，能提供非常多不同版本的源码在线查看、jar包、源码jar包、doc的下载。 同样，你也可以之间使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。</p>\n<h1 id=\"开源代码及文档搜索\"><a href=\"#开源代码及文档搜索\" class=\"headerlink\" title=\"开源代码及文档搜索\"></a>开源代码及文档搜索</h1><p><a href=\"https://searchcode.com/\" target=\"_blank\" rel=\"noopener\">https://searchcode.com/</a></p>\n<p>SearchCode 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>\n<h1 id=\"电子书搜索\"><a href=\"#电子书搜索\" class=\"headerlink\" title=\"电子书搜索\"></a>电子书搜索</h1><p><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">https://www.jiumodiary.com/</a></p>\n<p>鸠摩搜书是一个比较不错的电子书搜索网站。内容也比较全。</p>\n<h1 id=\"网盘资源搜索\"><a href=\"#网盘资源搜索\" class=\"headerlink\" title=\"网盘资源搜索\"></a>网盘资源搜索</h1><p><a href=\"http://pansou.com/\" target=\"_blank\" rel=\"noopener\">http://pansou.com/</a></p>\n<p>这个大家都懂的，可以通过这个网站搜索百度网盘上面的各种资源。</p>\n<h1 id=\"无版权图片搜索\"><a href=\"#无版权图片搜索\" class=\"headerlink\" title=\"无版权图片搜索\"></a>无版权图片搜索</h1><p><a href=\"https://unsplash.com\" target=\"_blank\" rel=\"noopener\">https://unsplash.com</a></p>\n<p>不知道有没有人和我一样，经常需要一些无版权的图片，比如公众号配图。</p>\n<p>unsplash是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜。</p>\n<h1 id=\"在线UML制图\"><a href=\"#在线UML制图\" class=\"headerlink\" title=\"在线UML制图\"></a>在线UML制图</h1><p><a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">https://www.processon.com/</a></p>\n<p>ProcessOn是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计等。</p>\n<h1 id=\"Json在线验证及格式化\"><a href=\"#Json在线验证及格式化\" class=\"headerlink\" title=\"Json在线验证及格式化\"></a>Json在线验证及格式化</h1><p><a href=\"https://www.json.cn/\" target=\"_blank\" rel=\"noopener\">https://www.json.cn/</a></p>\n<p>我用过很多json在线格式化的工具，经过实践，json.cn是比较不错的，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。</p>\n<p>Diff Check<br><a href=\"https://www.diffchecker.com/\" target=\"_blank\" rel=\"noopener\">https://www.diffchecker.com/</a></p>\n<p>使用过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。diffchecker很不错。</p>\n<h1 id=\"MarkDown编辑器\"><a href=\"#MarkDown编辑器\" class=\"headerlink\" title=\"MarkDown编辑器\"></a>MarkDown编辑器</h1><p>MaHua ：<a href=\"http://mahua.jser.me/\" target=\"_blank\" rel=\"noopener\">http://mahua.jser.me/</a></p>\n<p>马克飞象 ：<a href=\"https://maxiang.io/\" target=\"_blank\" rel=\"noopener\">https://maxiang.io/</a></p>\n<p>Cmd ：<a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">https://www.zybuluo.com/mdeditor</a></p>\n<p>以上这几个我都用过，都还好吧，因为我一般都喜欢把自己写过的东西保存下来，所以就用了客户端的，我是用的是MacDown</p>\n<h1 id=\"Maven依赖查询\"><a href=\"#Maven依赖查询\" class=\"headerlink\" title=\"Maven依赖查询\"></a>Maven依赖查询</h1><p><a href=\"http://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">http://mvnrepository.com/</a></p>\n<p>mvnrepository这个不用详细解释了，就是查询maven的gav信息一类的。因为我们公司有内部的Nexus仓库，所以很少用这个。</p>\n<h1 id=\"在线代码运行\"><a href=\"#在线代码运行\" class=\"headerlink\" title=\"在线代码运行\"></a>在线代码运行</h1><p><a href=\"https://tool.lu/coderunner/\" target=\"_blank\" rel=\"noopener\">https://tool.lu/coderunner/</a></p>\n<p>coderunner可以在线运行php,c,c++,go,python,java,groovy等代码。当我们在外面，没有IDE又想执行个小程序的时候是个不错的选择。</p>\n<h1 id=\"在线翻译\"><a href=\"#在线翻译\" class=\"headerlink\" title=\"在线翻译\"></a>在线翻译</h1><p>Google翻译 ：<a href=\"https://translate.google.cn/\" target=\"_blank\" rel=\"noopener\">https://translate.google.cn/</a></p>\n<p>百度翻译 ：<a href=\"http://fanyi.baidu.com/\" target=\"_blank\" rel=\"noopener\">http://fanyi.baidu.com/</a></p>\n<p>有道翻译 ：<a href=\"http://fanyi.youdao.com/\" target=\"_blank\" rel=\"noopener\">http://fanyi.youdao.com/</a></p>\n<p>说不出具体哪个好，其实都不太准确，还是需要自己根据语境进行翻译。</p>\n<p>不过忍不住吐槽一句国内的这几个翻译网站，既然是做翻译的，域名竟然用拼音，我也是醉了。</p>\n<h1 id=\"SQL自动生成Java代码\"><a href=\"#SQL自动生成Java代码\" class=\"headerlink\" title=\"SQL自动生成Java代码\"></a>SQL自动生成Java代码</h1><p><a href=\"http://www.autojcode.com/code/sql2class.jsp\" target=\"_blank\" rel=\"noopener\">http://www.autojcode.com/code/sql2class.jsp</a></p>\n<p>AutoJCode可以从sql的建表语句中生成一个DO类。</p>\n<h1 id=\"json生成java类\"><a href=\"#json生成java类\" class=\"headerlink\" title=\"json生成java类\"></a>json生成java类</h1><p><a href=\"http://www.bejson.com/json2javapojo\" target=\"_blank\" rel=\"noopener\">http://www.bejson.com/json2javapojo</a></p>\n<p>json是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。</p>\n<h1 id=\"SQL美化-格式化-压缩\"><a href=\"#SQL美化-格式化-压缩\" class=\"headerlink\" title=\"SQL美化/格式化/压缩\"></a>SQL美化/格式化/压缩</h1><p><a href=\"https://tool.lu/sql/\" target=\"_blank\" rel=\"noopener\">https://tool.lu/sql/</a></p>\n<p>sql在线美化，格式化，压缩：</p>\n<h1 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h1><p><a href=\"http://tool.chinaz.com/tools/unicode.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/unicode.aspx</a></p>\n<p>站长工具的编码转换比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。</p>\n<h1 id=\"Corn表达式生成\"><a href=\"#Corn表达式生成\" class=\"headerlink\" title=\"Corn表达式生成\"></a>Corn表达式生成</h1><p><a href=\"http://www.pdtools.net/tools/becron.jsp\" target=\"_blank\" rel=\"noopener\">http://www.pdtools.net/tools/becron.jsp</a></p>\n<p>Cron 一般用于配置定时任务的执行。</p>\n<h1 id=\"正则验证\"><a href=\"#正则验证\" class=\"headerlink\" title=\"正则验证\"></a>正则验证</h1><p><a href=\"http://tool.chinaz.com/regex\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/regex</a></p>\n<p>Java开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。</p>\n<h1 id=\"正则代码生成\"><a href=\"#正则代码生成\" class=\"headerlink\" title=\"正则代码生成\"></a>正则代码生成</h1><p><a href=\"http://tool.chinaz.com/tools/regexgenerate\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/regexgenerate</a></p>\n<p>站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。</p>\n<h1 id=\"时间戳转换\"><a href=\"#时间戳转换\" class=\"headerlink\" title=\"时间戳转换\"></a>时间戳转换</h1><p><a href=\"http://tool.chinaz.com/Tools/unixtime.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/Tools/unixtime.aspx</a></p>\n<p>时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。</p>\n<p>Java中很多地方都会用到时间戳，也经常会使用这种转换工具。</p>\n<h1 id=\"世界时间转换\"><a href=\"#世界时间转换\" class=\"headerlink\" title=\"世界时间转换\"></a>世界时间转换</h1><p><a href=\"http://www.timebie.com/cn/easternbeijing.php\" target=\"_blank\" rel=\"noopener\">http://www.timebie.com/cn/easternbeijing.php</a></p>\n<p>世界各地时间转换，我之前做国际业务的时候，比较常用的是北京时间转纽约时间，北京时间转洛杉矶时间。 timebie提供了世界时间相互转换的功能。</p>\n<h1 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h1><p><a href=\"http://tool.chinaz.com/tools/textencrypt.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/tools/textencrypt.aspx</a></p>\n<p>加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。</p>\n<h1 id=\"查看网页源代码\"><a href=\"#查看网页源代码\" class=\"headerlink\" title=\"查看网页源代码\"></a>查看网页源代码</h1><p><a href=\"http://s.tool.chinaz.com/tools/pagecode.aspx\" target=\"_blank\" rel=\"noopener\">http://s.tool.chinaz.com/tools/pagecode.aspx</a></p>\n<p>这个工具，可以输入一个网站，直接查看网站的源码。具体有什么用，大家可以发挥各种想象。</p>\n<h1 id=\"单位换算\"><a href=\"#单位换算\" class=\"headerlink\" title=\"单位换算\"></a>单位换算</h1><p><a href=\"https://www.convertworld.com/zh-hans/\" target=\"_blank\" rel=\"noopener\">https://www.convertworld.com/zh-hans/</a></p>\n<p>convertworld是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。</p>\n<h1 id=\"在线调色板\"><a href=\"#在线调色板\" class=\"headerlink\" title=\"在线调色板\"></a>在线调色板</h1><p><a href=\"http://tool.chinaz.com/Tools/OnlineColor.aspx\" target=\"_blank\" rel=\"noopener\">http://tool.chinaz.com/Tools/OnlineColor.aspx</a></p>\n<p>这个对前端开发比较有用，可以在线调色。</p>\n<h1 id=\"ASCII-ART生成\"><a href=\"#ASCII-ART生成\" class=\"headerlink\" title=\"ASCII ART生成\"></a>ASCII ART生成</h1><p><a href=\"http://patorjk.com/software/taag/\" target=\"_blank\" rel=\"noopener\">http://patorjk.com/software/taag/</a></p>\n<p>常用对照表</p>\n<p>ASCII对照表 ： <a href=\"http://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=4</a></p>\n<p>HTTP状态码 ： <a href=\"http://tool.oschina.net/commons?type=5\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=5</a></p>\n<p>HTTP Content-type ： <a href=\"http://tool.oschina.net/commons\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons</a></p>\n<p>TCP/UDP常见端口参考 ：<a href=\"http://tool.oschina.net/commons?type=7\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=7</a></p>\n<p>HTML转义字符 ： <a href=\"http://tool.oschina.net/commons?type=2\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=2</a></p>\n<p>RGB颜色参考 ： <a href=\"http://tool.oschina.net/commons?type=3\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=3</a></p>\n<p>网页字体参考 ： <a href=\"http://tool.oschina.net/commons?type=8\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/commons?type=8</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/gtmetix/1.jpg","slug":"1.jpg","post":"ckdzce385001an6zq6knm8nbx","modified":0,"renderable":0},{"_id":"source/_posts/hexo git/1.jpeg","slug":"1.jpeg","post":"ckdzce38o0021n6zqhrfhy0wm","modified":0,"renderable":0},{"_id":"source/_posts/hexo git/2.png","slug":"2.png","post":"ckdzce38o0021n6zqhrfhy0wm","modified":0,"renderable":0},{"_id":"source/_posts/hexo git/3.png","slug":"3.png","post":"ckdzce38o0021n6zqhrfhy0wm","modified":0,"renderable":0},{"_id":"source/_posts/hexo git/4.png","slug":"4.png","post":"ckdzce38o0021n6zqhrfhy0wm","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckdzce36h0003n6zqdq2y4uhw","category_id":"ckdzce36x0006n6zqxo1k1xxs","_id":"ckdzce37g000hn6zqsccovtyl"},{"post_id":"ckdzce37c000fn6zqjtf91vpd","category_id":"ckdzce37b000dn6zqu1jhbxv4","_id":"ckdzce37j000mn6zqq87z07u0"},{"post_id":"ckdzce36u0005n6zqr530lod5","category_id":"ckdzce37b000dn6zqu1jhbxv4","_id":"ckdzce37l000qn6zqdnejqnpj"},{"post_id":"ckdzce37k000pn6zqbcufi4l9","category_id":"ckdzce37g000in6zqzghrdc7r","_id":"ckdzce37r000zn6zqz2xhd0q3"},{"post_id":"ckdzce37q000yn6zq1c404kjh","category_id":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce3830017n6zq0xt939uv"},{"post_id":"ckdzce37e000gn6zqkrh0bdbb","category_id":"ckdzce37z0011n6zqmwt5w7p3","_id":"ckdzce388001cn6zq9oh4vnzn"},{"post_id":"ckdzce3820016n6zqquu7joal","category_id":"ckdzce37b000dn6zqu1jhbxv4","_id":"ckdzce38b001gn6zqvvopxuf6"},{"post_id":"ckdzce387001bn6zq3ej74k98","category_id":"ckdzce37z0011n6zqmwt5w7p3","_id":"ckdzce38f001ln6zqzi50b2xu"},{"post_id":"ckdzce389001fn6zq0e272fq5","category_id":"ckdzce37z0011n6zqmwt5w7p3","_id":"ckdzce38h001nn6zqbxrn0zlj"},{"post_id":"ckdzce3710009n6zq6foszl52","category_id":"ckdzce37g000in6zqzghrdc7r","_id":"ckdzce38i001pn6zqkj6bovml"},{"post_id":"ckdzce3710009n6zq6foszl52","category_id":"ckdzce388001dn6zq1n3avgp4","_id":"ckdzce38l001un6zq9c66xgi7"},{"post_id":"ckdzce37j000ln6zq0rqv6fw5","category_id":"ckdzce38e001in6zqnsjn3dra","_id":"ckdzce38n001xn6zqovyal4qu"},{"post_id":"ckdzce38h001on6zqt6h4y34c","category_id":"ckdzce37z0011n6zqmwt5w7p3","_id":"ckdzce38p0022n6zq9jnz4q6n"},{"post_id":"ckdzce37m000sn6zqs5z8o83w","category_id":"ckdzce38j001qn6zqukl108v8","_id":"ckdzce38s0025n6zqzth1nwvd"},{"post_id":"ckdzce376000bn6zquf8ef1vk","category_id":"ckdzce37k000nn6zqoerhvpoa","_id":"ckdzce394002cn6zqkn0c2mwo"},{"post_id":"ckdzce376000bn6zquf8ef1vk","category_id":"ckdzce38n001yn6zqgf1loxhf","_id":"ckdzce398002gn6zqhs0jis3o"},{"post_id":"ckdzce379000cn6zq491ohu9j","category_id":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce39a002in6zqdc1p6xhw"},{"post_id":"ckdzce379000cn6zq491ohu9j","category_id":"ckdzce38s0026n6zq7w1otkib","_id":"ckdzce39d002mn6zqpljql940"},{"post_id":"ckdzce395002fn6zq8cidseyw","category_id":"ckdzce38j001qn6zqukl108v8","_id":"ckdzce39f002pn6zq6uky08ln"},{"post_id":"ckdzce37s0010n6zqjc34y1nl","category_id":"ckdzce395002en6zq5qf7s0st","_id":"ckdzce39i002un6zq3ytq6fnj"},{"post_id":"ckdzce39a002kn6zqxpdhk0wk","category_id":"ckdzce36x0006n6zqxo1k1xxs","_id":"ckdzce39j002wn6zq9hfrrdtz"},{"post_id":"ckdzce3800014n6zqytisf5mw","category_id":"ckdzce395002en6zq5qf7s0st","_id":"ckdzce39l0030n6zq1b8m6l05"},{"post_id":"ckdzce39i002vn6zqk5xoad9n","category_id":"ckdzce37z0011n6zqmwt5w7p3","_id":"ckdzce39p0035n6zq3jsawdhu"},{"post_id":"ckdzce385001an6zq6knm8nbx","category_id":"ckdzce39g002rn6zqpavzizk3","_id":"ckdzce39r003an6zqi4utru9q"},{"post_id":"ckdzce37h000kn6zqu0tbx4d0","category_id":"ckdzce3840018n6zqkgwhc2lx","_id":"ckdzce39t003dn6zq0natvgbh"},{"post_id":"ckdzce37h000kn6zqu0tbx4d0","category_id":"ckdzce39l002zn6zqd0swf99p","_id":"ckdzce39w003in6zq5fdfpego"},{"post_id":"ckdzce38f001kn6zqjcas89wo","category_id":"ckdzce39p0037n6zqpsuy1syz","_id":"ckdzce39x003ln6zqmcgjggxs"},{"post_id":"ckdzce38k001tn6zqz3ttmd0r","category_id":"ckdzce37k000nn6zqoerhvpoa","_id":"ckdzce3a0003sn6zquxiahm0w"},{"post_id":"ckdzce38k001tn6zqz3ttmd0r","category_id":"ckdzce39u003fn6zqg5yrwejw","_id":"ckdzce3a3003wn6zqtczu17sm"},{"post_id":"ckdzce38m001wn6zqr0mk8pf0","category_id":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce3a4003zn6zqep7pvnbg"},{"post_id":"ckdzce38m001wn6zqr0mk8pf0","category_id":"ckdzce39z003pn6zqopnnw70a","_id":"ckdzce3a50042n6zqld82xsz8"},{"post_id":"ckdzce38o0021n6zqhrfhy0wm","category_id":"ckdzce3a1003un6zq5wwgx4kc","_id":"ckdzce3a60045n6zqj7jspc4a"},{"post_id":"ckdzce3900028n6zqz7lmexxi","category_id":"ckdzce37o000un6zq0odl1h04","_id":"ckdzce3a70049n6zq2vus6g55"},{"post_id":"ckdzce3900028n6zqz7lmexxi","category_id":"ckdzce3a40040n6zqqvzi0zkn","_id":"ckdzce3a8004cn6zqjiajeh01"},{"post_id":"ckdzce398002hn6zqujwb3s7d","category_id":"ckdzce3a60046n6zq2vqvhbxj","_id":"ckdzce3a8004en6zqkrrj6ggh"},{"post_id":"ckdzce39d002nn6zqxd2n4s8q","category_id":"ckdzce3a7004an6zql2cdjeny","_id":"ckdzce3aa004in6zqrteoe781"},{"post_id":"ckdzce39f002qn6zq2lsr0jby","category_id":"ckdzce3a9004fn6zqyhu0uoxc","_id":"ckdzce3aa004ln6zqe24z5q1v"},{"post_id":"ckdzce39j002xn6zqra0y1533","category_id":"ckdzce3aa004jn6zqauio3qhw","_id":"ckdzce3ac004on6zqvpwdix0h"},{"post_id":"ckdzce39y003on6zqt13e88kw","category_id":"ckdzce3a7004an6zql2cdjeny","_id":"ckdzce3ad004sn6zqmx3e8mem"}],"PostTag":[{"post_id":"ckdzce36h0003n6zqdq2y4uhw","tag_id":"ckdzce3700007n6zqz3xb32q2","_id":"ckdzce37m000rn6zqul64cctd"},{"post_id":"ckdzce36h0003n6zqdq2y4uhw","tag_id":"ckdzce37b000en6zq3vkofqpj","_id":"ckdzce37o000tn6zqi6yekd1w"},{"post_id":"ckdzce36h0003n6zqdq2y4uhw","tag_id":"ckdzce37h000jn6zq6gpdo04d","_id":"ckdzce37q000xn6zqyarvuuuw"},{"post_id":"ckdzce36u0005n6zqr530lod5","tag_id":"ckdzce37k000on6zqpdpmet9u","_id":"ckdzce3800013n6zq7j2bgqor"},{"post_id":"ckdzce36u0005n6zqr530lod5","tag_id":"ckdzce37o000vn6zq1200idae","_id":"ckdzce3810015n6zqs0nhxvz0"},{"post_id":"ckdzce3710009n6zq6foszl52","tag_id":"ckdzce37z0012n6zq4p64rr3s","_id":"ckdzce38k001sn6zqtxi2mv8l"},{"post_id":"ckdzce3710009n6zq6foszl52","tag_id":"ckdzce3840019n6zq73gsspwk","_id":"ckdzce38m001vn6zq9fu7m0ba"},{"post_id":"ckdzce3710009n6zq6foszl52","tag_id":"ckdzce388001en6zqdby3meae","_id":"ckdzce38o0020n6zqvaz93r8o"},{"post_id":"ckdzce3710009n6zq6foszl52","tag_id":"ckdzce38e001jn6zqrebmjl6b","_id":"ckdzce38q0023n6zqrbvs001y"},{"post_id":"ckdzce379000cn6zq491ohu9j","tag_id":"ckdzce38j001rn6zqq373oa36","_id":"ckdzce3920029n6zq1veyvx6u"},{"post_id":"ckdzce379000cn6zq491ohu9j","tag_id":"ckdzce38n001zn6zqyqf8fvsx","_id":"ckdzce394002bn6zq0p97gnx9"},{"post_id":"ckdzce39a002kn6zqxpdhk0wk","tag_id":"ckdzce37z0012n6zq4p64rr3s","_id":"ckdzce39f002on6zq1o19xkhw"},{"post_id":"ckdzce39a002kn6zqxpdhk0wk","tag_id":"ckdzce394002dn6zq8d8gf5cj","_id":"ckdzce39i002tn6zqs5o8mqh5"},{"post_id":"ckdzce37c000fn6zqjtf91vpd","tag_id":"ckdzce37o000vn6zq1200idae","_id":"ckdzce39m0031n6zqjnlwtsu8"},{"post_id":"ckdzce37c000fn6zqjtf91vpd","tag_id":"ckdzce394002dn6zq8d8gf5cj","_id":"ckdzce39o0033n6zqrqm0r058"},{"post_id":"ckdzce37c000fn6zqjtf91vpd","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce39q0038n6zqgoykgrfv"},{"post_id":"ckdzce37c000fn6zqjtf91vpd","tag_id":"ckdzce37k000on6zqpdpmet9u","_id":"ckdzce39s003bn6zqkobq7g1p"},{"post_id":"ckdzce37e000gn6zqkrh0bdbb","tag_id":"ckdzce39k002yn6zq92qoda5g","_id":"ckdzce39u003gn6zqedqpigh9"},{"post_id":"ckdzce39o0034n6zqdildrvu6","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce39w003jn6zqq2h7bz91"},{"post_id":"ckdzce39q0039n6zqxljx5nax","tag_id":"ckdzce37k000on6zqpdpmet9u","_id":"ckdzce39y003nn6zqcrk9uk1o"},{"post_id":"ckdzce39s003cn6zqks3c9bux","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce39z003qn6zqbc0uxjfn"},{"post_id":"ckdzce37h000kn6zqu0tbx4d0","tag_id":"ckdzce39p0036n6zq9t8pu4a6","_id":"ckdzce3a0003rn6zq35ny6gr9"},{"post_id":"ckdzce37h000kn6zqu0tbx4d0","tag_id":"ckdzce39t003en6zqfg1zrbo2","_id":"ckdzce3a2003vn6zqk1f37oar"},{"post_id":"ckdzce39w003kn6zq8oxz6g2i","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce3a3003xn6zqtxhziy4n"},{"post_id":"ckdzce37j000ln6zq0rqv6fw5","tag_id":"ckdzce39x003mn6zq40lufsii","_id":"ckdzce3a50041n6zqf3le6tuw"},{"post_id":"ckdzce37k000pn6zqbcufi4l9","tag_id":"ckdzce37z0012n6zq4p64rr3s","_id":"ckdzce3a50043n6zqh02th0ax"},{"post_id":"ckdzce37m000sn6zqs5z8o83w","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce3a60047n6zqmn48od24"},{"post_id":"ckdzce37p000wn6zqdlx4oixv","tag_id":"ckdzce3a50044n6zqdw6u40dy","_id":"ckdzce3a7004bn6zqqmf8jcjj"},{"post_id":"ckdzce37s0010n6zqjc34y1nl","tag_id":"ckdzce3a70048n6zqvhycj8ge","_id":"ckdzce3a9004gn6zqwbvea1np"},{"post_id":"ckdzce3800014n6zqytisf5mw","tag_id":"ckdzce3a70048n6zqvhycj8ge","_id":"ckdzce3ac004pn6zqj6lbdumq"},{"post_id":"ckdzce3800014n6zqytisf5mw","tag_id":"ckdzce3a9004hn6zqfzr4b7bo","_id":"ckdzce3ad004qn6zq191ccajc"},{"post_id":"ckdzce3800014n6zqytisf5mw","tag_id":"ckdzce3aa004kn6zq4bng2a9t","_id":"ckdzce3ae004tn6zqu7oluuxd"},{"post_id":"ckdzce3820016n6zqquu7joal","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce3ae004vn6zq0g5xsens"},{"post_id":"ckdzce3820016n6zqquu7joal","tag_id":"ckdzce37k000on6zqpdpmet9u","_id":"ckdzce3ae004wn6zqp4bunpkh"},{"post_id":"ckdzce3820016n6zqquu7joal","tag_id":"ckdzce37z0012n6zq4p64rr3s","_id":"ckdzce3af004yn6zqms725ttp"},{"post_id":"ckdzce3820016n6zqquu7joal","tag_id":"ckdzce394002dn6zq8d8gf5cj","_id":"ckdzce3af004zn6zq2ed276la"},{"post_id":"ckdzce385001an6zq6knm8nbx","tag_id":"ckdzce3ae004un6zqwtzmeram","_id":"ckdzce3af0051n6zquqjkhztu"},{"post_id":"ckdzce387001bn6zq3ej74k98","tag_id":"ckdzce3ae004xn6zqgfc8kmqq","_id":"ckdzce3af0053n6zqjhrsj1ya"},{"post_id":"ckdzce387001bn6zq3ej74k98","tag_id":"ckdzce3af0050n6zqxz58ijti","_id":"ckdzce3af0054n6zqaiz4c149"},{"post_id":"ckdzce389001fn6zq0e272fq5","tag_id":"ckdzce3af0052n6zqnos0p96s","_id":"ckdzce3ah0057n6zq5684oye4"},{"post_id":"ckdzce389001fn6zq0e272fq5","tag_id":"ckdzce3af0050n6zqxz58ijti","_id":"ckdzce3ah0058n6zqthkm3ffg"},{"post_id":"ckdzce38f001kn6zqjcas89wo","tag_id":"ckdzce38j001rn6zqq373oa36","_id":"ckdzce3ah005an6zq45boqfgt"},{"post_id":"ckdzce38g001mn6zq3q37n7iq","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce3ai005dn6zq4ec5znsw"},{"post_id":"ckdzce38g001mn6zq3q37n7iq","tag_id":"ckdzce3ah005bn6zqnk0iyuk0","_id":"ckdzce3ai005en6zq0fa97ths"},{"post_id":"ckdzce38h001on6zqt6h4y34c","tag_id":"ckdzce3ai005cn6zqzy5t88i0","_id":"ckdzce3ak005hn6zqq5vp2ano"},{"post_id":"ckdzce38h001on6zqt6h4y34c","tag_id":"ckdzce3af0050n6zqxz58ijti","_id":"ckdzce3ak005in6zqje6ihzk5"},{"post_id":"ckdzce38k001tn6zqz3ttmd0r","tag_id":"ckdzce3aj005gn6zqcakbsuaf","_id":"ckdzce3al005ln6zqztpuu09v"},{"post_id":"ckdzce38k001tn6zqz3ttmd0r","tag_id":"ckdzce38n001zn6zqyqf8fvsx","_id":"ckdzce3al005mn6zq396ssqk2"},{"post_id":"ckdzce38m001wn6zqr0mk8pf0","tag_id":"ckdzce3al005kn6zq7kqjp7by","_id":"ckdzce3am005on6zqi72yqx6j"},{"post_id":"ckdzce38o0021n6zqhrfhy0wm","tag_id":"ckdzce3al005nn6zqbjrxwa09","_id":"ckdzce3an005sn6zqwmuh0o9c"},{"post_id":"ckdzce38o0021n6zqhrfhy0wm","tag_id":"ckdzce3am005pn6zqfkr5pgaw","_id":"ckdzce3an005tn6zqfcidu1j8"},{"post_id":"ckdzce38o0021n6zqhrfhy0wm","tag_id":"ckdzce3am005qn6zqnm9y97lr","_id":"ckdzce3an005vn6zqkxrmsd4v"},{"post_id":"ckdzce38q0024n6zqocsv3q83","tag_id":"ckdzce3am005rn6zq4zv83px8","_id":"ckdzce3an005wn6zqpyfqrwsz"},{"post_id":"ckdzce3900028n6zqz7lmexxi","tag_id":"ckdzce3an005un6zqz6si63ll","_id":"ckdzce3aq0061n6zq8en9axua"},{"post_id":"ckdzce3900028n6zqz7lmexxi","tag_id":"ckdzce3an005xn6zq5pf031rt","_id":"ckdzce3aq0062n6zqypwsv17e"},{"post_id":"ckdzce3900028n6zqz7lmexxi","tag_id":"ckdzce3ao005yn6zqh7owybrn","_id":"ckdzce3at0064n6zq2c4l8htp"},{"post_id":"ckdzce3900028n6zqz7lmexxi","tag_id":"ckdzce3ap005zn6zqbd552pgu","_id":"ckdzce3at0065n6zqx8xw4xc9"},{"post_id":"ckdzce392002an6zq4bievvzs","tag_id":"ckdzce3ap0060n6zqqsb51yav","_id":"ckdzce3au0067n6zqa4g5x9iy"},{"post_id":"ckdzce395002fn6zq8cidseyw","tag_id":"ckdzce39a002jn6zqvhhr5u0f","_id":"ckdzce3au0068n6zqovkla1u8"},{"post_id":"ckdzce395002fn6zq8cidseyw","tag_id":"ckdzce394002dn6zq8d8gf5cj","_id":"ckdzce3au006an6zqedjvonm2"},{"post_id":"ckdzce398002hn6zqujwb3s7d","tag_id":"ckdzce3at0066n6zqvy84o4m9","_id":"ckdzce3av006cn6zqjd80wl5f"},{"post_id":"ckdzce398002hn6zqujwb3s7d","tag_id":"ckdzce3au0069n6zqqfp8xt52","_id":"ckdzce3av006dn6zq4op1ll55"},{"post_id":"ckdzce39d002nn6zqxd2n4s8q","tag_id":"ckdzce3au006bn6zqj2bbm146","_id":"ckdzce3aw006gn6zqt5o6v8yg"},{"post_id":"ckdzce39d002nn6zqxd2n4s8q","tag_id":"ckdzce3av006en6zq9dat1mkv","_id":"ckdzce3aw006hn6zqprc8pu6z"},{"post_id":"ckdzce39i002vn6zqk5xoad9n","tag_id":"ckdzce3av006fn6zqt7u9drw0","_id":"ckdzce3ax006kn6zqm4qnk85a"},{"post_id":"ckdzce39i002vn6zqk5xoad9n","tag_id":"ckdzce3af0050n6zqxz58ijti","_id":"ckdzce3ax006ln6zqckki9703"},{"post_id":"ckdzce39j002xn6zqra0y1533","tag_id":"ckdzce3aw006jn6zqkqcvw11u","_id":"ckdzce3ax006nn6zq8v4y4u32"},{"post_id":"ckdzce39m0032n6zqi1333a09","tag_id":"ckdzce3ax006mn6zqf8zsmf3q","_id":"ckdzce3ay006pn6zqc0llvom0"},{"post_id":"ckdzce39u003hn6zqp6m3zfd8","tag_id":"ckdzce3ax006on6zqw7mpj9ou","_id":"ckdzce3ay006rn6zq66fr8ylb"},{"post_id":"ckdzce39y003on6zqt13e88kw","tag_id":"ckdzce3ay006qn6zqio74xaf0","_id":"ckdzce3b0006vn6zq81yt6e8j"},{"post_id":"ckdzce39y003on6zqt13e88kw","tag_id":"ckdzce3av006en6zq9dat1mkv","_id":"ckdzce3b0006wn6zqh2yvils2"},{"post_id":"ckdzce39y003on6zqt13e88kw","tag_id":"ckdzce3aw006jn6zqkqcvw11u","_id":"ckdzce3b0006xn6zqvgapm50r"},{"post_id":"ckdzce39y003on6zqt13e88kw","tag_id":"ckdzce3b0006un6zqjg2z7n8z","_id":"ckdzce3b0006yn6zqr89ov2t2"}],"Tag":[{"name":"linux","_id":"ckdzce3700007n6zqz3xb32q2"},{"name":"rpm","_id":"ckdzce37b000en6zq3vkofqpj"},{"name":"yum","_id":"ckdzce37h000jn6zq6gpdo04d"},{"name":"jenkins","_id":"ckdzce37k000on6zqpdpmet9u"},{"name":"git","_id":"ckdzce37o000vn6zq1200idae"},{"name":"java","_id":"ckdzce37z0012n6zq4p64rr3s"},{"name":"单例模式","_id":"ckdzce3840019n6zq73gsspwk"},{"name":"设计模式","_id":"ckdzce388001en6zqdby3meae"},{"name":"线程","_id":"ckdzce38e001jn6zqrebmjl6b"},{"name":"springsession","_id":"ckdzce38j001rn6zqq373oa36"},{"name":"session","_id":"ckdzce38n001zn6zqyqf8fvsx"},{"name":"maven","_id":"ckdzce394002dn6zq8d8gf5cj"},{"name":"docker","_id":"ckdzce39a002jn6zqvhhr5u0f"},{"name":"jpa","_id":"ckdzce39k002yn6zq92qoda5g"},{"name":"RabbitMq","_id":"ckdzce39p0036n6zq9t8pu4a6"},{"name":"消息队列","_id":"ckdzce39t003en6zqfg1zrbo2"},{"name":"httpd","_id":"ckdzce39x003mn6zq40lufsii"},{"name":"thymeleaf","_id":"ckdzce3a50044n6zqdw6u40dy"},{"name":"solr","_id":"ckdzce3a70048n6zqvhycj8ge"},{"name":"solr-master","_id":"ckdzce3a9004hn6zqfzr4b7bo"},{"name":"solr-slave","_id":"ckdzce3aa004kn6zq4bng2a9t"},{"name":"性能优化","_id":"ckdzce3ae004un6zqwtzmeram"},{"name":"springAdmin","_id":"ckdzce3ae004xn6zqgfc8kmqq"},{"name":"spring cloud","_id":"ckdzce3af0050n6zqxz58ijti"},{"name":"rabbitMq","_id":"ckdzce3af0052n6zqnos0p96s"},{"name":"mysql","_id":"ckdzce3ah005bn6zqnk0iyuk0"},{"name":"spring config","_id":"ckdzce3ai005cn6zqzy5t88i0"},{"name":"spring","_id":"ckdzce3aj005gn6zqcakbsuaf"},{"name":"源码","_id":"ckdzce3al005kn6zq7kqjp7by"},{"name":"hexo","_id":"ckdzce3al005nn6zqbjrxwa09"},{"name":"githubpage","_id":"ckdzce3am005pn6zqfkr5pgaw"},{"name":"hexo-admin","_id":"ckdzce3am005qn6zqnm9y97lr"},{"name":"nutch","_id":"ckdzce3am005rn6zq4zv83px8"},{"name":"IOC容器","_id":"ckdzce3an005un6zqz6si63ll"},{"name":"依赖注入","_id":"ckdzce3an005xn6zq5pf031rt"},{"name":"DI","_id":"ckdzce3ao005yn6zqh7owybrn"},{"name":"Inversion of Control","_id":"ckdzce3ap005zn6zqbd552pgu"},{"name":"notepad","_id":"ckdzce3ap0060n6zqqsb51yav"},{"name":"plantuml","_id":"ckdzce3at0066n6zqvy84o4m9"},{"name":"atom","_id":"ckdzce3au0069n6zqqfp8xt52"},{"name":"工作效率","_id":"ckdzce3au006bn6zqj2bbm146"},{"name":"work","_id":"ckdzce3av006en6zq9dat1mkv"},{"name":"resttemplate","_id":"ckdzce3av006fn6zqt7u9drw0"},{"name":"工具","_id":"ckdzce3aw006jn6zqkqcvw11u"},{"name":"tomcat","_id":"ckdzce3ax006mn6zqf8zsmf3q"},{"name":"red hat Linux","_id":"ckdzce3ax006on6zqw7mpj9ou"},{"name":"工作","_id":"ckdzce3ay006qn6zqio74xaf0"},{"name":"tools","_id":"ckdzce3b0006un6zqjg2z7n8z"}]}}